<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>TypeScript 系列基础篇(三) 对象类型</title>
      <link href="/onlyy-blog/2022/03/02/TypeScript%E7%B3%BB%E5%88%97-%E5%9F%BA%E7%A1%80%E7%AF%87-%E4%B8%89-%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B/"/>
      <url>/onlyy-blog/2022/03/02/TypeScript%E7%B3%BB%E5%88%97-%E5%9F%BA%E7%A1%80%E7%AF%87-%E4%B8%89-%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>对象是我们组织数据的基本方式。除了常规的对象类型外，TS 还提供了<strong>只读数组</strong>、<strong>元组</strong>、<strong>属性修饰符</strong>、<strong>索引签名</strong>等知识体系。在前面的章节中，我们已经了解到了对象的基本使用。可以用<strong>字面量</strong>、<strong><code>interface</code></strong>、<strong><code>type alias</code></strong>来规定一个普通的对象类型。现在是时候了解一下常用的对象属性修饰符、类型拓展、索引签名和内置的特殊对象类型了。 还没有对象吗？那就赶紧<code>new</code>一个吧！</p><h2 id="一、属性修饰符"><a href="#一、属性修饰符" class="headerlink" title="一、属性修饰符"></a>一、<mark>属性修饰符</mark></h2><p>利用属性修饰符，我们可以增强对象的属性的约束。</p><h3 id="1-可选属性"><a href="#1-可选属性" class="headerlink" title="1. ? 可选属性"></a>1. <code>?</code> 可选属性</h3><p>可选属性我们在之前就已经有所了解。定义对象类型时，在属性名后面加上英文问号 “<code>?</code>“ ，表示该属性可选。此后，该类型的对象里可以有这个属性，也可以没有。因此，该属性除了我们给它约束了的类型之外，还可能是<code>undefined</code>，从而引发某些问题。在之前的文章中提到过，这可以通过<strong>真值校验</strong>来进行类型缩减，或者给函数的形参设置默认值，从而解决。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其中gender为可选属性</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  gender?: <span class="number">1</span> | <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以有全部属性</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">cc</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;cc&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">gender</span>: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以缺失可选属性</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">yy</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;yy&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-readonly-只读属性"><a href="#2-readonly-只读属性" class="headerlink" title="2. readonly 只读属性"></a>2. <code>readonly</code> 只读属性</h3><p>在对象的某个或某些属性前加上关键字 <strong><code>readonly</code></strong>，可以设置该属性为只读属性。<strong>对象的只读属性在<code>TS</code>里一般不允许被重新赋值</strong>。只读属性不意味着完全不能修改。如果只读属性是一个对象类型，那我们可以修改它里面的成员。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// id为只读属性，不允许重新赋值</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">idInfo</span>: &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">addr</span>: <span class="built_in">string</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以有全部属性</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">cc</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;cc&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">idInfo</span>: &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="string">&quot;42xxxx199x04xxxx1X&quot;</span>,</span><br><span class="line">    <span class="attr">addr</span>: <span class="string">&quot;Wuhan&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面这句会报错，因为cc的id信息被设置为只读属性，不可以被重新哦</span></span><br><span class="line">cc.<span class="property">idInfo</span> = &#123; <span class="attr">id</span>: <span class="string">&quot;xiao cai ji&quot;</span>, <span class="attr">addr</span>: <span class="string">&quot;beijing&quot;</span> &#125;;</span><br><span class="line"><span class="comment">// 这样修改就可以啦</span></span><br><span class="line">cc.<span class="property">idInfo</span>.<span class="property">addr</span> = <span class="string">&quot;beijing&quot;</span>;</span><br></pre></td></tr></table></figure><p>然而事实上，在<code>TS</code>里我们依然有方法可以让只读属性被重新赋值。由于<code>TS</code>的类型检查机制，在检查两个对象类型是否兼容时，只针对类型，而不会去检测属性是否有 <code>readonly</code> 。例如，下面这两个对象类型是完全相互兼容的。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// id为只读属性，不允许重新赋值</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">idInfo</span>: &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">addr</span>: <span class="built_in">string</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 没有readonly属性，所有成员都可以被赋值</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">People</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">idInfo</span>: &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">addr</span>: <span class="built_in">string</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意Person的属性是只读的</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">person</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;gg&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">15</span>,</span><br><span class="line">  <span class="attr">idInfo</span>: &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="string">&quot;qaq&quot;</span>,</span><br><span class="line">    <span class="attr">addr</span>: <span class="string">&quot;zzZ&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 声明一个People类型的对象person，它的属性不是只读的</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">people</span>: <span class="title class_">People</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型兼容，具有只读属性的person可以被赋值给people</span></span><br><span class="line"><span class="comment">// 此时people是People类型，其属性可以修改；person是Person类型，其属性只读</span></span><br><span class="line"><span class="comment">// 熟悉JS引用类型的同学们都知道，people和person是同一个对象</span></span><br><span class="line">people = person;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改people的属性，我们发现person也会被相应修改，因为他们实际是同一个对象</span></span><br><span class="line">people.<span class="property">name</span> = <span class="string">&quot;pp&quot;</span>;</span><br><span class="line">people.<span class="property">age</span> = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p>从这个栗子中可以看到，我们可以通过一个<strong>不具有相应只读属性，且属性类型能够兼容</strong>的对象，来重写另一个对象的只读属性。因此，在<strong>使用只读属性时，一定要注意这种情况</strong>，以免引起超出意料的困扰。</p><h2 id="二、索引签名"><a href="#二、索引签名" class="headerlink" title="二、索引签名"></a>二、<mark>索引签名</mark></h2><p>在上一篇文章<a href="https://juejin.cn/post/7070172611849748517">TS 中的函数签名，函数重载，泛型函数，你都了解多少？Typescript 系列：(二)函数篇 </a>中，我们了解了函数签名。和这里的<strong>索引签名</strong>多多少少有些相像。</p><p>我们在使用<strong><code>interface</code></strong>或者<strong><code>type alias</code></strong>定义某个对象类型时，以往的做法是列举出所有的属性名并规定它们的值的类型。但是有时候，我们不知道对象里会有哪些属性，无法逐个列出。此时，我们可以使用<mark><strong>索引签名</strong></mark>，来<strong>规定属性名的类型</strong>和对应属性值的类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过索引签名，我们可以定义一个伪数组的</span></span><br><span class="line"><span class="comment">// 规定了属性名必须是number</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">StringArray</span> &#123;</span><br><span class="line">  [<span class="attr">index</span>: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意和真数组区分开来</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">strArr1</span>: <span class="title class_">StringArray</span> = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&quot;100分&quot;</span>,</span><br><span class="line">  <span class="number">5</span>: <span class="string">&quot;95分&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 报错，因为属性名grades不是number类型，不符合StringArray类型的约束</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">strArr2</span>: <span class="title class_">StringArray</span> = &#123;</span><br><span class="line">  <span class="attr">grades</span>: <span class="string">&quot;100分&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当我们使用<code>number</code>类型作为属性名时，<code>JS</code>在把他放进对象之前<strong>会先将其转化为<code>string</code>类型</strong>。索引签名可以和指定属性名,以及属性修饰符混合使用，此时，对象中必须包含列举出的属性(可选属性除外)，而且可拓展符合索引签名的约束的属性。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  [<span class="attr">x</span>: <span class="built_in">string</span>]: <span class="built_in">string</span>;</span><br><span class="line">  <span class="number">100</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="number">50</span>?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">cc</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="number">100</span>: <span class="string">&quot;满意100&quot;</span>,</span><br><span class="line">  <span class="number">6</span>: <span class="string">&quot;我是由索引签名拓展的属性&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">yy</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&quot;QAQ&quot;</span>,</span><br><span class="line">  <span class="number">100</span>: <span class="string">&quot;555~&quot;</span>,</span><br><span class="line">  <span class="number">50</span>: <span class="string">&quot;0.0&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>索引签名可以不止一套，但是<strong>各个索引签名的返回值应该互相兼容</strong>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  [<span class="attr">x</span>: <span class="built_in">string</span>]: <span class="built_in">string</span>;</span><br><span class="line">  [<span class="attr">y</span>: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以<strong>在索引签名的签名加上<code>readonly</code>关键字，使被签名的属性变为只读属性。</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> [<span class="attr">x</span>: <span class="built_in">number</span>]: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">cc</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="number">2</span>: <span class="string">&quot;cc&quot;</span>,</span><br><span class="line">  <span class="number">5</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="number">10</span>: <span class="string">&quot;boi&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="三、类型拓展"><a href="#三、类型拓展" class="headerlink" title="三、类型拓展"></a>三、<mark>类型拓展</mark></h2><p>我们可以从已有的对象类型的配置中，生成一个全新的类型，使其不仅含有原来类型的所有属性，还能拥有自己独有的属性。这样可以方便地实现类型复用，避免过多地重复敲代码，提高我们的工作效率。在定义新类型时，<strong>使用 <code>interface</code> 和 <code>type</code> 关键字，实现类型拓展的方式会有差别</strong>。</p><h3 id="1-类型继承"><a href="#1-类型继承" class="headerlink" title="1. 类型继承"></a>1. 类型继承</h3><p>使用<strong><code>interface</code></strong>关键字声明的对象类型，可以通过<strong><code>extends</code></strong>关键字来继承其它的对象类型，从而<strong>直接获得父类型的所有属性配置、属性签名，而不必重复列举一遍</strong>。<strong>可以同时继承多个对象类型</strong>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> B &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C类型继承A类型，包含name属性，不添加其它属性</span></span><br><span class="line"><span class="keyword">interface</span> C <span class="keyword">extends</span> A &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CC类型继承A，B类型，包含name, age, 以及自己列举的gender属性</span></span><br><span class="line"><span class="keyword">interface</span> CC <span class="keyword">extends</span> A, B &#123;</span><br><span class="line">  <span class="attr">gender</span>: <span class="number">1</span> | <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-类型交叉"><a href="#2-类型交叉" class="headerlink" title="2. 类型交叉"></a>2. 类型交叉</h3><p>通过<strong><code>type</code></strong>关键字给一个对象类型起<strong>别名</strong>时，使用 <code>&amp;</code> 符号来连接多个类型，从而产生一个新类型，新的类型包含所有其它对象类型的属性，即类型交叉。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> B &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类型CC包含name和age属性</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">CC</span> = A &amp; B;</span><br></pre></td></tr></table></figure><p>值得一提的是，如果 <code>&amp;</code> 连接的是简单联合类型，则产生的新类型是 <code>&amp;</code> 符号两边类型的公有类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">type</span> B = <span class="built_in">string</span>[] | <span class="built_in">number</span>;</span><br><span class="line"><span class="comment">// C是A和B共有的类型，number类型</span></span><br><span class="line"><span class="keyword">type</span> C = A &amp; B;</span><br></pre></td></tr></table></figure><p>这一点 和 <code>&amp;</code>在对象类型之间的使用看起来完全不同，起初我也有些疑惑。但是我们可以从本质上来思考，就不再有疑惑了。在关键字 type 定义的类型别名中，使用 <code>&amp;</code> 符号连接已有的类型可以产生一个新的类型，这个<strong>新类型需要同时满足 <code>&amp;</code> 符号两边的类型的约束</strong>。</p><p>因此，在<strong>对象类型的栗子</strong>中，新类型<code>CC</code>既需要满足<code>A</code>类型的约束 (因此<code>CC</code>必须有<code>A</code>的所有属性)，又必须满足类型 B 的约束 (因此必须含有类型 B 的所有属性)，即<code>CC</code>具有<code>A</code>和<code>B</code>的所有属性。</p><p>而在<strong>简单联合类型</strong>的栗子中，新类型<code>C</code>既要满足 A 的类型约束 (要么<code>C</code>是<code>number</code>, 要么是<code>string</code>)，又要满足类型<code>B</code>的约束 (要么<code>C</code>是字符串数组<code>string[]</code>，要么是<code>number</code>)，因此最终得到的<code>C</code>是<code>number</code>。</p><h2 id="四、泛型对象"><a href="#四、泛型对象" class="headerlink" title="四、泛型对象"></a>四、<mark>泛型对象</mark></h2><p><strong>泛型</strong>：使用尖括号<code>&lt;&gt;</code>来声明类型参数 (可以有多个)来表示暂时未知的类型，在实际声明变量时传入相应的类型 (或者由<code>TS</code>自动推论) 来替换相应出现该类型参数的地方，从而将抽象的、未知的类型替换为具体的、已知的类型。一个类型参数指代一种类型，例如<code>&lt;T,K,U,...&gt;</code>分别指代一种暂时未知的类型。将泛型用于定义对象类型，便得到了<strong>泛型对象</strong>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型T代表一种暂时未知的类型</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">PersonInfo</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">info</span>: T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 传入类型变量string，这时候string就会在相应的地方替换原来的T</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">p1</span>: <span class="title class_">PersonInfo</span>&lt;<span class="built_in">string</span>&gt; = &#123;</span><br><span class="line">  <span class="attr">info</span>: <span class="string">&quot;cc&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">p2</span>: <span class="title class_">PersonInfo</span>&lt;<span class="built_in">number</span>&gt; = &#123;</span><br><span class="line">  <span class="attr">info</span>: <span class="number">18</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">p3</span>: <span class="title class_">PersonInfo</span>&lt;<span class="string">&quot;男&quot;</span> | <span class="string">&quot;女&quot;</span>&gt; = &#123;</span><br><span class="line">  <span class="attr">info</span>: <span class="string">&quot;男&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>泛型对象常用于泛型函数，可参考<a href="https://juejin.cn/post/7070172611849748517">TS 中的函数签名，函数重载，泛型函数，你都了解多少？Typescript 系列：(二)函数篇</a>。</p><p><strong>泛型同样可在类型别名中使用</strong>。而类型别名除了定义对象类型之外，还能用泛型来定义各种其它类型。因此，我们可以<strong>使用泛型嵌套来定义更为复杂的类型结构</strong> (孩子已经哭了，难怪都说，玩会了泛型，<code>TS</code>就学完了一半)。本文主要介绍对象类型，关于泛型，以后再专门介绍。如下是官网的一个栗子。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">OrNull</span>&lt;<span class="title class_">Type</span>&gt; = <span class="title class_">Type</span> | <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">OneOrMany</span>&lt;<span class="title class_">Type</span>&gt; = <span class="title class_">Type</span> | <span class="title class_">Type</span>[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">OneOrManyOrNull</span>&lt;<span class="title class_">Type</span>&gt; = <span class="title class_">OrNull</span>&lt;<span class="title class_">OneOrMany</span>&lt;<span class="title class_">Type</span>&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">OneOrManyOrNullStrings</span> = <span class="title class_">OneOrManyOrNull</span>&lt;<span class="built_in">string</span>&gt;;</span><br></pre></td></tr></table></figure><h2 id="五、数组类型"><a href="#五、数组类型" class="headerlink" title="五、数组类型"></a>五、数组类型</h2><p>我们知道，数组是一种特殊的对象类型。上面简单了解了下泛型，那么我们现在就能知道，原来所谓数值数组、字符串数组等 (<code>number[]</code>，<code>string[]</code> )是泛型数组<code>Array&lt;number&gt;</code>，<code>Array&lt;string&gt;</code>的简写。现代<code>JS</code>也提供了其它新类型的泛型结构，如<code>Map&lt;T, K&gt;</code>，<code>Set&lt;T&gt;</code>，<code>Promise&lt;T&gt;</code>等，类型参数的数量都取决于各类型的自身行为表现。</p><h3 id="1-ReadonlyArray-只读数组"><a href="#1-ReadonlyArray-只读数组" class="headerlink" title="1. ReadonlyArray 只读数组"></a>1. <code>ReadonlyArray</code> 只读数组</h3><p>只读数组是<code>TS</code>提供的一种特殊的数组，它的任何成员都不能被修改。</p><ul><li>无法进行新增、删除、替换等操作，<code>push</code>、<code>pop</code>等修改自身的方法都无法使用。</li><li>可以使用不修改自身的数组方法。例如使用<code>slice</code>方法，返回一个普通的数组</li><li>代表一种类型，无法当作构造函数使用，不能使用<code>new</code>操作符。</li><li>在声明一个只读数组类型的变量时需指定类型参数，只读数组里只能存放该类型的值。</li><li>只读数组类型的变量本身可以接收普通数组的赋值。</li><li>普通数组不能接收只读数组的赋值</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定类型参数number，即该只读数组里只</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="title class_">ReadonlyArray</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">123</span>];</span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line">a.<span class="title function_">pop</span>();</span><br><span class="line"><span class="comment">// 可以使用slice方法</span></span><br><span class="line"><span class="keyword">let</span> cc = a.<span class="title function_">slice</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该变量可以用普通重新赋值</span></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">let</span> val = <span class="keyword">new</span> <span class="title class_">ReadonlyArray</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">aa</span>: <span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">456</span>];</span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line">aa = a;</span><br></pre></td></tr></table></figure><h3 id="2-Tuple-Types-元组"><a href="#2-Tuple-Types-元组" class="headerlink" title="2. Tuple Types 元组"></a>2. <code>Tuple Types</code> 元组</h3><p><mark><strong>元组</strong></mark>类型是另一种特殊的数组类型，<strong>一般来说</strong>它可以存储不同类型的成员，<strong>限定了数组的长度及每个成员的类型</strong>。(<strong>普通数组也可以通过指定联合类型的类型参数，从而存放不同类型的成员)</strong>。元组的成员是可以被修改，可以调用一系列的数组方法。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">UserInfo</span> = [<span class="built_in">string</span>, <span class="built_in">number</span>, <span class="number">1</span> | <span class="number">2</span>];</span><br></pre></td></tr></table></figure><p>这里得<code>UserInfo</code>便是一个元组类型，规定了元组里<strong>有且仅有</strong>三个成员，索引为<code>0</code>的成员是<code>string</code>类型，索引为<code>1</code>的成员是<code>number</code>类型，索引为<code>2</code>的成员 是字面量联合类型 <code>1 | 2</code> 。</p><ul><li>元组类型可以被解构。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">introduceUser</span>(<span class="params">info: UserInfo</span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [name, age, gender] = info;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`我是<span class="subst">$&#123;name&#125;</span>，今年<span class="subst">$&#123;age&#125;</span>岁啦`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>元组也可以指定可选成员</strong>：</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第三个成员可选</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UserInfo</span> = [<span class="built_in">string</span>, <span class="built_in">number</span>, (<span class="number">1</span> | <span class="number">2</span>)?];</span><br></pre></td></tr></table></figure><ul><li>元组中可使用剩余参数，来<strong>指定某个或某些索引位置的成员的类型和其它成员的类型</strong>。此时，元组没有长度限制。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">FamilyMember</span> = <span class="built_in">string</span>[];</span><br><span class="line"><span class="comment">// 指定索引0处的类型为string，索引1处的类型为number，剩余类型为FamilyMember</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UserInfo1</span> = [<span class="built_in">string</span>, <span class="built_in">number</span>, ...<span class="title class_">FamilyMember</span>[]];</span><br><span class="line"><span class="comment">// 同理</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UserInfo2</span> = [<span class="built_in">string</span>, <span class="built_in">number</span>, ...<span class="title class_">FamilyMember</span>[], <span class="built_in">boolean</span>];</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UserInfo3</span> = [...<span class="title class_">FamilyMember</span>[], <span class="built_in">string</span>, <span class="built_in">number</span>];</span><br></pre></td></tr></table></figure><ul><li><p><strong><code>readonly</code></strong> 只读元组类型</p><p>我们可以用类似 数组类型的简写方式 来声明一个只读元组：<strong><code>readonly [string, number]</code></strong>，使元组的成员变为只读成员，不可修改。<strong><code>readonly</code>关键字只能用于字面量数组或字面量元组类型之前，不可用于类型别名之前</strong>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ok</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">cc</span>: <span class="keyword">readonly</span> [<span class="built_in">string</span>, <span class="built_in">number</span>] = [<span class="string">&quot;cc&quot;</span>, <span class="number">18</span>];</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">yy</span>: <span class="keyword">readonly</span> <span class="title class_">UserInfo3</span> = [[<span class="string">&quot;dd&quot;</span>], <span class="string">&quot;1&quot;</span>, <span class="number">1</span>];</span><br><span class="line"><span class="comment">// 用于字面量元组之前，ok</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">yy</span>: <span class="keyword">readonly</span> [...<span class="title class_">FamilyMember</span>[], <span class="built_in">string</span>, <span class="built_in">number</span>] = [[<span class="string">&quot;dd&quot;</span>], <span class="string">&quot;1&quot;</span>, <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错，只读属性不可修改</span></span><br><span class="line">cc[<span class="number">0</span>] = <span class="string">&quot;yy&quot;</span>;</span><br></pre></td></tr></table></figure><p>此外，如果我们对数组使用<mark><strong>常量断言</strong></mark>：<strong><code>as const</code></strong>，该数组的类型也会变为只读元组。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> yy = [<span class="string">&quot;yy&quot;</span>, <span class="number">18</span>] <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错，只读属性不可修改</span></span><br><span class="line">yy[<span class="number">0</span>] = <span class="string">&quot;cc&quot;</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>ReadonlyArray</code>、<code>tuple</code>、<code>readonly tuple</code> 的主要区别。</p><ul><li><code>ReadonlyArray</code> 只读数组：不可修改数组成员，不可增删改，不会为每个数组成员单独指定类型，可以被重新赋值；</li><li><code>tuple</code> 元组：一般指定了长度和各个成员的类型，使用剩余参数法来声明元组类型时则没有限制长度；元组可以修改成员的值；可以被重新赋值；</li><li><code>readonly tuple</code>：一般指定了长度和各个成员的类型，使用剩余参数法来声明元组类型时则没有限制长度，不可修改成员的值，不可被重新赋值；</li></ul></li></ul><p>关于对象类型就先分享到这里啦。如果觉得我的文章有不妥之处，欢迎在评论区留言指正。下一期聊聊<strong>泛型</strong>，不见不散。</p>]]></content>
      
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TS系列基础篇(一) TS类型指南</title>
      <link href="/onlyy-blog/2022/03/01/Typescript%E7%B3%BB%E5%88%97-%E5%9F%BA%E7%A1%80%E7%AF%87-%E4%B8%80-TS%E7%B1%BB%E5%9E%8B%E6%8C%87%E5%8D%97/"/>
      <url>/onlyy-blog/2022/03/01/Typescript%E7%B3%BB%E5%88%97-%E5%9F%BA%E7%A1%80%E7%AF%87-%E4%B8%80-TS%E7%B1%BB%E5%9E%8B%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<p>这段时间以来，TS 的发展可谓是如日中天，本想偷个懒去看看别人写的分享贴来学习，找了近十篇之后，发现要么是比较浅显，要么有些偏差，没有找到很满意的。于是决定去看<a href="https://www.typescriptlang.org/docs/handbook/declaration-files/consumption.html#consuming">官方文档</a>。学习了一段时间后，准备写一个系列，从基础类型，对象，函数，模块等 TS 知识，到在<code>vue</code>、<code>react</code>中的应用，供有需要的同学们参考。其中，我套用了不少官方文档的示例，觉得我的学习经验不好或不正确的朋友，欢迎批评指正。</p><p><code>TS</code>是<code>JS</code>的超集。在学 TS 之前，最好有一定的<code>JS</code>基础。本篇只介绍<code>typescript</code>的安装和各种基础类型。需要了解其它内容的同学可以看其它篇章或查阅官方文档。</p><p>[toc]</p><h2 id="一-、安装与编译"><a href="#一-、安装与编译" class="headerlink" title="(一)、安装与编译"></a>(一)、安装与编译</h2><p>想要使用<code>TS</code>，得先会安装。Typescript 需要<code>node</code>环境，确保你已经安装了<code>node</code>。如果还没有安装<code>node</code>，可以去<a href="[`Node.js`](https://nodejs.org/zh-cn/"><code>Node.js</code>官网</a>下载，傻瓜式安装。</p><p>打开项目目录进行初始化：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init <span class="literal">-y</span></span><br></pre></td></tr></table></figure><p>官方推荐了<code>npm</code>，<code>yarn</code>，<code>pnpm</code>三种工具，任选其一即可（<code>npm</code>工具为<code>node</code>自带的包管理工具，可自由使用；<code>yarn</code>或<code>pnpm</code>工具需要提前安装）。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># with npm</span></span><br><span class="line">npm install typescript <span class="literal">--save-dev</span></span><br><span class="line"><span class="comment"># with yarn</span></span><br><span class="line">yarn add typescript <span class="literal">--dev</span></span><br><span class="line"><span class="comment"># with pnpm</span></span><br><span class="line">pnpm add typescript <span class="literal">-D</span></span><br></pre></td></tr></table></figure><p>在安装 ts 时，编译工具<code>tsc</code>也会被自动安装。待安装完成，在项目根目录下新建一个<code>app.ts</code>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.ts</span></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;app&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">charAt</span>(<span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>即可通过以下任一方式运行<code>tsc</code>，编译成功后会在和<code>app.ts</code>同级目录下多出一个<code>app.js</code>文件。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前目录下的app.ts文件编译为app.js</span></span><br><span class="line"><span class="comment"># npm</span></span><br><span class="line">npx tsc app.ts</span><br><span class="line"><span class="comment"># yarn</span></span><br><span class="line">yarn tsc app.ts</span><br><span class="line"><span class="comment"># pnpm</span></span><br><span class="line">pnpm tsc app.ts</span><br></pre></td></tr></table></figure><p><code>app.js</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;app&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">charAt</span>(<span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>这个<code>js</code>文件和<code>app.ts</code>看起来没有差别，这是因为我们没有在<code>app.ts</code>里没有进行类型约束。与类型的相关内容会在后面谈到。现在我们来让<code>app.ts</code>出一点“错误”，将<code>str</code>换成数组，编辑器会把错误代码用红色波浪线标出，如果此时在命令行运行<code>yarn tsc app.ts</code>，控制台便会报错。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.ts</span></span><br><span class="line"><span class="keyword">const</span> str = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;p&quot;</span>, <span class="string">&quot;p&quot;</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">charAt</span>(<span class="number">0</span>)); <span class="comment">// charAt会被</span></span><br></pre></td></tr></table></figure><p>尽管如此，报错了的代码依旧会被编译成<code>js</code>文件。我们可以在<code>tsc</code>命令后加上编译的相关配置指令来进行控制。比如，加上<strong><code>--noEmitOnError</code></strong>之后，一旦报错便不会生成<code>js</code>文件。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc <span class="literal">--noEmitOnError</span> hello.ts</span><br></pre></td></tr></table></figure><p>但是 ts 的编译配置项非常多，如果每次都通过在命令行加入指令来进行相关控制，无疑非常繁琐。因此我们可以在<strong><code>tsconfig.json</code></strong>里编写相关配置，这样我们执行<code>tsc</code>命令时，编译器会默认从当前目录逐步向上层目录查找并读取<code>tsconfig.json</code>里的配置项。</p><h2 id="二-、配置文件：tsconfig-json"><a href="#二-、配置文件：tsconfig-json" class="headerlink" title="(二)、配置文件：tsconfig.json"></a>(二)、配置文件：<code>tsconfig.json</code></h2><p>在运行<code>tsc</code>命令时，我们可以在后面添加指令来指定相关配置。但是我们会更倾向于在<code>tsconfig.json</code>里对相关指令进行配置，以减少重复、繁琐的操作。在<code>Vue</code>、<code>React</code>等框架搭建的项目里，一般都已生成初步配置好了的<code>tsconfig.json</code>文件。本篇只进行解基础内容的分享，有关配置的章节将在后续推出。</p><h2 id="三-、类型基础"><a href="#三-、类型基础" class="headerlink" title="(三)、类型基础"></a>(三)、类型基础</h2><p>这里介绍部分 TS 基础类型，关于类型的进阶将在后续篇章中单独介绍。注意不要将基础类型和 js 基本数据类型混为一谈。基础类型可以理解为 ts 内置的各种类型，而非我们人为定义出的类型。TS 有多种基础类型，这些类型可以用来进行组合，从而得到我们需要的人为定义的类型。TS 在声明变量时，在变量名后加上冒号<mark>: </mark>和类型名来进行变量的类型注释。如果不添加类型注释，则 TS 会根据变量的初始值进行<mark><strong>类型推论</strong></mark>，自动推断出该变量属于什么类型。如果也没有初始值，则会被推断为<strong>any</strong>类型。</p><h3 id="1-原有的基本数据类型"><a href="#1-原有的基本数据类型" class="headerlink" title="1. 原有的基本数据类型"></a>1. 原有的基本数据类型</h3><ul><li><strong><code>string</code></strong>：字符串类型，注意<code>String</code>在<code>js</code>里已经有特殊意义了，而小写的<code>string</code>才是<code>Typescript</code>用来表示字符串的类型名称，即在注释变量类型为字符串时，使用小写的<code>string</code>，而不是大写的<code>String</code>，注意不要混淆了两者；<code>number</code>和<code>boolean</code>同理。</li><li><strong><code>number</code></strong>：数字类型；</li><li><p><strong><code>boolean</code></strong>：布尔类型；</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明变量类型，可以不赋初值，后续给num赋的值必须是number类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">num</span>: <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">str</span>: <span class="built_in">string</span> = <span class="string">&quot;typescript&quot;</span>;</span><br><span class="line"><span class="comment">// 类型推断：TS会自动推断出bool的类型为boolean</span></span><br><span class="line"><span class="keyword">let</span> bool = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-Array"><a href="#2-Array" class="headerlink" title="2. Array"></a>2. <code>Array</code></h3><p><code>Array</code>是数组类型，属于对象类型的一种。由于数组内会有数组成员，因此，在声明数组变量的时候，还要给数组成员添加类型注释，一般有两种常见方式：<strong><code>Type[]</code></strong>、<strong><code>Array&lt;Type&gt;</code></strong>。后者涉及<strong>泛型</strong>概念，将在后续介绍。其中，<code>Type</code>指代数组成员的类型，可以是基础类型，也可以是人为定义的类型 (关于数组的变形，元组类型，将在对象类型的章节介绍)。例如，要声明一个存放字符串的数组变量：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">arr1</span>: <span class="built_in">string</span>[];</span><br><span class="line"><span class="comment">// 也可以像下面</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr2</span>: <span class="title class_">Array</span>&lt;<span class="built_in">string</span>&gt;;</span><br></pre></td></tr></table></figure><h3 id="3-object"><a href="#3-object" class="headerlink" title="3. object"></a>3. <code>object</code></h3><p>对象类型是我们平时更为常见的类型。在本篇只给出一些简单定义，后续篇章中会进行单独介绍。一个对象类型的变量可以通过键值对来存储多个数据。定义一个对象类型，可以简单地列出它的各个属性及属性的类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个包含name, age, gender属性的变量obj</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>: &#123; <span class="attr">name</span>: <span class="built_in">string</span>; <span class="attr">age</span>: <span class="built_in">number</span>; <span class="attr">gender</span>: <span class="string">&quot;gg&quot;</span> | <span class="string">&quot;mm&quot;</span> &#125;;</span><br></pre></td></tr></table></figure><p>之后给 obj 赋值时<strong>必须有且只能有</strong><code>name</code>，<code>age</code>，<code>gender</code>三个属性，且属性值应为相应的类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 会报错,多了一个beauty属性,因此类型不合</span></span><br><span class="line">obj = &#123; <span class="attr">name</span>: <span class="string">&quot;yy&quot;</span>, <span class="attr">age</span>: <span class="number">22</span>, <span class="attr">gender</span>: <span class="string">&quot;mm&quot;</span>, <span class="attr">beauty</span>: <span class="number">100</span> &#125;;</span><br><span class="line"><span class="comment">// 报错，缺少了gender属性</span></span><br><span class="line">obj = &#123; <span class="attr">name</span>: <span class="string">&quot;yy&quot;</span>, <span class="attr">age</span>: <span class="number">22</span> &#125;;</span><br><span class="line"><span class="comment">// 正确赋值</span></span><br><span class="line">obj = &#123; <span class="attr">name</span>: <span class="string">&quot;yy&quot;</span>, <span class="attr">age</span>: <span class="number">22</span>, <span class="attr">gender</span>: <span class="string">&quot;mm&quot;</span> &#125;;</span><br></pre></td></tr></table></figure><p>如果想要让某个属性变为可选项，则可以在定义对象类型时在属性名后使用问号”?”：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将gender定义为可选项</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>: &#123; <span class="attr">name</span>: <span class="built_in">string</span>; <span class="attr">age</span>: <span class="built_in">number</span>; gender?: <span class="string">&quot;gg&quot;</span> | <span class="string">&quot;mm&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line">obj = &#123; <span class="attr">name</span>: <span class="string">&quot;yy&quot;</span>, <span class="attr">age</span>: <span class="number">22</span>, <span class="attr">gender</span>: <span class="string">&quot;mm&quot;</span> &#125;;</span><br><span class="line"><span class="comment">// 也正确，因为gender是可选的</span></span><br><span class="line">obj = &#123; <span class="attr">name</span>: <span class="string">&quot;yy&quot;</span>, <span class="attr">age</span>: <span class="number">22</span> &#125;;</span><br></pre></td></tr></table></figure><p>在某个属性被定义为可选项之后，一旦给该对象赋值时，没有传入该属性，它的取值便会成为<code>undefined</code> (注意<strong>这与一开始边定义<code>gender: &#39;gg&#39; | &#39;mm&#39; | undefined</code>不同</strong>。)</p><p>使用可选项有些地方需要注意，如<strong>在函数的形参中</strong>存在可选项，此时由于<code>gender</code>属性可能为<code>undefined</code>，我们在使用时需要在该属性后面加上英文感叹号”<code>!</code>“进行<strong>非空断言</strong>，明确它不是<code>undefined</code>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">obj: &#123; name: <span class="built_in">string</span>; age: <span class="built_in">number</span>; gender?: <span class="string">&quot;gg&quot;</span> | <span class="string">&quot;mm&quot;</span> &#125;</span>) &#123;</span><br><span class="line">  <span class="comment">// 使用!进行非空断言</span></span><br><span class="line">  obj.<span class="property">gender</span>!.<span class="title function_">replace</span>(<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-Union-Types-联合类型"><a href="#4-Union-Types-联合类型" class="headerlink" title="4. Union Types 联合类型"></a>4. <code>Union Types</code> 联合类型</h3><p><code>Union Types</code>是指使用 “<code>|</code>“符号来把多个类型联合成一个类型，一个联合类型的变量，其值可以是联合类型的任何一个子类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义a为联合类型，则a可以是string类型也可以是number类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"><span class="comment">// a可以是string</span></span><br><span class="line">a = <span class="string">&quot;union types&quot;</span>;</span><br><span class="line"><span class="comment">// a也可以是number</span></span><br><span class="line">a = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>在<strong>函数的形参中</strong>使用联合类型时有一些注意事项，如在上面的例子中，<code>a</code> 的类型是<code>string | number</code>，此时<code>a</code>无法调用字符串方法，因为<code>a</code>有可能是一个<code>number</code>；同理，也不能直接调用数字类型的方法。当然，也不能直接赋值给<code>string</code>类型的变量或者<code>number</code>类型的变量。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"><span class="comment">// a可以是string</span></span><br><span class="line">a = <span class="string">&quot;union types&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">b</span>: <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>: <span class="built_in">number</span>;</span><br><span class="line"><span class="comment">// 当开启了严格空值检查时，以下两次赋值都不合法</span></span><br><span class="line">b = a;</span><br><span class="line">c = a;</span><br></pre></td></tr></table></figure><p>当然，如果每个子类型都具有共同的方法，则可以调用该共同的方法。例如：数组和字符串都具有<code>slice</code>方法，则联合类型<code>string | number[]</code> 的变量可以调用<code>slice</code>方法。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params">obj: <span class="built_in">string</span> | <span class="built_in">number</span>[]</span>) &#123;</span><br><span class="line">  <span class="comment">// 可以直接调用slice方法</span></span><br><span class="line">  <span class="keyword">const</span> a = obj.<span class="title function_">slice</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-Type-Alias-类型别名"><a href="#5-Type-Alias-类型别名" class="headerlink" title="5. Type Alias 类型别名"></a>5. <code>Type Alias</code> 类型别名</h3><p>使用<strong><code>type</code></strong>关键字给你的类型起一个别名，以后就可以使用别名来指代这个类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Point</span> = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">ID</span> = <span class="built_in">number</span> | <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类型别名Point</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">p</span>: <span class="title class_">Point</span> = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">123</span>,</span><br><span class="line">  <span class="attr">y</span>: <span class="number">222</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="6-Interfaces"><a href="#6-Interfaces" class="headerlink" title="6. Interfaces"></a>6. Interfaces</h3><p>通过关键字<strong><code>interface</code></strong>，来定义一个接口，实际是一个对象类型，用于规定一个对象的形状。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printCoord</span>(<span class="params">pt: Point</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;The coordinate&#x27;s x value is &quot;</span> + pt.<span class="property">x</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;The coordinate&#x27;s y value is &quot;</span> + pt.<span class="property">y</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">printCoord</span>(&#123; <span class="attr">x</span>: <span class="number">100</span>, <span class="attr">y</span>: <span class="number">100</span> &#125;);</span><br></pre></td></tr></table></figure><p>简单说说<strong><code>interface</code>与类型别名的区别</strong>：</p><ul><li><code>interface</code> 可以通过 <strong><code>extends</code></strong>关键字来<strong>继承</strong>另一个<code>interface</code>，而<code>type</code>通过 <code>&amp;</code>符号来连接不同的对象属性；</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承Animal接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">skull</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承了Animal接口的属性name</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">dog</span>: <span class="title class_">Dog</span> = &#123;</span><br><span class="line">  <span class="attr">skull</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;wangcai&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型别名通过&amp;符号来拓展属性</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Dog2</span> = <span class="title class_">Animal</span> &amp; &#123;</span><br><span class="line">  <span class="attr">skull</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>interface</code>可以进行拓展，<code>Type</code>不可以</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">skull</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拓展interface的内容</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时Dog类型包含name,skull,age三个</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">dog</span>: <span class="title class_">Dog</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;wangcai&quot;</span>,</span><br><span class="line">  <span class="attr">skull</span>: <span class="number">12</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个Dog2类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Dog2</span> = &#123;</span><br><span class="line">  <span class="attr">skull</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会报错，Dog2重复了</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Dog2</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>interface</code>定义对象的形状，<code>type</code>不仅可以用于对象，也可以用于其它类型</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">TypeA</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TypeB</span> = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TypeC</span> = <span class="title class_">TypeA</span> | <span class="title class_">TypeB</span>;</span><br></pre></td></tr></table></figure><h3 id="7-Intersection-Types-交叉类型"><a href="#7-Intersection-Types-交叉类型" class="headerlink" title="7. Intersection Types 交叉类型"></a>7. <code>Intersection Types</code> 交叉类型</h3><p>用 <code>&amp;</code> 符号来连接多个类型，属于交叉类型 <code>A &amp; B</code> 的变量，既满足<code>A</code>的约束，又满足<code>B</code>的约束。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">TypeA</span> = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TypeB</span> = <span class="title class_">Array</span>&lt;<span class="built_in">boolean</span>&gt; | <span class="built_in">number</span>;</span><br><span class="line"><span class="comment">// TypeC既满足TypeA又满足TypeB，因此TypeC是number</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TypeC</span> = <span class="title class_">TypeA</span> &amp; <span class="title class_">TypeB</span>;</span><br><span class="line"><span class="comment">// a是number类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="title class_">TypeC</span> = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// b是TypeA类型，它的值是个string，因此不能赋值给a</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">b</span>: <span class="title class_">TypeA</span> = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">a = b; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>也可以用来拓展对象类型的属性：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> B = &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">gender</span>: <span class="string">&quot;男&quot;</span> | <span class="string">&quot;女&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 类型C是既满足A又满足B，即C既包含A的所有属性，又包含B的所有属性，</span></span><br><span class="line"><span class="comment">// 从而实现属性拓展</span></span><br><span class="line"><span class="keyword">type</span> C = A &amp; B;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>: C = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;cc&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">gender</span>: <span class="string">&quot;男&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意 <strong><code>&amp;</code> 和 | 的区别</strong>：”<code>&amp;</code>“可以合并多个对象类型的属性，使得到的新的对象类型包含其它所有类型的全部属性；”<code>&amp;</code>“可以获得多个类型之间的公共子类型；”<code>|</code>“可以联合多个类型，得到的新类型的值，只需满足其中一种子类型即可。</p><h3 id="8-Literal-Types-字面量类型"><a href="#8-Literal-Types-字面量类型" class="headerlink" title="8. Literal Types 字面量类型"></a>8. <code>Literal Types</code> 字面量类型</h3><p>通过字面量来定义类型，字面量的值可以是任意一个类型的值，可以将多个不同类型的字面量进行组合，此时得到的变量上的方法无法进行合法调用，因为变量可能为其它不含该方法的类型（与联合类型同理）。因此需要进行类型精简或类型断言。注意在变量声明时进行类型注释了的才能被字面量类型约束，如果没有类型注释，则会按照类型推论的结果来判定类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义gender只能取值为 &#x27;男&#x27; 或 &#x27;女&#x27; 中的一种</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">gender</span>: <span class="string">&quot;男&quot;</span> | <span class="string">&quot;女&quot;</span> = <span class="string">&quot;男&quot;</span>;</span><br><span class="line"><span class="comment">// gender2经类型推论string类型</span></span><br><span class="line"><span class="keyword">let</span> gender2 = <span class="string">&quot;男&quot;</span>;</span><br><span class="line"><span class="comment">// 多种类型字面量的组合</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="string">&quot;未知数&quot;</span> | <span class="number">1</span> | &#123; <span class="attr">y</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="comment">// 严格类型检查时不能合法调用</span></span><br><span class="line">x.<span class="title function_">split</span>(<span class="string">&quot;知&quot;</span>) &lt;</span><br><span class="line">  <span class="comment">// 进行类型断言后可合法</span></span><br><span class="line">  <span class="built_in">string</span> &gt;</span><br><span class="line">  x.<span class="title function_">split</span>(<span class="string">&quot;知&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="9-null-和-undefined-与-非空断言"><a href="#9-null-和-undefined-与-非空断言" class="headerlink" title="9. null 和 undefined 与 非空断言"></a>9. <code>null</code> 和 <code>undefined</code> 与 非空断言</h3><p>两个空值类型，和在<code>js</code>里的区别一致。开启/关闭严格空值检查会影响到空值类型的行为。当我们知道一个变量不会为空时，可以在该变量后使用英文感叹号 “<code>!</code>“ ，进行临时<strong>非空断言 （<code>Non-null Assertion</code>）</strong>。这点在函数中尤为重要。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyType</span> = <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">value</span>: <span class="title class_">MyType</span> = <span class="string">&quot;I love China&quot;</span>;</span><br><span class="line"><span class="comment">// 对value进行非空断言</span></span><br><span class="line">value!.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="10-Enums-枚举类型"><a href="#10-Enums-枚举类型" class="headerlink" title="10. Enums 枚举类型"></a>10. <code>Enums</code> 枚举类型</h3><p>枚举类型是一组被有意义地命名了的常量的集合。与其它类型本质上不同的是，其它的类型都只是类型，而枚举类型却是可以使用的值。<strong>通过<code>enum</code>关键字声明某个变量为枚举类型的值</strong>，使用枚举类型，可以让我们不去关注变量实际的值，而使用更有意义的名字来代表实际的值。例如，在表示性别时，我们可以简单地用数字 1 和 2 来表示 男 和 女。那么在实际使用中，我们需要知道到底是 1 代表男还是 1 代表女。当数据从前端传到后端，后端的小伙伴又需要去了解哪个数字代表哪个性别。这对我们来说就不太友好。所以，我们可以使用枚举类型来定义一组表示性别的常量，之后使用时，只需取常量的名字即可。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Gender</span> &#123;</span><br><span class="line">  <span class="attr">male</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">female</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">secret</span>: <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举类型包括数字型枚举、字符串型枚举、异构枚举等等。此处只简要了解一下枚举类型的的存在，后续会写一篇枚举类型的深入。</p><h3 id="11-any"><a href="#11-any" class="headerlink" title="11. any"></a>11. <code>any</code></h3><p><code>any</code>可以指代任何类型，可以被赋值给任意类型的变量。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给变量anyscript一个any类型，其值为数字123</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">anyscript</span>: <span class="built_in">any</span> = <span class="number">123</span>;</span><br><span class="line"><span class="comment">// 给变量typescript一个string类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">typescript</span>: <span class="built_in">string</span> = <span class="string">&quot;typescript&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值操作后，typescript变成了123，其类型发生了改变</span></span><br><span class="line">typescript = anyscript;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 而编译器会认为typescript变量为string类型，且允许我们调用string类型的方法</span></span><br><span class="line">typescript.<span class="title function_">split</span>(<span class="string">&quot;c&quot;</span>);</span><br><span class="line"><span class="comment">// 而事实上此时变量typescript的值已经变为了数字123，调用string的方法就会</span></span><br></pre></td></tr></table></figure><p>这个看起来很便捷的<code>any</code>类型，在这种时候就会引发问题，造成类型污染。因此，我们应该避免使用<code>any</code>，以免走进<code>Anyscript</code>的误区。</p><h3 id="12-unknown与类型断言"><a href="#12-unknown与类型断言" class="headerlink" title="12. unknown与类型断言"></a>12. <code>unknown</code>与类型断言</h3><p><code>unknown</code>用来表示未知类型，和<code>any</code>相似，它的值可以是任何类型。不同的是，如果一个变量是<code>unknown</code>类型，那么它在被明确为某个确切的类型之前，不能调用任何方法，也不能被赋值给其它变量。你可以使用<mark><strong>类型断言</strong></mark>来<strong>临时</strong>人为明确一个 unknown 变量的确切类型。毕竟<strong>你永远比<code>Typescript</code>知道的多</strong>！类型断言一般有两种方式：使用 <code>a as Type</code> 或者 在需要进行类型断言的变量前使用尖括号：<code>&lt;Type&gt;a</code>，来明确变量<code>a</code>为<code>Type</code>类型。注意类型断言是临时的，因此它不会改变原来<code>unknown</code>变量的类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个unknown变量a，一个字符串变量b</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="built_in">unknown</span> = <span class="string">&quot;I am unknown type&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">b</span>: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里会报错，因为a为unknown类型，而且并没有明确它的具体类型，</span></span><br><span class="line"><span class="comment">// 不能被赋值给字符串变量b，哪怕a本身实际的值为字符串</span></span><br><span class="line">b = a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类型断言来明确a的具体类型为字符串string，</span></span><br><span class="line"><span class="comment">// 之后便可以赋值给字符串b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用as进行类型断言，可以用括号将其整体包裹起来，以进行对断言之后的变量a的操作</span></span><br><span class="line">b = a <span class="keyword">as</span> <span class="built_in">string</span>;</span><br><span class="line">b = (a <span class="keyword">as</span> <span class="built_in">string</span>) + <span class="string">&quot;!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以使用&lt;Type&gt;a的形式进行类型断言</span></span><br><span class="line">b = &lt;<span class="built_in">string</span>&gt;a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 之后 a 的类型依然是unknown</span></span><br></pre></td></tr></table></figure><p>也许你会觉得使用<code>unknown</code>类型有些繁琐。但相比起<code>any</code>类型容易引发的错误，<code>unknown</code>类型的使用足够安全。因此，如果有需要使用不明确的类型时，应该首选<code>unknown</code>而不是<code>any</code>。毕竟谁也不愿意，一杯茶，一个圈，一个<code>BUG</code>改一天(甚至还在排查错误原因)。</p><h3 id="13-never-和-void"><a href="#13-never-和-void" class="headerlink" title="13. never 和 void"></a>13. <code>never</code> 和 <code>void</code></h3><p><code>void</code>用于表示函数返回空值；<code>never</code>用于表示不该使用的值或者函数不应该有返回值，在我们平常的工作中<code>never</code>的应用场景较少。</p><h3 id="14-不常用的类型"><a href="#14-不常用的类型" class="headerlink" title="14.不常用的类型"></a>14.不常用的类型</h3><p><strong><code>Bigint</code>和<code>Symbol</code></strong>是<code>ES6</code>之后加入的基本数据类型，目前在日常工作中的使用并不多见。<code>TS</code>中的这两种类型和<code>JS</code>中一致。</p><ul><li><p><strong><code>bigint</code></strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用BigInt函数来创建一个bigint类型的变量</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">oneHundred</span>: <span class="built_in">bigint</span> = <span class="title class_">BigInt</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用字面量语法 数字 + n 来创建bigint类型的变量</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">anotherHundred</span>: <span class="built_in">bigint</span> = <span class="number">100n</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>Symbol</code></strong></p><p><code>Symbol</code>是<code>ES6</code>之后新增的一种基本数据类型，每个<code>Symbol</code>类型的变量，其值都是唯一的，即使传入相同的参数，返回的结果也永远不会相等。一般使用<code>Symbol</code>函数来创建。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Symbol函数创建Symbol类型的变量/常量</span></span><br><span class="line"><span class="keyword">const</span> first1 = <span class="title class_">Symbol</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> first2 = <span class="title class_">Symbol</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"></span><br><span class="line">first1 === first2; <span class="comment">// 永远是false</span></span><br></pre></td></tr></table></figure></li></ul><p>类型基础的内容就介绍到这里啦，下一篇将着重介绍在函数中使用各种类型时需要注意的问题，例如如何进行类型精确。如果文章描述有不妥之处，恳请不吝指出，我们下一篇再见！</p>]]></content>
      
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

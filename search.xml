<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Typescript系列 基础篇 (六) 模块化入门篇</title>
      <link href="/onlyy-blog/articals/cb3e0e8e9b95/"/>
      <url>/onlyy-blog/articals/cb3e0e8e9b95/</url>
      
        <content type="html"><![CDATA[<h1 id="Typescript-系列-基础篇-六-模块化入门篇"><a href="#Typescript-系列-基础篇-六-模块化入门篇" class="headerlink" title="Typescript 系列 基础篇 (六) 模块化入门篇"></a>Typescript 系列 基础篇 (六) 模块化入门篇</h1><p><code>TS</code>模块化是建立在<code>JS</code>模块化的基础上，与<code>JS</code>中的写法有许多的不同之处。<code>TS</code>极大地支持了主流的<code>ESM</code>和<code>CommomJs</code>，也对其他的模块化方案有所兼容。</p><h2 id="一、ES-模块化语法"><a href="#一、ES-模块化语法" class="headerlink" title="一、ES 模块化语法"></a>一、<code>ES</code> 模块化语法</h2><h3 id="1-export-导出"><a href="#1-export-导出" class="headerlink" title="1. export 导出"></a>1. <em><code>export</code></em> 导出</h3><p><code>TS</code>支持<code>ES</code>模块化方案，写法和<code>JS</code>中一致。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ModuleA.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> b = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> <span class="title function_">c</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 设置默认导出项，仅TS中可导出interface、type等</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-import-导入"><a href="#2-import-导入" class="headerlink" title="2. import 导入"></a>2. <em><code>import</code></em> 导入</h3><ul><li>使用<code>import</code>加载其它模块，和<code>JS</code>中一致，可以使用 <strong><code>as</code></strong> 重命名。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; a, b, c <span class="keyword">as</span> <span class="title class_">RenamedC</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./ModuleA&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Person</span> <span class="keyword">from</span> <span class="string">&quot;./ModuleA&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li>可以混合导入，但是默认项必须写在前面。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.ts</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Person</span>, &#123; a, b, c <span class="keyword">as</span> <span class="title class_">RenamedC</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./ModuleA&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li>可以使用 <strong><code>import *</code></strong> 来导入所有内容，并用 <strong><code>as</code></strong> 重命名。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.ts</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> M <span class="keyword">from</span> <span class="string">&quot;./ModuleA&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li>可以使用 <code>import + 文件名</code> 来导入一个文件，这种情况下，被导入的文件中的代码会被执行，可能会对当前作用域中的变量产生影响。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.ts</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./ModuleA&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li><p><code>TS</code>特有的语法</p><ul><li><p><code>JS</code>中没有<code>interface</code>、<code>type</code>等概念，没有相应的关键字。因此，<code>interface</code>和<code>type</code>语句是<code>TS</code>特有的导出语法。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ModuleB.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">Cat</span> = &#123; <span class="attr">breed</span>: <span class="built_in">string</span>; <span class="attr">yearOfBirth</span>: <span class="built_in">number</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">  <span class="attr">breeds</span>: <span class="built_in">string</span>[];</span><br><span class="line">  <span class="attr">yearOfBirth</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> c = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>导入时正常导入就行了。</p></li><li><p><strong><em><code>import type</code></em></strong> 语法</p><p>该语法只能用来导入类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不能导入变量c</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; <span class="title class_">Cat</span>, <span class="title class_">Dog</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./ModuleB&quot;</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>inline type imports</code></p><p><code>TS 4.5</code> 版本允许混合导入类型和变量。<strong>把 <code>type</code> 关键字写在导入的类型前面</strong>，不写<code>type</code>的则为变量。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不能导入变量c</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">type</span> <span class="title class_">Cat</span>, <span class="keyword">type</span> <span class="title class_">Dog</span>, c &#125; <span class="keyword">from</span> <span class="string">&quot;./ModuleB&quot;</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>具有 <code>CommonJs</code> 表现的 <code>ES</code> 语法</p><p>使用 <strong><code>export = &#123; // ... &#125;</code></strong> 来导出的模块，既可以用<code>CommonJs</code>语法导入，也可以用<code>ESM</code>的兼容语法 <code>import a = require(&#39;./xxx&#39;)</code> 语法导入。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ModuleX.ts</span></span><br><span class="line"><span class="keyword">export</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;x&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// app.ts</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="built_in">require</span>(<span class="string">&quot;./ModuleX&quot;</span>); <span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">import</span> b = <span class="built_in">require</span>(<span class="string">&quot;./ModuleX&quot;</span>); <span class="comment">// 推荐写法</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="二、CommonJs-模块化语法"><a href="#二、CommonJs-模块化语法" class="headerlink" title="二、CommonJs 模块化语法"></a>二、<code>CommonJs</code> 模块化语法</h2><p><strong>通过 全局变量 <code>module</code> 上的 <code>exports</code> 属性来设置导出的内容</strong>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MathModule.ts</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">pi</span>: <span class="number">3.14</span>,</span><br><span class="line">  <span class="attr">squareTwo</span>: <span class="number">1.41</span>,</span><br><span class="line">  <span class="attr">phi</span>: <span class="number">1.61</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对应的，使用 <strong><code>require</code></strong> 来导入。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.ts</span></span><br><span class="line"><span class="keyword">const</span> math = <span class="built_in">require</span>(<span class="string">&quot;./MathModule&quot;</span>);</span><br><span class="line"><span class="comment">// 或者也可以解构</span></span><br><span class="line"><span class="keyword">const</span> &#123; pi, squareTwo &#125; = <span class="built_in">require</span>(<span class="string">&quot;./MathModule&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>TS</code>系列基础篇就写到这儿了，累了，<code>TS</code>进阶篇再见。另外，想进一步了解<code>TS</code>模块化的知识，可以参考我的<strong><code>TS</code>进阶系列</strong>：<a href="https://juejin.cn/post/7080089003113840670">深入理解 TS 模块</a>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript系列  基础篇(五)  Classes 类</title>
      <link href="/onlyy-blog/articals/767363b62d63/"/>
      <url>/onlyy-blog/articals/767363b62d63/</url>
      
        <content type="html"><![CDATA[<h1 id="TypeScript-系列-基础篇-五-Classes-类"><a href="#TypeScript-系列-基础篇-五-Classes-类" class="headerlink" title="TypeScript 系列 基础篇(五) Classes 类"></a>TypeScript 系列 基础篇(五) Classes 类</h1><p><strong>类</strong> 在 <code>JavaScript</code> 中出现于 <code>ES2015</code> 版本，<code>TS</code>对 类 进行了全面支持，还加入了一些其它语法来增强类的表达能力，本文将详细聊一聊<code>TS</code>中的类的知识，你知道的和不知道的，这里都有。</p><h2 id="一、类的成员"><a href="#一、类的成员" class="headerlink" title="一、类的成员"></a>一、类的成员</h2><h3 id="1-属性字段-Fields"><a href="#1-属性字段-Fields" class="headerlink" title="1. 属性字段 (Fields)"></a>1. 属性字段 (<code>Fields</code>)</h3><p>字段声明会为类添加创建一个<strong>公共</strong>的<strong>可写</strong>的<strong>实例属性</strong>。我们可以为字段添加类型注释，如果不添加，就会是 <code>any</code> 类型，当然这是我们不希望发生的。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  gender; <span class="comment">// gender为 any 类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字段声明时可以赋初值，其类型会被 TS 自动推论，在实例化时会自动执行值的初始化。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  name = <span class="string">&quot;cc&quot;</span>; <span class="comment">// name为string类型</span></span><br><span class="line">  age = <span class="number">18</span>; <span class="comment">// age 为 string 类型</span></span><br><span class="line">  <span class="attr">gender</span>: <span class="number">1</span> | <span class="number">2</span> = <span class="number">2</span>; <span class="comment">// 如果不注释类型，则gender会被推论为number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cc = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">cc.<span class="property">name</span>; <span class="comment">// &#x27;cc&#x27;</span></span><br><span class="line">cc.<span class="property">age</span>; <span class="comment">// 18</span></span><br></pre></td></tr></table></figure><p>如果开启了严格属性初始化检查： <strong><code>strictPropertyInitialization</code></strong>，则<strong>没有赋初值</strong>的字段<strong>必须在构造函数中初始化</strong>，不能在其它的方法中初始化，TS 不会去检测其它方法内的初始化。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  name = <span class="string">&quot;cc&quot;</span>; <span class="comment">// name为string类型</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = <span class="number">18</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，开启该检测是为了防止属性值为空带来的意外错误。我们可以使用<strong>非空断言</strong>来明确该属性不会为空，这样也不会报错。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  name!: <span class="built_in">number</span>; <span class="comment">// 非空断言</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-readonly-只读属性"><a href="#2-readonly-只读属性" class="headerlink" title="2. readonly 只读属性"></a>2. <em><code>readonly</code></em> 只读属性</h3><p>添加了 <strong><code>readonly</code></strong> 修饰符的属性，将<strong>不允许在构造函数以外的地方中进行重新赋值</strong>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&quot;cc&quot;</span>; <span class="comment">// 只读属性</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;yy&quot;</span>; <span class="comment">// 可以构造函数中赋值，因为构造函数相当于初始化</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">setName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;hi&quot;</span>; <span class="comment">// 报错，只读属性不允许重新赋值</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 也不可在类以外进行赋值</span></span><br><span class="line"><span class="keyword">const</span> cc = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">cc.<span class="property">name</span> = <span class="string">&quot;cc&quot;</span>; <span class="comment">// 报错，只读属性不允许重新赋值</span></span><br></pre></td></tr></table></figure><h3 id="3-constructor-构造函数"><a href="#3-constructor-构造函数" class="headerlink" title="3. constructor 构造函数"></a>3. <code>constructor</code> 构造函数</h3><p>构造函数接收实例化时传入的参数，可以提供参数默认值。在构造函数中进行类实例的初始化操作，可以分配属性值、调用类的方法等。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name = <span class="string">&quot;cc&quot;</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还记得我们在<a href="https://juejin.cn/post/7070172611849748517">Typescript 系列：(二)函数篇</a>里讲的函数重载吗？构造函数自然也可以重载。注意构造函数的<strong>重载签名</strong>和<strong>实现签名</strong>是没有返回值类型的。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="comment">// 两套重载签名</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">number</span></span>);</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>);</span><br><span class="line">  <span class="comment">// 实现签名</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">number</span> | <span class="built_in">string</span>, age?: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-调用-super"><a href="#4-调用-super" class="headerlink" title="4. 调用 super( )"></a>4. 调用 <em><code>super( )</code></em></h3><p>我们知道，类可以通过 <strong><code>extends</code></strong> 关键字来继承一个基类。此时，我们在构造函数中使用 <strong><code>this</code></strong> 关键字<strong>之前</strong>需要先调用 <strong><code>super( )</code></strong> ，相当于调用了父类的构造函数。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误，没有在构造函数中先调用super()，就使用了this</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User1</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User2</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-methods-方法"><a href="#5-methods-方法" class="headerlink" title="5. methods 方法"></a>5. <code>methods</code> 方法</h3><p>类里面的函数叫做方法。<strong>声明一个方法不要用 <code>function</code> 关键字</strong>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name = <span class="string">&quot;cc&quot;</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// setName方法</span></span><br><span class="line">  <span class="title function_">setName</span>(<span class="attr">name</span>: <span class="built_in">string</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-存取器-setters-getters"><a href="#6-存取器-setters-getters" class="headerlink" title="6. 存取器 setters/getters"></a>6. 存取器 <code>setters/getters</code></h3><p>和 <code>JS</code> 里没什么差别。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">_name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name = <span class="string">&quot;cc&quot;</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// setter</span></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">name: <span class="built_in">string</span></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">name</span>(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于存取器，<code>TS</code>有几个特别的推论：</p><ul><li>如果有 <code>get</code> 而没有 <code>set</code>，则该属性会被推论为 <code>readonly</code> 只读属性；</li><li>如果 <code>setter</code> 没有明确参数的类型，则会推论为 <code>getter</code> 的返回值的类型；</li><li><code>getter</code> 和 <code>setter</code> 的可见性保持一致。</li></ul><h3 id="7-索引签名"><a href="#7-索引签名" class="headerlink" title="7. 索引签名"></a>7. 索引签名</h3><p>类 也可以使用索引签名，和在对象类型里使用差不多。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  [<span class="attr">x</span>: <span class="built_in">string</span>]: <span class="built_in">string</span> | <span class="built_in">number</span> | (<span class="function">(<span class="params">s?: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">string</span> | <span class="built_in">number</span>);</span><br><span class="line"></span><br><span class="line">  name = <span class="number">1</span>;</span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、类的继承"><a href="#二、类的继承" class="headerlink" title="二、类的继承"></a>二、类的继承</h2><h3 id="1-implement-语句"><a href="#1-implement-语句" class="headerlink" title="1. implement 语句"></a>1. <code>implement</code> 语句</h3><p>使用 <strong><code>implements</code></strong> 语句检查类是否符合某接口规范。实现某个接口，则类中需要含有该接口的所有属性和方法才能通过检测。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">setName</span>: <span class="function">(<span class="params">x: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// People类 实现 Person 接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span> <span class="keyword">implements</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&quot;cc&quot;</span>;</span><br><span class="line">  <span class="title function_">setName</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以同时实现多个接口：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">setName</span>: <span class="function">(<span class="params">x: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Manager</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// People类 实现 Person 接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span> <span class="keyword">implements</span> <span class="title class_">Person</span>, <span class="title class_">Manager</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&quot;cc&quot;</span>;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">string</span> = <span class="string">&quot;001&quot;</span>;</span><br><span class="line">  <span class="title function_">setName</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 <strong>implements</strong> 语句只是检测类是否符合接口规范。</p><h3 id="2-extends-语句"><a href="#2-extends-语句" class="headerlink" title="2. extends 语句"></a>2. <code>extends</code> 语句</h3><ul><li>通过 <code>extends</code> 语句可以让类继承一个基类，获得它所有的属性和方法，还能定义自己的属性和方法。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&quot;cc&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cc = <span class="keyword">new</span> <span class="title class_">Manager</span>();</span><br><span class="line">cc.<span class="property">name</span>; <span class="comment">// &#x27;cc&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>重写父类方法，可以通过 <code>super.xx( )</code> 来调用父类的方法。子类的方法需要能兼容父类的方法，包括参数数量、类型，以及返回值。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&quot;cc&quot;</span>;</span><br><span class="line">  <span class="title function_">setName</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  <span class="title function_">setName</span>(<span class="params">name: <span class="built_in">string</span> | <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> name === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">name</span> = <span class="title class_">String</span>(name + <span class="number">100</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">super</span>.<span class="title function_">setName</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cc = <span class="keyword">new</span> <span class="title class_">Manager</span>();</span><br><span class="line">cc.<span class="title function_">setName</span>(<span class="number">99</span>);</span><br><span class="line">cc.<span class="property">name</span>; <span class="comment">// &#x27;199&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>字段类型声明</li></ul><p>在父类的构造函数执行完之后，才会开始子类的初始化，期间可能改写来自父类的属性或方法。当 子类的某个属性 是 父类相应属性 的子类型时，这个过程就会浪费性能。可以通过 <strong><em><code>declare</code></em></strong> 关键字来声明字段类型，使其不受运行时效果的影响。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">bark</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AnimalHouse</span> &#123;</span><br><span class="line">  <span class="attr">resident</span>: <span class="title class_">Animal</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">animal: Animal</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">resident</span> = animal;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DogHouse</span> <span class="keyword">extends</span> <span class="title class_ inherited__">AnimalHouse</span> &#123;</span><br><span class="line">  <span class="comment">// 通过declare关键字，使resident属性的类型固定为Dog</span></span><br><span class="line">  <span class="keyword">declare</span> <span class="attr">resident</span>: <span class="title class_">Dog</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">dog: Dog</span>) &#123;</span><br><span class="line">    <span class="comment">// 不要忘记调用super()</span></span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>初始化顺序</li></ul><p>父类字段初始化 —&gt; 父类构造函数执行 —&gt; 子类字段初始化 —&gt; 子类构造函数执行</p><h3 id="3-继承内置类型"><a href="#3-继承内置类型" class="headerlink" title="3. 继承内置类型"></a>3. 继承内置类型</h3><p>继承内置类型，如<code>Array</code>、<code>Error</code>等，当在构造函数中调用<code>super( )</code>之后，<code>this</code>的原型指向会错误地指向<code>super</code>的调用者，即<code>Array</code>、<code>Error</code>等内置类型。<code>ES6</code>使用 <strong><code>new.target</code></strong> 来调整原型链，但是在 <code>ES5</code> 中却保证不了 <code>new.target</code> 的值。因此，我们在调用<code>super()</code>之后，要手动调整原型链，让<code>this</code>的原型指向我们新的类。 <strong><code>Object.setPrototypeOf( )</code></strong> 便是要用的方法 (不支持该方法的可以退一步使用<code>Object.prototype.__proto__</code> )。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MsgError1</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Error</span> &#123;</span><br><span class="line">  naame = <span class="number">123</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">m: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(m);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello &quot;</span> + <span class="variable language_">this</span>.<span class="property">message</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">let</span> m1 = <span class="keyword">new</span> <span class="title class_">MsgError1</span>(<span class="string">&quot;cc&quot;</span>);</span><br><span class="line"><span class="comment">// 由于原型链错误，sayHello方法在MsgError的原型上，</span></span><br><span class="line"><span class="comment">// 而m1的原型指向Error，索引没有sayHello方法</span></span><br><span class="line">m1.<span class="title function_">sayHello</span>(); <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MsgError2</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Error</span> &#123;</span><br><span class="line">  naame = <span class="number">123</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">m: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(m);</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(<span class="variable language_">this</span>, <span class="title class_">MsgError2</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello &quot;</span> + <span class="variable language_">this</span>.<span class="property">message</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> m2 = <span class="keyword">new</span> <span class="title class_">MsgError2</span>(<span class="string">&quot;cc&quot;</span>);</span><br><span class="line">m2.<span class="title function_">sayHello</span>(); <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><p>需要注意，这种问题会一直传递下去，也就是说，<strong>以 <code>MsgError2</code> 为基类所创造的子类，也需要再次手动调整原型的指向</strong>。此外，不支持<code>IE10</code>及更低的版本。</p><h2 id="三、成员的可见性-Member-Visibility"><a href="#三、成员的可见性-Member-Visibility" class="headerlink" title="三、成员的可见性 Member Visibility"></a>三、成员的可见性 <code>Member Visibility</code></h2><p>在 TS 中，实现了 <code>public</code>，<code>protected</code>，<code>private</code>等修饰符来实现成员的可见性。</p><h3 id="1-public"><a href="#1-public" class="headerlink" title="1. public"></a>1. <code>public</code></h3><p><strong><code>public</code></strong> 修饰符用来定义公开成员，这也是默认的成员可见性，当没有写可见性修饰符时，就默认是 <code>public</code> 。被声明为<code>public</code>的成员，可在任何地方访问。太简单了就不给栗子了。</p><h2 id="2-protected"><a href="#2-protected" class="headerlink" title="2. protected"></a>2. <code>protected</code></h2><p>被 <strong><code>protected</code></strong> 修饰的成员只能在类或者其子类中访问，无法通过实例来访问。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 类中可以</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cc = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;cc&quot;</span>);</span><br><span class="line">cc.<span class="property">name</span>; <span class="comment">// TS会报错，实例无法访问protected成员</span></span><br></pre></td></tr></table></figure><p>在子类中，如果我们通过字段重新声明了基类中的 <code>protected</code> 成员，则会将其在子类中变为 <code>public</code> 成员，除非重新加上 <code>protected</code> 修饰符：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">protected</span> <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  <span class="comment">// 不加 protected 修饰符， 则name变为public，通过实例来访问</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="comment">// 而这个则依然是protected成员</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cc = <span class="keyword">new</span> <span class="title class_">Manager</span>(<span class="string">&quot;cc&quot;</span>, <span class="number">18</span>);</span><br><span class="line">cc.<span class="property">name</span>; <span class="comment">// &#x27;cc&#x27;</span></span><br><span class="line"><span class="comment">// 报错，实例无法调用 protected</span></span><br><span class="line">cc.<span class="property">age</span>;</span><br></pre></td></tr></table></figure><h3 id="3-private"><a href="#3-private" class="headerlink" title="3. private"></a>3. <code>private</code></h3><p>被 <strong><code>private</code></strong> 修饰的成员只能在类中访问，无法通过实例来访问，也无法在其子类中访问。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  <span class="comment">// 错误，private成员不能在子类中访问</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="comment">// 同样错误，private成员不能在子类中访问</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cc = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;cc&quot;</span>, <span class="number">18</span>);</span><br><span class="line">cc.<span class="property">name</span>; <span class="comment">// 也错误，private成员不能通过实例来访问</span></span><br></pre></td></tr></table></figure><p>但是在<code>TS</code>中支持在类中通过同类的其它实例获取该实例上的<code>private</code>成员：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">hasSameName</span>(<span class="params">other: Person</span>) &#123;</span><br><span class="line">    <span class="comment">// 可以访问其它同类实例的 private 成员name</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span> === other.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cc = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;cc&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> yy = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;yy&quot;</span>);</span><br><span class="line">cc.<span class="title function_">hasSameName</span>(yy); <span class="comment">// 不报错，得到false</span></span><br></pre></td></tr></table></figure><p>需要注意，成员可见性仅在 <code>TS</code> 的类型检查时有效。一旦代码被编译为 <code>JS</code> 代码，则在<code>JS</code>中，可以通过类实例查看原本在<code>TS</code>是 <code>pretected</code> 或 <code>private</code> 的成员。另外 <code>JS</code> 的私有修饰符 “<code>#</code>“ 可以实现在编译后依然是私有成员。因此，如果要实现通过私有化来保护成员，应使用闭包、<code>WeakMap</code>或私有字段 “<code>#</code>“ 等手段。</p><h2 id="四、静态成员-static"><a href="#四、静态成员-static" class="headerlink" title="四、静态成员 static"></a>四、静态成员 <code>static</code></h2><p>首先我们要明确一点，类本身也是一个对象。我们通过<strong><em><code>static</code></em></strong>修饰符可以将某个成员变成静态成员。<strong>静态成员与类的实例无关，而是被挂到类对象本身，可以与实例成员重名，且静态方法中的 <code>this</code> 指向类对象本身，我们通过类对象本身来访问类成员</strong>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="comment">// 这是实例成员</span></span><br><span class="line">  <span class="attr">_name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 给实例成员name赋值</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 静态属性 name</span></span><br><span class="line">  <span class="keyword">static</span> <span class="attr">_name</span>: <span class="built_in">string</span> = <span class="string">&quot;person&quot;</span>;</span><br><span class="line">  <span class="comment">// 静态方法 其中的this指向类Person</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">setName</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_name</span> = name;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// class Person &#123; // ... &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cc = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;cc&quot;</span>);</span><br><span class="line"><span class="comment">// 访问实例成员_name</span></span><br><span class="line">cc.<span class="property">_name</span>; <span class="comment">// &#x27;cc&#x27;</span></span><br><span class="line"><span class="comment">// 访问静态成员_name</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property">_name</span>; <span class="comment">// &#x27;person&#x27;</span></span><br></pre></td></tr></table></figure><p>也许你会好奇我为什么用 <code>_name</code> 而不是<code>name</code>，事实上不是我不使用，而是不能使用。稍后你会得到答案。</p><p>静态成员也可以使用 <code>public</code>、<code>protected</code>、<code>private</code>等修饰符。类似的，<strong><code>protected</code> 静态属性 只能由类或子类中的静态成员访问；<code>private</code>静态成员只能由 类 中的静态成员访问</strong>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">static</span> _name = <span class="string">&quot;person&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property">_name</span>; <span class="comment">// 报错，不能访问protected成员</span></span><br></pre></td></tr></table></figure><p>静态成员可以被子类继承：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> _name = <span class="string">&quot;person&quot;</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">setName</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Manager</span>.<span class="property">_name</span>; <span class="comment">// &#x27;person&#x27;</span></span><br><span class="line"><span class="title class_">Manager</span>.<span class="title function_">setName</span>(<span class="string">&quot;cc&quot;</span>);</span><br><span class="line"><span class="title class_">Manager</span>.<span class="property">_name</span>; <span class="comment">// &#x27;cc&#x27;</span></span><br></pre></td></tr></table></figure><p>特殊的静态名字：<strong><code>name</code></strong> ，由于存在内置静态属性 <strong><code>Function.name</code></strong>，因此我们在给静态属性命名时，不能使用<code>name</code>，否则会发生冲突。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="comment">// 错误，静态属性name与内置静态属性 Function.name 冲突</span></span><br><span class="line">  <span class="keyword">static</span> name = <span class="string">&quot;person&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、静态域"><a href="#五、静态域" class="headerlink" title="五、静态域"></a>五、静态域</h2><p>我将类中的 <code>static blocks</code> 称为静态域，通过 <strong><em><code>static &#123; &#125;</code></em></strong>声明一块区域，在该区域编写的语句能够自动执行，且能访问私有属性 如 “<code>#name</code>“。因此，可以在静态域中书写静态成员做初始化逻辑。这里想不出什么好的栗子，就搬运了官网的：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> #count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">count</span>()</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Foo</span>.#count;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> lastInstances = <span class="title function_">loadLastInstances</span>();</span><br><span class="line">      <span class="title class_">Foo</span>.#count += lastInstances.<span class="property">length</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、泛型类"><a href="#六、泛型类" class="headerlink" title="六、泛型类"></a>六、泛型类</h2><p>在执行<code>new</code>操作时，泛型类的类型参数也会由传入的参数来进行推论。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">name</span>: T;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: T</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">setName</span>(<span class="params">name: T</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cc = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;cc&quot;</span>); <span class="comment">// T被推论</span></span><br></pre></td></tr></table></figure><p>泛型类可以像泛型接口一样进行泛型约束以及指定类型参数的默认值。大家都能明白的吧，就不给栗子了。</p><p>静态成员无法享用泛型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">// 错误，静态成员不可引用类型参数</span></span><br><span class="line">  <span class="keyword">static</span> <span class="attr">_name</span>: T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是因为每个静态成员都只有一个，而实例成员在每个实例上都存在一个。假若静态成员能享用泛型，那么我们<code>new</code>一个实例<code>a</code>，传入类型<code>string</code>，此时静态属性<code>_name</code>类型为<code>string</code>；我们<code>new</code> 一个实例<code>b</code>，传入类型<code>number</code>，那么此时静态属性_<code>name</code>的类型是啥呢？<code>string</code>亦或<code>number</code> ? 显然都不合理。所以静态成员无法使用类型参数。</p><h2 id="七、运行时的-this"><a href="#七、运行时的-this" class="headerlink" title="七、运行时的 this"></a>七、运行时的 <code>this</code></h2><p><code>Ts</code>中的<code>this</code>指向和 <code>JS</code> 保持一致，因此有时候我们需要防止成员丢失<code>this</code>上下文。</p><h3 id="1-使用箭头函数"><a href="#1-使用箭头函数" class="headerlink" title="1. 使用箭头函数"></a>1. 使用箭头函数</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  setName = <span class="function">(<span class="params">name: <span class="built_in">string</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这也需要权衡利弊：</p><ul><li>这样做能保证<code>setName</code>方法的<code>this</code>永远正确地指向实例本身；</li><li>使用中这种方式定义的方法不会挂载原型上，而是会被添加到每一个实例上，因此会占用更多的内存；</li><li>同样，其子类无法通过<code>super</code>,<code>setName</code>来调用父类的<code>setName</code>方法，因为无法在原型链上找到；</li></ul><h3 id="2-使用-this-参数"><a href="#2-使用-this-参数" class="headerlink" title="2. 使用 this 参数"></a>2. 使用 <code>this</code> 参数</h3><p>如同在<code>TS</code>的函数中将<code>this</code>作为参数，为其指定类型一样，在类的方法中也可以如此这般。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="comment">// 为this指定类型为 Person，则只有Person实例才可以调用该方法</span></span><br><span class="line">  <span class="title function_">setName</span>(<span class="params"><span class="variable language_">this</span>: Person, name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式很好地弥补了箭头函数的不足，唯一的缺点就是习惯了 <code>JS</code> 思维的同学可能会试图通过其它对象来调用该方法，显然这样是不会成功的。</p><h2 id="八、-把-this-作为-类型"><a href="#八、-把-this-作为-类型" class="headerlink" title="八、 把 this 作为 类型"></a>八、 <em>把 <code>this</code> 作为 类型</em></h2><p><strong>首先要说，这玩意儿非常有用</strong>。在<code>TS</code>的类中，<code>this</code> 可以作为一种特殊的类型，由当前的类进行动态推论。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="comment">// 把 this 作为形参person的类型</span></span><br><span class="line">  <span class="title function_">setName</span>(<span class="params">person: <span class="variable language_">this</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = person.<span class="property">name</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="keyword">const</span> b = a.<span class="title function_">setName</span>(a); <span class="comment">// b的类型为当前的类 Person</span></span><br></pre></td></tr></table></figure><p>这里得<code>setName</code>返回了<code>this</code>，这个<code>this</code>是表示实例值，其类型被推论为 <code>this</code>，这个<code>this</code>表示类型。<code>this</code> 类型就会在<code>setName</code>调用时被动态推论为当前的类。这样的好处是在子类中可以也自动推论为子类。例如我们在<code>Person</code>类的实例中调用<code>setName</code>，返回值的类型就是<code>Person</code>；如果在<code>Person</code>的子类<code>Manager</code>的实例中调用<code>setName</code>，返回值的类型则是<code>Person</code>的子类<code>Manage</code>r：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="comment">// 把 this 作为形参person的类型</span></span><br><span class="line">  <span class="title function_">setName</span>(<span class="params">person: <span class="variable language_">this</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = person.<span class="property">name</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> y = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="keyword">const</span> yy = y.<span class="title function_">setName</span>(y); <span class="comment">// aa的类型为Person</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> <span class="title class_">Manager</span>();</span><br><span class="line"><span class="keyword">const</span> cc = c.<span class="title function_">setName</span>(c); <span class="comment">// cc的类型为Manager</span></span><br></pre></td></tr></table></figure><p><strong>基于 <code>this</code> 类型的 类型守卫</strong>：和在函数中一样，我们可以在类或接口的方法的返回值的类型的位置使用<strong><em><code>this is Type</code></em></strong>来进行类型缩减。写个最简单的栗子吧，实在是懒癌犯了 <code>qwq</code>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  name? = <span class="string">&#x27;cc&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  <span class="comment">// 类型守卫的 this 为类型</span></span><br><span class="line">  <span class="title function_">isPerson</span>()<span class="variable language_">this</span> is <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">// return 语句的 this 指代类实例</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Person</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 可以利用 基于 this 类型的类型守卫 来进行类型缩减</span></span><br><span class="line">  <span class="title function_">hasName</span>()<span class="variable language_">this</span> is &#123;<span class="attr">name</span>: <span class="built_in">string</span>&#125; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span> !== <span class="literal">undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cc = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"><span class="comment">// 利用类型守卫来进行类型缩减</span></span><br><span class="line"><span class="keyword">if</span>(cc.<span class="title function_">hasName</span>())&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="九、参数属性"><a href="#九、参数属性" class="headerlink" title="九、参数属性"></a>九、参数属性</h2><p>参数属性是<code>TS</code>提供的一个非常方便的语法。在构造函数的参数前加上 <code>public</code>、<code>protected</code>、<code>private</code>或者<code>readonly</code>等修饰符，就可以把普通参数变为参数属性。参数属性既是构造函数的参数，又会作为实例属性自动被添加到实例上，且在传参时自动进行赋值，无需在函数体内进行赋值操作。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="keyword">public</span> name: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">    <span class="keyword">protected</span> age: <span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> gender: <span class="number">1</span> | <span class="number">2</span></span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="comment">// 不需要在这里再进行赋值</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">setAge</span>(<span class="params">age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getAge</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">age</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> cc = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;cc&quot;</span>, <span class="number">18</span>, <span class="number">2</span>);</span><br><span class="line">cc.<span class="property">name</span>; <span class="comment">// &#x27;cc&#x27;</span></span><br><span class="line">cc.<span class="title function_">setAge</span>(<span class="number">20</span>);</span><br><span class="line">cc.<span class="title function_">getAge</span>(); <span class="comment">// 20</span></span><br><span class="line">cc.<span class="property">gender</span>; <span class="comment">// 报错，private属性不能通过实例</span></span><br></pre></td></tr></table></figure><h2 id="十、类表达式"><a href="#十、类表达式" class="headerlink" title="十、类表达式"></a>十、类表达式</h2><p>类似函数表达式，没啥说的，直接上栗子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Person</span> = <span class="keyword">class</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&quot;cc&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cc = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">cc.<span class="property">name</span>; <span class="comment">// &#x27;cc&#x27;  cc的类型是Person</span></span><br></pre></td></tr></table></figure><h2 id="十一、abstract-抽象类及其成员"><a href="#十一、abstract-抽象类及其成员" class="headerlink" title="十一、abstract 抽象类及其成员"></a>十一、<em>abstract</em> 抽象类及其成员</h2><p>含有抽象成员的类为抽象类。抽象类和抽象成员都需要在前面加上 <strong><code>abstract</code></strong> 修饰符。抽象类不能使用 <code>new</code> 进行实例化，而是用来作为<strong>基类</strong>，声明一些抽象方法或抽象属性，其子类需要实现所有这些方法或属性。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="title function_">setName</span>(<span class="attr">x</span>: <span class="built_in">string</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类必须包含父类的全部</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&quot;manager&quot;</span>;</span><br><span class="line">  <span class="title function_">setName</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="十二、类成员之间的关系"><a href="#十二、类成员之间的关系" class="headerlink" title="十二、类成员之间的关系"></a>十二、类成员之间的关系</h2><p>和其它类型一样，类之间也是通过结构来进行比较的，当拥有相同的成员，则可以相互替换；当一个类<code>A</code>中含有另一个类<code>B</code>的所有成员，尽管没有显示地通过 <code>extends</code> 继承，类 <code>A</code> 依然会被认为是类 <code>B</code> 的子类。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不会报错</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">person</span>: <span class="title class_">Person</span> = <span class="keyword">new</span> <span class="title class_">Manager</span>();</span><br></pre></td></tr></table></figure><p>这看起来很直观简单，不过少数情况下会看起来有些 <code>emmm</code>，怪怪的。拿个官方栗子来：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x: Empty</span>) &#123;</span><br><span class="line">  <span class="comment">// 啥也不做</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下这几个都没问题，也就是说，它们都是空类 Empty 的子类</span></span><br><span class="line"><span class="comment">// bigint和symbol不是</span></span><br><span class="line"><span class="title function_">fn</span>(<span class="variable language_">window</span>);</span><br><span class="line"><span class="title function_">fn</span>(&#123;&#125;);</span><br><span class="line"><span class="title function_">fn</span>(fn);</span><br><span class="line"><span class="title function_">fn</span>(<span class="number">0</span>);</span><br><span class="line"><span class="title function_">fn</span>(<span class="literal">undefined</span>);</span><br></pre></td></tr></table></figure><p>关于类的知识就分享到这里啦，下一篇 分享 <code>TS</code> 中的 <strong><em>模块</em></strong> 的内容，不见不散！</p>]]></content>
      
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript系列基础篇(四) 类型操纵</title>
      <link href="/onlyy-blog/articals/3b83d40f51a2/"/>
      <url>/onlyy-blog/articals/3b83d40f51a2/</url>
      
        <content type="html"><![CDATA[<h1 id="TypeScript-系列基础篇-四-类型操纵"><a href="#TypeScript-系列基础篇-四-类型操纵" class="headerlink" title="TypeScript 系列基础篇(四) 类型操纵"></a>TypeScript 系列基础篇(四) 类型操纵</h1><p>定义一个类型，我们通常使用<strong><code>interface</code></strong>和 <strong><code>type</code></strong>关键字来进行规定，有时候也会直接使用字面量类型，这些过程足以应付大部分场景。但是有些时候，我们希望掌握<strong>从已经存在的值或者类型中提取或派生出新的类型</strong>的技巧，这就是我们今天要来了解的<strong><code>Type Manipulation</code> 类型操纵</strong>。相信我，掌握这些技巧后，你也能被各种类型玩出百般花样。</p><h2 id="一、使用-keyof-操作符"><a href="#一、使用-keyof-操作符" class="headerlink" title="一、使用 keyof 操作符"></a>一、使用 <strong><em><code>keyof</code></em></strong> 操作符</h2><p>使用 <strong><code>keyof</code></strong> 操作符，可以获取一个 <strong>对象类型</strong> 的属性名 (字符串或者数值)，并将其组合成一个联合类型。注意得到的是一个类型，因此<strong>应使用<code>type</code>关键字</strong>，而不能使用<code>var</code>, <code>let</code>, <code>const</code>等声明值变量的关键字。</p><ul><li>一般情况下，<code>keyof</code>操作会得到字面量联合类型；</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Person类型有三个属性，属性名分别为&quot;name&quot;,&quot;age&quot;,100</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="number">100</span>: <span class="built_in">string</span>[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对Person类型使用keyof操作符，可以将其属性名组合成一个字面量联合类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NewType</span> = keyof <span class="title class_">Person</span>; <span class="comment">// NewType为 &quot;name&quot; | &quot;age&quot; | 100</span></span><br></pre></td></tr></table></figure><ul><li><p>如果被操作的对象类型有着<code>string</code>类型或者<code>number</code>类型的<strong>索引签名</strong>，那么<code>keyof</code>操作会得到<code>string</code>或者<code>number</code>类型，而不是字面量类型。</p><ul><li><code>number</code>类型的索引签名，<code>keyof</code>会得到 <code>number</code> 类型；</li><li><code>string</code>类型的索引签名，<code>keyof</code>会得到 <code>string | number</code> 类型；</li></ul></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 索引签名规定索引必须为number类型，属性值是string类型</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  [<span class="attr">x</span>: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Type1为number类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Type1</span> = keyof <span class="title class_">Person</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是如果是string类型的索引签名</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">People</span> &#123;</span><br><span class="line">  [<span class="attr">x</span>: <span class="built_in">string</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Type2为 string | number</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Type2</span> = keyof <span class="title class_">People</span>;</span><br></pre></td></tr></table></figure><p>由于<code>JavaScript</code>中对象的 <code>key</code> 会被强制转换成 <code>string</code> 类型。因此，我们即使用数值型的<code>key</code>，最后也等同于转化之后的字符串 <code>key</code> ，<strong>即 <code>obj[0]</code> 和 <code>obj[&quot;0&quot;]</code> 完全一样</strong>。因此，<strong><code>string</code>类型的索引签名，对象实例可以由 <code>number</code> 类型的<code>key</code>，因为会被强制转化为<code>string</code>。所以<code>keyof</code>操作得到的是 <code>string | number</code>类型</strong>。</p><h2 id="二、使用-typeof-操作符"><a href="#二、使用-typeof-操作符" class="headerlink" title="二、使用 typeof 操作符"></a>二、使用 <em><code>typeof</code></em> 操作符</h2><p>在<code>JavaScript</code>中，<strong><code>typeof</code></strong>操作符常用于基本数据类型的判断。而<code>TS</code>在类型上下文中也加入了 <strong><code>typeof</code></strong> 操作符，用于获取一个变量或属性的类型。不同于我们平常的用法，当<code>typeof</code>出现在类型上下文中时，得到的类型也可以是一个对象类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;cc&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> T = <span class="keyword">typeof</span> a; <span class="comment">// T为number</span></span><br><span class="line"><span class="keyword">type</span> K = <span class="keyword">typeof</span> obj.<span class="property">name</span>; <span class="comment">// K为string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> U = <span class="keyword">typeof</span> obj; <span class="comment">// U为 &#123;name: string, age: number&#125;</span></span><br></pre></td></tr></table></figure><p><strong><code>typeof</code></strong>用在这些简单类型的值上，不得不说有点累赘。但是对于复杂类型的值，用<code>typeof</code>就可以很方便地表达多种类型。例如，可以用<code>TS</code>提供的泛型类型<strong><code>ReturnType</code></strong>来获取一个<strong>函数类型</strong>的<strong>返回值的类型</strong>(指定<code>ReturnType</code>的类型参数为某个函数类型，得到该函数类型的返回值的类型)。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛型函数类型表达式，设置泛型类型参数默认值</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Fn</span>&lt;T = <span class="built_in">number</span>&gt; = <span class="function">(<span class="params">x: T</span>) =&gt;</span> T;</span><br><span class="line"><span class="comment">// 不指定类型参数，则泛型T为number</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Type1</span> = <span class="title class_">ReturnType</span>&lt;<span class="title class_">Fn</span>&gt;; <span class="comment">// Type1为number</span></span><br><span class="line"><span class="comment">// 指定泛型类型参数T为string</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Type2</span> = <span class="title class_">ReturnType</span>&lt;<span class="title class_">Fn</span>&lt;<span class="built_in">string</span>&gt;&gt;; <span class="comment">// Type2为string</span></span><br></pre></td></tr></table></figure><p>注意 <strong><code>ReturnType</code></strong> 接收的泛型类型参数应该是一个类型，而不是一个值。在类型上下文中可以使用<code>typeof</code>关键字将通过<strong>表示值的变量或属性</strong>来表达一个类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fn是&quot;值&quot;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">a: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 错误，ReturnType的泛型类型参数应该是一个类型，而不是一个值</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Type1</span> = <span class="title class_">ReturnType</span>&lt;fn&gt;;</span><br><span class="line"><span class="comment">// 使用typeof 关键字表达fn的类型, ok</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Type2</span> = returnType&lt;<span class="keyword">typeof</span> fn&gt;; <span class="comment">// Type2为number</span></span><br></pre></td></tr></table></figure><p>注意，<strong><code>typeof</code>关键字在类型上下文中，永远只能用于变量名和属性名后面</strong>。在平常用于判断类型时，则不受此限制。<strong>类型上下文</strong>：接收一个类型作为参数或者声明、表达、生成一个类型的上下文，如<code>interface</code>、<code>type</code>等关键字以及泛型参数的上下文。</p><h2 id="三、索引访问类型"><a href="#三、索引访问类型" class="headerlink" title="三、索引访问类型"></a>三、索引访问类型</h2><p>在<strong>对象实例</strong>中，我们可以通过索引来访问某个属性值。同样的，在<strong>对象类型</strong>中，我们也可以通过索引访问某个属性的类型，此时的索引应该是一个类型，而不是一个值，用方括号的形式接收该索引。索引可以是联合类型、字面量类型、类型别名、乃至<code>keyof</code>操作符表达的类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个对象类型</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过方括号索引获得某个属性的类型，索引为字面量类型&quot;name&quot;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Name</span> = <span class="title class_">Person</span>[<span class="string">&quot;name&quot;</span>]; <span class="comment">// name</span></span><br><span class="line"><span class="comment">// 错误，不可以用 . 的方式访问</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Age</span> = <span class="title class_">Person</span>.<span class="property">age</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 索引为字面量联合类型 &quot;name&quot; | &quot;age&quot;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NameOrAge1</span> = <span class="title class_">Person</span>[<span class="string">&quot;name&quot;</span> | <span class="string">&quot;age&quot;</span>]; <span class="comment">// string | number</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 索引为类型别名</span></span><br><span class="line"><span class="keyword">type</span> M = <span class="string">&quot;name&quot;</span> | <span class="string">&quot;age&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NameOrAge2</span> = <span class="title class_">Person</span>[M]; <span class="comment">// string | number</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 索引为用keyof表达的类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NameOrAge3</span> = <span class="title class_">Person</span>[keyof <span class="title class_">Person</span>]; <span class="comment">// string | number</span></span><br></pre></td></tr></table></figure><p>无法访问对象类型中没有的属性。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个对象类型</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 错误，Person类型中没有gender属性/方法</span></span><br><span class="line"><span class="keyword">type</span> T = <span class="title class_">Person</span>[<span class="string">&quot;gender&quot;</span>];</span><br></pre></td></tr></table></figure><p>前面说到，接收的索引应该是一个类型。所以，当我们的对象类型具有索引签名时，则也可以接收<strong><code>string</code></strong>、<strong><code>number</code></strong>。另外，在数组类型中，也可以用<code>number</code>作为索引来访问。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  [<span class="attr">x</span>: <span class="built_in">number</span>]: <span class="built_in">string</span>[];</span><br><span class="line">  [<span class="attr">x</span>: <span class="built_in">string</span>]: <span class="built_in">string</span>[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用number作为索引</span></span><br><span class="line"><span class="keyword">type</span> A = <span class="title class_">Person</span>[<span class="built_in">number</span>]; <span class="comment">// string[]</span></span><br><span class="line"><span class="comment">// 使用string作为索引</span></span><br><span class="line"><span class="keyword">type</span> B = <span class="title class_">Person</span>[<span class="built_in">string</span>]; <span class="comment">// string[]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;cc&quot;</span>];</span><br><span class="line"><span class="keyword">type</span> C = <span class="keyword">typeof</span> arr[<span class="built_in">number</span>]; <span class="comment">// number | string</span></span><br></pre></td></tr></table></figure><h2 id="四、条件类型"><a href="#四、条件类型" class="headerlink" title="四、条件类型"></a>四、条件类型</h2><p>类似我们常用的三元表达式，<strong>条件类型表达式</strong>：<strong><em><code>Type1 extends Type2 ? TrueType : FalseType</code></em></strong>；当<code>Type2</code>是<code>Type1</code>的子类型时，表达式得到<code>TrueType</code>，否则得到<code>FalseType</code>。这看起来好像没啥用，然而，</p><ul><li><strong>条件类型表达式的强劲之处在于用于泛型</strong>。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyType</span>&lt;T&gt; = T <span class="keyword">extends</span> &#123; <span class="attr">info</span>: <span class="built_in">unknown</span> &#125; ? T[<span class="string">&quot;info&quot;</span>] : <span class="built_in">never</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="title class_">MyType</span>&lt;&#123; <span class="attr">name</span>: <span class="built_in">string</span>; <span class="attr">info</span>: <span class="built_in">number</span> &#125;&gt;; <span class="comment">// a为number类型的值</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">b</span>: <span class="title class_">MyType</span>&lt;<span class="title class_">Array</span>&lt;<span class="built_in">string</span>&gt;&gt;; <span class="comment">// b为never类型的值</span></span><br></pre></td></tr></table></figure><p>对条件类型的泛型类型参数使用<code>extends</code>关键字可以约束其类型：</p><ul><li><strong>在条件类型中进行推论</strong></li></ul><p>在条件类型表达式的中使用 <strong><em><code>infer</code></em></strong>关键字推论泛型类型参数或函数类型的返回值的类型，并用一个形式类型指代，这个形式类型可用于条件类型表达式中指代推论得出的实际类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在条件类型表达式的Array泛型中使用infer关键字，</span></span><br><span class="line"><span class="comment">// 推论Array成员的类型为Item类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyType</span>&lt;<span class="title class_">Type</span>&gt; = <span class="title class_">Type</span> <span class="keyword">extends</span> <span class="title class_">Array</span>&lt;infer <span class="title class_">Item</span>&gt; ? <span class="title class_">Item</span> : <span class="title class_">Type</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="title class_">MyType</span>&lt;<span class="built_in">string</span>[]&gt;; <span class="comment">// a为string类型的变量</span></span><br></pre></td></tr></table></figure><ul><li><strong>分布式条件类型</strong></li></ul><p>当我们为泛型指定的类型参数为联合类型时，条件类型的作用会分布于联合类型的每一个单独的子类型上。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">GetArrType</span>&lt;T&gt; = T <span class="keyword">extends</span> <span class="built_in">any</span> ? T[] : <span class="built_in">never</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// T[]的作用会分布到strig和number上，形成string[] | number[]</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">StrOrNumArr</span> = <span class="title class_">GetArrType</span>&lt;<span class="built_in">string</span> | <span class="built_in">number</span>&gt;; <span class="comment">// string[] | number[]</span></span><br></pre></td></tr></table></figure><h2 id="五、映射类型"><a href="#五、映射类型" class="headerlink" title="五、映射类型"></a>五、映射类型</h2><h3 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1. 基本使用"></a>1. 基本使用</h3><p>映射类型是一种泛型，往往<strong>建立在索引签名之上</strong>，即以索引签名的形式，利用指定的泛型类型参数<code>T</code>的所有属性类型的联合(一般使用 <code>keyof</code> 关键字来遍历出<code>T</code>的所有属性类型)，作为新的对象类型的索引签名，并为其指定新的返回值类型。好吧，这太绕了。说白了，就是<strong>给对象类型 A 的所有属性/方法指定新的返回值的类型，从而得到一个新的对象类型</strong>。<strong>关键字 <code>in</code> 后面是一个与类型参数<code>T</code>有关的联合类型</strong>。还是有些绕？那就来看一个栗子吧：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">OptionsFlags</span>&lt;<span class="title class_">Type</span>&gt; = &#123;</span><br><span class="line">  <span class="comment">// 索引签名的形式，这里的Property时类型参数，可以随便命名,T、K啥的都可以</span></span><br><span class="line">  [<span class="title class_">Property</span> <span class="keyword">in</span> keyof <span class="title class_">Type</span>]: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们尝试定义一个对象类型</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">gender</span>: <span class="number">1</span> | <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将Person类型传递给OptionsFlag，得到新的类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NewType</span> = <span class="title class_">OptionsFlags</span>&lt;<span class="title class_">Person</span>&gt;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">NewType为 &#123;</span></span><br><span class="line"><span class="comment">  name: boolean,</span></span><br><span class="line"><span class="comment">  age: boolean,</span></span><br><span class="line"><span class="comment">  gender: boolean</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这下我们就能明白了，文字说再多都是虚的，还得是代码。通过映射类型的方式得到新的类型，新类型继承了所有原来的属性(包括方法)，并指定了新的返回值 (当然可以使用条件类型表达式)。</p><h3 id="2-映射修饰符"><a href="#2-映射修饰符" class="headerlink" title="2.映射修饰符"></a>2.映射修饰符</h3><p>既然已经了解了映射类型的基本使用，现在来看看有哪些类型修饰符，它们又分别是用来做什么的。在上一篇文章<a href="https://juejin.cn/post/7070434381013188615">今天来聊聊 TS 中的那些对象类型——TypeScript 系列：(三) 对象类型</a>中，我们了解了对象属性的属性修饰符 <code>?</code> 和 <code>readonly</code>，事实上，映射修饰符也是这两小只。</p><ul><li><p><strong><code>readonly</code> 修饰符</strong></p><p>我们知道，通过映射类型，我们可以继承原有对象类型的所有属性，并它们指定新的返回值的类型。那么，我们如何为新的对象类型的属性添加为只读属性呢？或者如果原有的类型中存在只读属性，如何在新的类型中移除只读限制呢？很简单，在签名的<code>[ ]</code> 之前使用 <strong><code>+readonly</code></strong> 、<strong><code>-readonly</code></strong> 号即可，+ 号也可以省略。</p></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Person类型中有只读</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">id</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义一个映射类型MapperA</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MapperA</span>&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]: <span class="built_in">string</span>[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给Mapper传入Person类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PeopleA</span> = <span class="title class_">MapperA</span>&lt;<span class="title class_">Person</span>&gt;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">PersonA为 &#123;</span></span><br><span class="line"><span class="comment">  name: string[],</span></span><br><span class="line"><span class="comment">  age: string[],</span></span><br><span class="line"><span class="comment">  readonly id: string[]</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 - 移除新类型id的readonly限制</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MapperB</span>&lt;T&gt; = &#123;</span><br><span class="line">  -<span class="keyword">readonly</span> [K <span class="keyword">in</span> keyof T]: <span class="built_in">string</span>[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PeopleB</span> = <span class="title class_">MapperB</span>&lt;<span class="title class_">Person</span>&gt;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">PeopleB为 &#123;</span></span><br><span class="line"><span class="comment">  name: string[],</span></span><br><span class="line"><span class="comment">  age: string[],</span></span><br><span class="line"><span class="comment">  id: string[]</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 + 给新的对象类型的所有属性添加只读限制</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MapperC</span>&lt;T&gt; = &#123;</span><br><span class="line">  +<span class="keyword">readonly</span> [K <span class="keyword">in</span> keyof T]: <span class="built_in">string</span>[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PeopleC</span> = <span class="title class_">MapperC</span>&lt;<span class="title class_">Person</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// + 号通常省略</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PeopleCC</span> = <span class="title class_">MapperC</span>&lt;<span class="title class_">Person</span>&gt;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">PeopleC、PeopleCC都为  &#123;</span></span><br><span class="line"><span class="comment">  readonly name: string[];</span></span><br><span class="line"><span class="comment">  readonly age: string[];</span></span><br><span class="line"><span class="comment">  readonly id: string[];</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>?</code> 可选修饰符</strong></li></ul><p>同样，在映射类型产生新类型时，可选修饰符也会保留。我们可以<strong>在签名的 <code>[ ]</code> 后用 <code>-?</code>来移除可选性</strong>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">NewType</span>&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]-?: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-key的重映射"><a href="#3-key的重映射" class="headerlink" title="3. key的重映射"></a>3. <code>key</code>的重映射</h3><p><strong>使用 <code>as</code> 可以在新的对象类型中对原有的 <code>key</code> 进行重映射</strong>。直接<code>show code</code>吧，来一道官方栗子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Getters</span>&lt;<span class="title class_">Type</span>&gt; = &#123;</span><br><span class="line">  <span class="comment">// 这句代码可以分为三个部分</span></span><br><span class="line">  [<span class="title class_">Property</span> <span class="keyword">in</span> keyof <span class="title class_">Type</span> <span class="keyword">as</span> <span class="string">`get<span class="subst">$&#123;Capitalize&lt;</span></span></span><br><span class="line"><span class="subst"><span class="string">    <span class="built_in">string</span> &amp; Property</span></span></span><br><span class="line"><span class="subst"><span class="string">  &gt;&#125;</span>`</span>]: <span class="function">() =&gt;</span> <span class="title class_">Type</span>[<span class="title class_">Property</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">gender</span>: <span class="number">1</span> | <span class="number">2</span>;</span><br><span class="line">  <span class="number">100</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">GetPerson</span> = <span class="title class_">Getters</span>&lt;<span class="title class_">Person</span>&gt;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">GetPerson为 &#123;</span></span><br><span class="line"><span class="comment">  getName: () =&gt; string;</span></span><br><span class="line"><span class="comment">  getAge: () =&gt; number;</span></span><br><span class="line"><span class="comment">  getGender: () =&gt; 1 | 2;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在上面的栗子中，我们把那句代码分为三个部分, “<code>as</code>“ 之前的<code>A</code>部分, “<code>as</code>“ ~ “<code>:</code>“ 之间的<code>B</code>部分，”<code>:</code>“之后的<code>C</code>部分。<code>A</code> 和 <code>C</code>两部分结合起来，就是我们之前了解到的映射类型。所以，难点在于理解 <code>B</code> 部分的内容。这里涉及到了<strong>模板字面量类型</strong>，类似与模板字符串，(下一节有详细介绍)。<strong><code>Capitalize</code></strong>是<code>TS</code>提供的首字母大写的泛型类型。类型参数<code>Property</code>指代<code>keyof</code>每一次遍历到的类型<code>Type</code>的<code>key</code>，使用 <code>as</code> 将 新的对象类型中对应的 <code>key</code> 重命名为 模板字面量类型 <code>get + Property</code>类型(即原来的对象类型的对应的<code>key</code>)中属于<code>string</code>类型的<code>key</code> (即排除<code>number</code>索引) 首字母大写的 。</p><p>还可以利用<code>TS</code>提供<strong><code>Exclude&lt;P, B&gt;</code>的泛型类型</strong>来排除 B 类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新类型中移除了&quot;kind&quot;属性</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">RemoveKindField</span>&lt;<span class="title class_">Type</span>&gt; = &#123;</span><br><span class="line">  [<span class="title class_">Property</span> <span class="keyword">in</span> keyof <span class="title class_">Type</span> <span class="keyword">as</span> <span class="title class_">Exclude</span>&lt;<span class="title class_">Property</span>, <span class="string">&quot;kind&quot;</span>&gt;]: <span class="title class_">Type</span>[<span class="title class_">Property</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>还记得一开始我们说的<strong>关键字 <code>in</code> 后面是一个与类型参数<code>T</code>有关的联合类型</strong>吗？事实上，这个联合类型不是仅仅只能用简单类型的联合，而可以是一切类型的联合，只需要通过 <code>as</code> 来把 <code>key</code> 重新映射为<code>string</code>或<code>number</code>或两者的字面量类型即可。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">EventConfig</span>&lt;<span class="title class_">Events</span> <span class="keyword">extends</span> &#123; <span class="attr">kind</span>: <span class="built_in">string</span> &#125;&gt; = &#123;</span><br><span class="line">  [E <span class="keyword">in</span> <span class="title class_">Events</span> <span class="keyword">as</span> E[<span class="string">&quot;kind&quot;</span>]]: <span class="function">(<span class="params">event: E</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面是一个官网的栗子。<code>Events</code>是一个具<code>kind</code>属性的对象类型的联合类型，<code>E</code>代表这个联合类型中的每一个具有<code>kind</code>属性的对象类型，也是新对象的<code>key</code>，通过<code>as</code> 关键字将 <code>E</code> 重映射为索引访问类型 <code>E[&quot;kind&quot;]</code>，也就是<code>string</code>类型。因此，最后得到的是一个 <code>key</code> 为<code>string</code>类型的方法签名(函数的调用签名)。</p><p>(不得不说，各种类型操纵方法结合起来，是真能玩出花来。虽然明白比尔写的是啥，但我这脑瓜子实在是设计不出来这么优雅的类型。)</p><h2 id="六、模板字面量类型"><a href="#六、模板字面量类型" class="headerlink" title="六、模板字面量类型"></a>六、模板字面量类型</h2><p>这是本文要分享的最后一种类型操纵方式了，毕竟没把泛型加进来讲，因为我之前的文章里介绍过了。</p><ul><li>利用字符串模板的形式，可以得到模板字面量类型。注意类型是用<code>type</code>来定义。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Name</span> = <span class="string">&quot;cc&quot;</span>; <span class="comment">// 类型，不是值，不要使用let、var、const等</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TemplateType</span> = <span class="string">`I am <span class="subst">$&#123;Name&#125;</span>`</span>; <span class="comment">// &#x27;I am cc&#x27;类型，不是值</span></span><br></pre></td></tr></table></figure><ul><li>如果模板用的类型是联合类型，则会分别对联合类型的每一个类型进行处理</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Name</span> = <span class="string">&quot;cc&quot;</span> | <span class="string">&quot;yy&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TemplateType</span> = <span class="string">`love<span class="subst">$&#123;Name&#125;</span>`</span>; <span class="comment">// &#x27;lovecc&#x27; | &#x27;loveyy&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>如果模板本身也是联合类型，则会分别对模板的每一个类型和使用的类型进行处理</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Name</span> = <span class="string">&quot;cc&quot;</span> | <span class="string">&quot;yy&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Gender</span> = <span class="number">1</span> | <span class="number">2</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TemplateType</span> = <span class="string">`love<span class="subst">$&#123;Name | Gender&#125;</span>`</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">则TemplateType为 lovecc | loveyy | love1 | love2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li>如果有多个模板，则是将每个模板的情况和其它模板的情况进行组合</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Name</span> = <span class="string">&quot;cc&quot;</span> | <span class="string">&quot;yy&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Gender</span> = <span class="number">1</span> | <span class="number">2</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Age</span> = <span class="number">18</span> | <span class="number">20</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TemplateType</span> = <span class="string">`<span class="subst">$&#123;Age&#125;</span>love<span class="subst">$&#123;Name | Gender&#125;</span>`</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">则TemplateType为</span></span><br><span class="line"><span class="comment">18lovecc | 18loveyy | 18love1 | 18love2</span></span><br><span class="line"><span class="comment"> | 20lovecc | 20loveyy | 20love1 | 20love2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li>用在函数签名中，才能体会到模版字面量类型有多强大</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">PropEventSource</span>&lt;<span class="title class_">Type</span>&gt; = &#123;</span><br><span class="line">  <span class="comment">// 调用签名，通过模板字面量类型指定了第一个参数的类型</span></span><br><span class="line">  <span class="title function_">on</span>(</span><br><span class="line">    <span class="attr">eventName</span>: <span class="string">`<span class="subst">$&#123;<span class="built_in">string</span> &amp; keyof Type&#125;</span>Changed`</span>,</span><br><span class="line">    <span class="attr">callback</span>: <span class="function">(<span class="params">newValue: <span class="built_in">any</span></span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line">  ): <span class="built_in">void</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>模板字面量类型的推论</li></ul><p>把<code>on( )</code>设计为泛型函数，使<code>TS</code>自己进行类型推论。不说了，都是泪。直接上官方示例代码吧。一层一层的泛型，不思考的话实在不容易看懂。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">PropEventSource</span>&lt;<span class="title class_">Type</span>&gt; = &#123;</span><br><span class="line">  on&lt;<span class="title class_">Key</span> <span class="keyword">extends</span> <span class="built_in">string</span> &amp; keyof <span class="title class_">Type</span>&gt;(</span><br><span class="line">    <span class="attr">eventName</span>: <span class="string">`<span class="subst">$&#123;Key&#125;</span>Changed`</span>,</span><br><span class="line">    <span class="attr">callback</span>: <span class="function">(<span class="params">newValue: Type[Key]</span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line">  ): <span class="built_in">void</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="七、内置的字符串操纵类型"><a href="#七、内置的字符串操纵类型" class="headerlink" title="七、内置的字符串操纵类型"></a>七、内置的字符串操纵类型</h2><h3 id="1-Uppercase-lt-StringType-gt"><a href="#1-Uppercase-lt-StringType-gt" class="headerlink" title="1. Uppercase &lt;StringType&gt;"></a>1. <code>Uppercase &lt;StringType&gt;</code></h3><p>产生一个<strong>将泛型类型（必须是字符串类型、字符串型的字面量类型）所有字母转化为大写</strong>的新类型。不改变原来的类型。如果是<code>string</code>类型而不是字面量类型，则生成的类型依然是<code>string</code>，不要求其值的首字母大写（一下几个内置方法都是如此）。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Name</span> = <span class="string">&quot;cc&quot;</span> | <span class="string">&quot;yy&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UpperName</span> = <span class="title class_">Uppercase</span>&lt;<span class="title class_">Name</span>&gt;; <span class="comment">// &#x27;CC&#x27; | &#x27;YY&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="2-Lowercase-lt-StringType-gt"><a href="#2-Lowercase-lt-StringType-gt" class="headerlink" title="2. Lowercase &lt;StringType&gt;"></a>2. <code>Lowercase &lt;StringType&gt;</code></h3><p>产生一个<strong>将泛型类型（必须是字符串类型、字符串型的字面量类型）所有字母转化为小写</strong>的新类型。不改变原来的类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Name</span> = <span class="string">&quot;CC&quot;</span> | <span class="string">&quot;YY&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UpperName</span> = <span class="title class_">Uppercase</span>&lt;<span class="title class_">Name</span>&gt;; <span class="comment">// &#x27;cc&#x27; | &#x27;yy&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="3-Capitalize-lt-StringType-gt"><a href="#3-Capitalize-lt-StringType-gt" class="headerlink" title="3. Capitalize &lt;StringType&gt;"></a>3. <code>Capitalize &lt;StringType&gt;</code></h3><p>产生一个<strong>将泛型类型（必须是字符串类型、字符串型的字面量类型）首字母转化为大写</strong>的新类型。不改变原来的类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Name</span> = <span class="string">&quot;cc&quot;</span> | <span class="string">&quot;yy&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UpperName</span> = <span class="title class_">Uppercase</span>&lt;<span class="title class_">Name</span>&gt;; <span class="comment">// &#x27;Cc&#x27; | &#x27;Yy&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="4-Uncapitalize-lt-StringType-gt"><a href="#4-Uncapitalize-lt-StringType-gt" class="headerlink" title="4. Uncapitalize &lt;StringType&gt;"></a>4. <code>Uncapitalize &lt;StringType&gt;</code></h3><p>产生一个<strong>将泛型类型（必须是字符串类型、字符串型的字面量类型）首字母转化为小写</strong>的新类型。不改变原来的类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Name</span> = <span class="string">&quot;CC&quot;</span> | <span class="string">&quot;YY&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UpperName</span> = <span class="title class_">Uppercase</span>&lt;<span class="title class_">Name</span>&gt;; <span class="comment">// &#x27;cC&#x27; | &#x27;yY&#x27;</span></span><br></pre></td></tr></table></figure><p>好了，本篇就到此为止了，各种类型已经把我玩出花来了。下一篇，我们将一起学习 <strong><code>class</code></strong> ，不见不散！</p>]]></content>
      
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript 系列基础篇(三) 对象类型</title>
      <link href="/onlyy-blog/articals/e67cc259bdfa/"/>
      <url>/onlyy-blog/articals/e67cc259bdfa/</url>
      
        <content type="html"><![CDATA[<h1 id="TypeScript-系列基础篇-三-对象类型"><a href="#TypeScript-系列基础篇-三-对象类型" class="headerlink" title="TypeScript 系列基础篇(三) 对象类型"></a>TypeScript 系列基础篇(三) 对象类型</h1><p>对象是我们组织数据的基本方式。除了常规的对象类型外，TS 还提供了<strong>只读数组</strong>、<strong>元组</strong>、<strong>属性修饰符</strong>、<strong>索引签名</strong>等知识体系。在前面的章节中，我们已经了解到了对象的基本使用。可以用<strong>字面量</strong>、<strong><code>interface</code></strong>、<strong><code>type alias</code></strong>来规定一个普通的对象类型。现在是时候了解一下常用的对象属性修饰符、类型拓展、索引签名和内置的特殊对象类型了。 还没有对象吗？那就赶紧<code>new</code>一个吧！</p><h2 id="一、属性修饰符"><a href="#一、属性修饰符" class="headerlink" title="一、属性修饰符"></a>一、<mark>属性修饰符</mark></h2><p>利用属性修饰符，我们可以增强对象的属性的约束。</p><h3 id="1-可选属性"><a href="#1-可选属性" class="headerlink" title="1. ? 可选属性"></a>1. <code>?</code> 可选属性</h3><p>可选属性我们在之前就已经有所了解。定义对象类型时，在属性名后面加上英文问号 “<code>?</code>“ ，表示该属性可选。此后，该类型的对象里可以有这个属性，也可以没有。因此，该属性除了我们给它约束了的类型之外，还可能是<code>undefined</code>，从而引发某些问题。在之前的文章中提到过，这可以通过<strong>真值校验</strong>来进行类型缩减，或者给函数的形参设置默认值，从而解决。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其中gender为可选属性</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  gender?: <span class="number">1</span> | <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以有全部属性</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">cc</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;cc&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">gender</span>: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以缺失可选属性</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">yy</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;yy&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-readonly-只读属性"><a href="#2-readonly-只读属性" class="headerlink" title="2. readonly 只读属性"></a>2. <code>readonly</code> 只读属性</h3><p>在对象的某个或某些属性前加上关键字 <strong><code>readonly</code></strong>，可以设置该属性为只读属性。<strong>对象的只读属性在<code>TS</code>里一般不允许被重新赋值</strong>。只读属性不意味着完全不能修改。如果只读属性是一个对象类型，那我们可以修改它里面的成员。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// id为只读属性，不允许重新赋值</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">idInfo</span>: &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">addr</span>: <span class="built_in">string</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以有全部属性</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">cc</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;cc&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">idInfo</span>: &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="string">&quot;42xxxx199x04xxxx1X&quot;</span>,</span><br><span class="line">    <span class="attr">addr</span>: <span class="string">&quot;Wuhan&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面这句会报错，因为cc的id信息被设置为只读属性，不可以被重新哦</span></span><br><span class="line">cc.<span class="property">idInfo</span> = &#123; <span class="attr">id</span>: <span class="string">&quot;xiao cai ji&quot;</span>, <span class="attr">addr</span>: <span class="string">&quot;beijing&quot;</span> &#125;;</span><br><span class="line"><span class="comment">// 这样修改就可以啦</span></span><br><span class="line">cc.<span class="property">idInfo</span>.<span class="property">addr</span> = <span class="string">&quot;beijing&quot;</span>;</span><br></pre></td></tr></table></figure><p>然而事实上，在<code>TS</code>里我们依然有方法可以让只读属性被重新赋值。由于<code>TS</code>的类型检查机制，在检查两个对象类型是否兼容时，只针对类型，而不会去检测属性是否有 <code>readonly</code> 。例如，下面这两个对象类型是完全相互兼容的。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// id为只读属性，不允许重新赋值</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">idInfo</span>: &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">addr</span>: <span class="built_in">string</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 没有readonly属性，所有成员都可以被赋值</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">People</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">idInfo</span>: &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">addr</span>: <span class="built_in">string</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意Person的属性是只读的</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">person</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;gg&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">15</span>,</span><br><span class="line">  <span class="attr">idInfo</span>: &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="string">&quot;qaq&quot;</span>,</span><br><span class="line">    <span class="attr">addr</span>: <span class="string">&quot;zzZ&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 声明一个People类型的对象person，它的属性不是只读的</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">people</span>: <span class="title class_">People</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型兼容，具有只读属性的person可以被赋值给people</span></span><br><span class="line"><span class="comment">// 此时people是People类型，其属性可以修改；person是Person类型，其属性只读</span></span><br><span class="line"><span class="comment">// 熟悉JS引用类型的同学们都知道，people和person是同一个对象</span></span><br><span class="line">people = person;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改people的属性，我们发现person也会被相应修改，因为他们实际是同一个对象</span></span><br><span class="line">people.<span class="property">name</span> = <span class="string">&quot;pp&quot;</span>;</span><br><span class="line">people.<span class="property">age</span> = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p>从这个栗子中可以看到，我们可以通过一个<strong>不具有相应只读属性，且属性类型能够兼容</strong>的对象，来重写另一个对象的只读属性。因此，在<strong>使用只读属性时，一定要注意这种情况</strong>，以免引起超出意料的困扰。</p><h2 id="二、索引签名"><a href="#二、索引签名" class="headerlink" title="二、索引签名"></a>二、<mark>索引签名</mark></h2><p>在上一篇文章<a href="https://juejin.cn/post/7070172611849748517">TS 中的函数签名，函数重载，泛型函数，你都了解多少？Typescript 系列：(二)函数篇 </a>中，我们了解了函数签名。和这里的<strong>索引签名</strong>多多少少有些相像。</p><p>我们在使用<strong><code>interface</code></strong>或者<strong><code>type alias</code></strong>定义某个对象类型时，以往的做法是列举出所有的属性名并规定它们的值的类型。但是有时候，我们不知道对象里会有哪些属性，无法逐个列出。此时，我们可以使用<mark><strong>索引签名</strong></mark>，来<strong>规定属性名的类型</strong>和对应属性值的类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过索引签名，我们可以定义一个伪数组的</span></span><br><span class="line"><span class="comment">// 规定了属性名必须是number</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">StringArray</span> &#123;</span><br><span class="line">  [<span class="attr">index</span>: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意和真数组区分开来</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">strArr1</span>: <span class="title class_">StringArray</span> = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&quot;100分&quot;</span>,</span><br><span class="line">  <span class="number">5</span>: <span class="string">&quot;95分&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 报错，因为属性名grades不是number类型，不符合StringArray类型的约束</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">strArr2</span>: <span class="title class_">StringArray</span> = &#123;</span><br><span class="line">  <span class="attr">grades</span>: <span class="string">&quot;100分&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当我们使用<code>number</code>类型作为属性名时，<code>JS</code>在把他放进对象之前<strong>会先将其转化为<code>string</code>类型</strong>。索引签名可以和指定属性名,以及属性修饰符混合使用，此时，对象中必须包含列举出的属性(可选属性除外)，而且可拓展符合索引签名的约束的属性。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  [<span class="attr">x</span>: <span class="built_in">string</span>]: <span class="built_in">string</span>;</span><br><span class="line">  <span class="number">100</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="number">50</span>?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">cc</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="number">100</span>: <span class="string">&quot;满意100&quot;</span>,</span><br><span class="line">  <span class="number">6</span>: <span class="string">&quot;我是由索引签名拓展的属性&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">yy</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&quot;QAQ&quot;</span>,</span><br><span class="line">  <span class="number">100</span>: <span class="string">&quot;555~&quot;</span>,</span><br><span class="line">  <span class="number">50</span>: <span class="string">&quot;0.0&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>索引签名可以不止一套，但是<strong>各个索引签名的返回值应该互相兼容</strong>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  [<span class="attr">x</span>: <span class="built_in">string</span>]: <span class="built_in">string</span>;</span><br><span class="line">  [<span class="attr">y</span>: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以<strong>在索引签名的签名加上<code>readonly</code>关键字，使被签名的属性变为只读属性。</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> [<span class="attr">x</span>: <span class="built_in">number</span>]: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">cc</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="number">2</span>: <span class="string">&quot;cc&quot;</span>,</span><br><span class="line">  <span class="number">5</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="number">10</span>: <span class="string">&quot;boi&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="三、类型拓展"><a href="#三、类型拓展" class="headerlink" title="三、类型拓展"></a>三、<mark>类型拓展</mark></h2><p>我们可以从已有的对象类型的配置中，生成一个全新的类型，使其不仅含有原来类型的所有属性，还能拥有自己独有的属性。这样可以方便地实现类型复用，避免过多地重复敲代码，提高我们的工作效率。在定义新类型时，<strong>使用 <code>interface</code> 和 <code>type</code> 关键字，实现类型拓展的方式会有差别</strong>。</p><h3 id="1-类型继承"><a href="#1-类型继承" class="headerlink" title="1. 类型继承"></a>1. 类型继承</h3><p>使用<strong><code>interface</code></strong>关键字声明的对象类型，可以通过<strong><code>extends</code></strong>关键字来继承其它的对象类型，从而<strong>直接获得父类型的所有属性配置、属性签名，而不必重复列举一遍</strong>。<strong>可以同时继承多个对象类型</strong>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> B &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C类型继承A类型，包含name属性，不添加其它属性</span></span><br><span class="line"><span class="keyword">interface</span> C <span class="keyword">extends</span> A &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CC类型继承A，B类型，包含name, age, 以及自己列举的gender属性</span></span><br><span class="line"><span class="keyword">interface</span> CC <span class="keyword">extends</span> A, B &#123;</span><br><span class="line">  <span class="attr">gender</span>: <span class="number">1</span> | <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-类型交叉"><a href="#2-类型交叉" class="headerlink" title="2. 类型交叉"></a>2. 类型交叉</h3><p>通过<strong><code>type</code></strong>关键字给一个对象类型起<strong>别名</strong>时，使用 <code>&amp;</code> 符号来连接多个类型，从而产生一个新类型，新的类型包含所有其它对象类型的属性，即类型交叉。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> B &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类型CC包含name和age属性</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">CC</span> = A &amp; B;</span><br></pre></td></tr></table></figure><p>值得一提的是，如果 <code>&amp;</code> 连接的是简单联合类型，则产生的新类型是 <code>&amp;</code> 符号两边类型的公有类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">type</span> B = <span class="built_in">string</span>[] | <span class="built_in">number</span>;</span><br><span class="line"><span class="comment">// C是A和B共有的类型，number类型</span></span><br><span class="line"><span class="keyword">type</span> C = A &amp; B;</span><br></pre></td></tr></table></figure><p>这一点 和 <code>&amp;</code>在对象类型之间的使用看起来完全不同，起初我也有些疑惑。但是我们可以从本质上来思考，就不再有疑惑了。在关键字 type 定义的类型别名中，使用 <code>&amp;</code> 符号连接已有的类型可以产生一个新的类型，这个<strong>新类型需要同时满足 <code>&amp;</code> 符号两边的类型的约束</strong>。</p><p>因此，在<strong>对象类型的栗子</strong>中，新类型<code>CC</code>既需要满足<code>A</code>类型的约束 (因此<code>CC</code>必须有<code>A</code>的所有属性)，又必须满足类型 B 的约束 (因此必须含有类型 B 的所有属性)，即<code>CC</code>具有<code>A</code>和<code>B</code>的所有属性。</p><p>而在<strong>简单联合类型</strong>的栗子中，新类型<code>C</code>既要满足 A 的类型约束 (要么<code>C</code>是<code>number</code>, 要么是<code>string</code>)，又要满足类型<code>B</code>的约束 (要么<code>C</code>是字符串数组<code>string[]</code>，要么是<code>number</code>)，因此最终得到的<code>C</code>是<code>number</code>。</p><h2 id="四、泛型对象"><a href="#四、泛型对象" class="headerlink" title="四、泛型对象"></a>四、<mark>泛型对象</mark></h2><p><strong>泛型</strong>：使用尖括号<code>&lt;&gt;</code>来声明类型参数 (可以有多个)来表示暂时未知的类型，在实际声明变量时传入相应的类型 (或者由<code>TS</code>自动推论) 来替换相应出现该类型参数的地方，从而将抽象的、未知的类型替换为具体的、已知的类型。一个类型参数指代一种类型，例如<code>&lt;T,K,U,...&gt;</code>分别指代一种暂时未知的类型。将泛型用于定义对象类型，便得到了<strong>泛型对象</strong>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型T代表一种暂时未知的类型</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">PersonInfo</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">info</span>: T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 传入类型变量string，这时候string就会在相应的地方替换原来的T</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">p1</span>: <span class="title class_">PersonInfo</span>&lt;<span class="built_in">string</span>&gt; = &#123;</span><br><span class="line">  <span class="attr">info</span>: <span class="string">&quot;cc&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">p2</span>: <span class="title class_">PersonInfo</span>&lt;<span class="built_in">number</span>&gt; = &#123;</span><br><span class="line">  <span class="attr">info</span>: <span class="number">18</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">p3</span>: <span class="title class_">PersonInfo</span>&lt;<span class="string">&quot;男&quot;</span> | <span class="string">&quot;女&quot;</span>&gt; = &#123;</span><br><span class="line">  <span class="attr">info</span>: <span class="string">&quot;男&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>泛型对象常用于泛型函数，可参考<a href="https://juejin.cn/post/7070172611849748517">TS 中的函数签名，函数重载，泛型函数，你都了解多少？Typescript 系列：(二)函数篇</a>。</p><p><strong>泛型同样可在类型别名中使用</strong>。而类型别名除了定义对象类型之外，还能用泛型来定义各种其它类型。因此，我们可以<strong>使用泛型嵌套来定义更为复杂的类型结构</strong> (孩子已经哭了，难怪都说，玩会了泛型，<code>TS</code>就学完了一半)。本文主要介绍对象类型，关于泛型，以后再专门介绍。如下是官网的一个栗子。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">OrNull</span>&lt;<span class="title class_">Type</span>&gt; = <span class="title class_">Type</span> | <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">OneOrMany</span>&lt;<span class="title class_">Type</span>&gt; = <span class="title class_">Type</span> | <span class="title class_">Type</span>[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">OneOrManyOrNull</span>&lt;<span class="title class_">Type</span>&gt; = <span class="title class_">OrNull</span>&lt;<span class="title class_">OneOrMany</span>&lt;<span class="title class_">Type</span>&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">OneOrManyOrNullStrings</span> = <span class="title class_">OneOrManyOrNull</span>&lt;<span class="built_in">string</span>&gt;;</span><br></pre></td></tr></table></figure><h2 id="五、数组类型"><a href="#五、数组类型" class="headerlink" title="五、数组类型"></a>五、数组类型</h2><p>我们知道，数组是一种特殊的对象类型。上面简单了解了下泛型，那么我们现在就能知道，原来所谓数值数组、字符串数组等 (<code>number[]</code>，<code>string[]</code> )是泛型数组<code>Array&lt;number&gt;</code>，<code>Array&lt;string&gt;</code>的简写。现代<code>JS</code>也提供了其它新类型的泛型结构，如<code>Map&lt;T, K&gt;</code>，<code>Set&lt;T&gt;</code>，<code>Promise&lt;T&gt;</code>等，类型参数的数量都取决于各类型的自身行为表现。</p><h3 id="1-ReadonlyArray-只读数组"><a href="#1-ReadonlyArray-只读数组" class="headerlink" title="1. ReadonlyArray 只读数组"></a>1. <code>ReadonlyArray</code> 只读数组</h3><p>只读数组是<code>TS</code>提供的一种特殊的数组，它的任何成员都不能被修改。</p><ul><li>无法进行新增、删除、替换等操作，<code>push</code>、<code>pop</code>等修改自身的方法都无法使用。</li><li>可以使用不修改自身的数组方法。例如使用<code>slice</code>方法，返回一个普通的数组</li><li>代表一种类型，无法当作构造函数使用，不能使用<code>new</code>操作符。</li><li>在声明一个只读数组类型的变量时需指定类型参数，只读数组里只能存放该类型的值。</li><li>只读数组类型的变量本身可以接收普通数组的赋值。</li><li>普通数组不能接收只读数组的赋值</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定类型参数number，即该只读数组里只</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="title class_">ReadonlyArray</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">123</span>];</span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line">a.<span class="title function_">pop</span>();</span><br><span class="line"><span class="comment">// 可以使用slice方法</span></span><br><span class="line"><span class="keyword">let</span> cc = a.<span class="title function_">slice</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该变量可以用普通重新赋值</span></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">let</span> val = <span class="keyword">new</span> <span class="title class_">ReadonlyArray</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">aa</span>: <span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">456</span>];</span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line">aa = a;</span><br></pre></td></tr></table></figure><h3 id="2-Tuple-Types-元组"><a href="#2-Tuple-Types-元组" class="headerlink" title="2. Tuple Types 元组"></a>2. <code>Tuple Types</code> 元组</h3><p><mark><strong>元组</strong></mark>类型是另一种特殊的数组类型，<strong>一般来说</strong>它可以存储不同类型的成员，<strong>限定了数组的长度及每个成员的类型</strong>。(<strong>普通数组也可以通过指定联合类型的类型参数，从而存放不同类型的成员)</strong>。元组的成员是可以被修改，可以调用一系列的数组方法。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">UserInfo</span> = [<span class="built_in">string</span>, <span class="built_in">number</span>, <span class="number">1</span> | <span class="number">2</span>];</span><br></pre></td></tr></table></figure><p>这里得<code>UserInfo</code>便是一个元组类型，规定了元组里<strong>有且仅有</strong>三个成员，索引为<code>0</code>的成员是<code>string</code>类型，索引为<code>1</code>的成员是<code>number</code>类型，索引为<code>2</code>的成员 是字面量联合类型 <code>1 | 2</code> 。</p><ul><li>元组类型可以被解构。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">introduceUser</span>(<span class="params">info: UserInfo</span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [name, age, gender] = info;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`我是<span class="subst">$&#123;name&#125;</span>，今年<span class="subst">$&#123;age&#125;</span>岁啦`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>元组也可以指定可选成员</strong>：</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第三个成员可选</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UserInfo</span> = [<span class="built_in">string</span>, <span class="built_in">number</span>, (<span class="number">1</span> | <span class="number">2</span>)?];</span><br></pre></td></tr></table></figure><ul><li>元组中可使用剩余参数，来<strong>指定某个或某些索引位置的成员的类型和其它成员的类型</strong>。此时，元组没有长度限制。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">FamilyMember</span> = <span class="built_in">string</span>[];</span><br><span class="line"><span class="comment">// 指定索引0处的类型为string，索引1处的类型为number，剩余类型为FamilyMember</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UserInfo1</span> = [<span class="built_in">string</span>, <span class="built_in">number</span>, ...<span class="title class_">FamilyMember</span>[]];</span><br><span class="line"><span class="comment">// 同理</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UserInfo2</span> = [<span class="built_in">string</span>, <span class="built_in">number</span>, ...<span class="title class_">FamilyMember</span>[], <span class="built_in">boolean</span>];</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UserInfo3</span> = [...<span class="title class_">FamilyMember</span>[], <span class="built_in">string</span>, <span class="built_in">number</span>];</span><br></pre></td></tr></table></figure><ul><li><p><strong><code>readonly</code></strong> 只读元组类型</p><p>我们可以用类似 数组类型的简写方式 来声明一个只读元组：<strong><code>readonly [string, number]</code></strong>，使元组的成员变为只读成员，不可修改。<strong><code>readonly</code>关键字只能用于字面量数组或字面量元组类型之前，不可用于类型别名之前</strong>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ok</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">cc</span>: <span class="keyword">readonly</span> [<span class="built_in">string</span>, <span class="built_in">number</span>] = [<span class="string">&quot;cc&quot;</span>, <span class="number">18</span>];</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">yy</span>: <span class="keyword">readonly</span> <span class="title class_">UserInfo3</span> = [[<span class="string">&quot;dd&quot;</span>], <span class="string">&quot;1&quot;</span>, <span class="number">1</span>];</span><br><span class="line"><span class="comment">// 用于字面量元组之前，ok</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">yy</span>: <span class="keyword">readonly</span> [...<span class="title class_">FamilyMember</span>[], <span class="built_in">string</span>, <span class="built_in">number</span>] = [[<span class="string">&quot;dd&quot;</span>], <span class="string">&quot;1&quot;</span>, <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错，只读属性不可修改</span></span><br><span class="line">cc[<span class="number">0</span>] = <span class="string">&quot;yy&quot;</span>;</span><br></pre></td></tr></table></figure><p>此外，如果我们对数组使用<mark><strong>常量断言</strong></mark>：<strong><code>as const</code></strong>，该数组的类型也会变为只读元组。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> yy = [<span class="string">&quot;yy&quot;</span>, <span class="number">18</span>] <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错，只读属性不可修改</span></span><br><span class="line">yy[<span class="number">0</span>] = <span class="string">&quot;cc&quot;</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>ReadonlyArray</code>、<code>tuple</code>、<code>readonly tuple</code> 的主要区别。</p><ul><li><code>ReadonlyArray</code> 只读数组：不可修改数组成员，不可增删改，不会为每个数组成员单独指定类型，可以被重新赋值；</li><li><code>tuple</code> 元组：一般指定了长度和各个成员的类型，使用剩余参数法来声明元组类型时则没有限制长度；元组可以修改成员的值；可以被重新赋值；</li><li><code>readonly tuple</code>：一般指定了长度和各个成员的类型，使用剩余参数法来声明元组类型时则没有限制长度，不可修改成员的值，不可被重新赋值；</li></ul></li></ul><p>关于对象类型就先分享到这里啦。如果觉得我的文章有不妥之处，欢迎在评论区留言指正。下一期聊聊<strong>泛型</strong>，不见不散。</p>]]></content>
      
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typescript 系列基础篇(二) TS 中的函数</title>
      <link href="/onlyy-blog/articals/a464066672a0/"/>
      <url>/onlyy-blog/articals/a464066672a0/</url>
      
        <content type="html"><![CDATA[<h1 id="Typescript-系列基础篇-二-TS-中的函数"><a href="#Typescript-系列基础篇-二-TS-中的函数" class="headerlink" title="Typescript 系列基础篇(二) TS 中的函数"></a>Typescript 系列基础篇(二) TS 中的函数</h1><p>函数在我们日常代码中占有绝对重要的地位，深入了解 TS 中函数的使用对我们的学习十分有利。如果你还不了解<strong>泛型函数</strong>、<strong>函数签名</strong>、<strong>函数重载</strong>，那么阅读本文将让你对 TS 中的函数有一个更加细致的理解，必能有所收获。</p><h2 id="一、返回值"><a href="#一、返回值" class="headerlink" title="一、返回值"></a>一、返回值</h2><p>我们在声明一个函数 / 方法时，可以在括号后加上类型注释，以约束其返回值的类型，如果没有明确约束返回值的类型，则将其推论为 any 类型。<strong>除了<code>void</code>和<code>any</code>之外，其它所有的类型都应该有相应类型的返回值。</strong></p><ul><li>返回值如果不是约束的类型，或者约束了类型却没有<code>return</code>相应的类型，则会报错：</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明变量时由初始值&#x27;cc&#x27;进行类型推论，得出_name为string类型</span></span><br><span class="line"><span class="keyword">let</span> _name = <span class="string">&quot;cc&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会报错，约束了返回值的类型，却没有return相应的类型,</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getName1</span>(<span class="params"></span>): <span class="built_in">string</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 约束了返回值类型只能时string</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getName1</span>(<span class="params"></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> _name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个number类型的变量_name2</span></span><br><span class="line"><span class="keyword">let</span> _name2 = <span class="number">18</span>;</span><br><span class="line"><span class="comment">// 约束函数返回值类型为string</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getName2</span>(<span class="params"></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="comment">// 会报错，返回值应该是string类型，而_name2是number类型</span></span><br><span class="line">  <span class="keyword">return</span> _name2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当我们<strong>实际的返回值有可能不是约束的类型时</strong>，也是不正确的：</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">_name3</span>: <span class="built_in">string</span> | <span class="built_in">number</span> = <span class="string">&quot;cc&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getName3</span>(<span class="params"></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="comment">// 不合法的返回值，因为_name3有可能是number类型，而返回值只能是string类型</span></span><br><span class="line">  <span class="keyword">return</span> _name3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这种情况<strong>尤其容易发生在字面量类型上</strong>：</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// _name4经类型推论判定为string类型</span></span><br><span class="line"><span class="keyword">let</span> _name4 = <span class="string">&quot;cc&quot;</span>;</span><br><span class="line"><span class="comment">// 约束返回值只能为 &#x27;cc&#x27; | &#x27;yy&#x27; 类型</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getName4</span>(<span class="params"></span>): <span class="string">&quot;cc&quot;</span> | <span class="string">&quot;yy&quot;</span> &#123;</span><br><span class="line">  <span class="comment">// 会报错，虽然_name4的值为&#x27;cc&#x27;，但它是string类型，不符合要求</span></span><br><span class="line">  <span class="comment">// return _name4</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 可以用类型断言来解决，后面我们将介绍类型缩减来解决</span></span><br><span class="line">  <span class="keyword">return</span> _name4 <span class="keyword">as</span> <span class="string">&quot;cc&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数的返回值为空时，使用<code>void</code>类型，此时可以<code>return undefined</code>，<code>return null</code>，也可以不写<code>return</code>，会默认返回<code>undefined</code>：</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> _name = <span class="string">&quot;cc&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回空值undefined</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setName</span>(<span class="params">name</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  _name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="title function_">setName</span>(<span class="string">&quot;yy&quot;</span>); <span class="comment">// a为undefined</span></span><br></pre></td></tr></table></figure><h2 id="二、参数"><a href="#二、参数" class="headerlink" title="二、参数"></a>二、参数</h2><p>在<code>TS</code>中我们往往需要对函数的参数添加类型注释，如果不添加类型注释，则该参数将被类型推论为<code>any</code>。<code>TS</code>不仅约束了传参时实参的类型，也约束了在函数内部形参的类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> _name = <span class="string">&quot;cc&quot;</span>;</span><br><span class="line"><span class="comment">// 定义一个接收string类型，无返回值的函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setName2</span>(<span class="params">name: <span class="built_in">string</span></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  _name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时候，我们的参数比较复杂，例如多种类型的组合：<code>string | number</code>，这时候我们需要进行<strong>类型缩减</strong>，以防在<code>return</code>或参数调用方法等情况下出现问题。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> _name = <span class="string">&quot;cc&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setName3</span>(<span class="params">name: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="comment">// 参数name有可能是number，因此不能直接赋值</span></span><br><span class="line">  _name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setName3</span>(<span class="params">name: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="comment">// name是string类型</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> name === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">    _name = name;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// name是number类型，可强制转化</span></span><br><span class="line">    _name = <span class="title class_">String</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时候，某个参数不是必须传的，就可以在形参后加上英文问号”<code>?</code>“来表示<strong>可选参数</strong>，如果调用函数时不传该参数，则该参数为<code>undefined</code>。因此，在函数体内部，该参数有可能是<code>undefined</code>，也需要进行类型缩减。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">userInfo</span>: &#123; <span class="attr">name</span>: <span class="built_in">string</span>; <span class="attr">age</span>: <span class="built_in">number</span>; <span class="attr">gender</span>: <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setUserInfo</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span>, gender?: <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (gender === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    userInfo.<span class="property">gender</span> = <span class="number">3</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    userInfo.<span class="property">gender</span> = gender;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、函数类型表达式"><a href="#三、函数类型表达式" class="headerlink" title="三、函数类型表达式"></a>三、函数类型表达式</h2><p>TS 中可以使用箭头函数的形式来定义一个函数类型：<strong><code>(a: Type1, b: Type2, ...) =&gt; TypeN</code></strong>表示<strong>接收的参数名称为<code>a</code>, <code>b</code> , …，类型分别为<code>Type1</code>, <code>Type2</code>,…，返回值类型为<code>TypeN</code>的函数。</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义了类型Fn1是一个函数，接收一个string类型的name和number类型的age为参数，</span></span><br><span class="line"><span class="comment">// 返回一个sttring类型的值</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Fn1</span> = <span class="function">(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给fn1添加Fn1类型，则参数和返回值都需要满足Fn1的约束</span></span><br><span class="line"><span class="comment">// 已经由Fn1约束了类型，因此无需再对参数和返回值进行类型注释</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">fn1</span>: <span class="title class_">Fn1</span> = <span class="keyword">function</span> (<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;I am&quot;</span> + name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以使用箭头函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">fn11</span>: <span class="title class_">Fn1</span> = <span class="function">(<span class="params">name, age</span>) =&gt;</span> <span class="string">&quot;I am&quot;</span> + name;</span><br></pre></td></tr></table></figure><p>在声明对象的方法时，可以很方便地使用函数类型表达式：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个User接口，其中包含interest方法，需要传入一个string类型的参数，</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">interest</span>: <span class="function">(<span class="params">something: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">user</span>: <span class="title class_">User</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;cc&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="title function_">interest</span>(<span class="params">something</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="四、类型缩减"><a href="#四、类型缩减" class="headerlink" title="四、类型缩减"></a>四、类型缩减</h2><p>在函数中，我们会经常遇到形参是组合类型或可选参数的情况，这时候我们就需要进行类型缩减，对该参数的类型抽丝剥茧，从而在每个具体的子类型时做相应的操作，防止类型出错。在该过程中，越往后该参数可能的类型范围就越小。</p><p>主要有 <strong>控制流分析</strong>：<code>if-else</code> 或 <code>switch-case</code> 。</p><h3 id="一-控制流分析"><a href="#一-控制流分析" class="headerlink" title="(一) 控制流分析"></a>(一) 控制流分析</h3><p>通过 if，else 等控制流语句来逐步缩减参数的类型范围。</p><ul><li><strong><code>typeof</code></strong> 类型守卫</li></ul><p>在下面的例子中，我们使用了<strong><code>typeof</code></strong> 这个 <strong><code>type gurads</code></strong> 类型守卫，<code>typeof</code>会返回一些列固定的字符串，我们根据这些字符串来减少类型范围。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Fn</span> = <span class="function">(<span class="params">name?: <span class="built_in">string</span> | <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">fn</span>: <span class="title class_">Fn</span> = <span class="keyword">function</span> (<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="comment">// 类型缩减</span></span><br><span class="line">  <span class="keyword">if</span> (name === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;default name&quot;</span>;</span><br><span class="line">    <span class="comment">// 接下来只能是string或者number</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> name === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">    <span class="comment">// 接下来只能是number</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">String</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><code>typeof</code> 的返回值</strong>：</p><ol><li><p><strong>“<code>string</code>“</strong></p></li><li><p><strong>“<code>numbrt</code>“</strong></p></li><li><p><strong>“<code>bigint</code>“</strong></p></li><li><p><strong>“<code>boolean</code>“</strong></p></li><li><p><strong>“<code>symbol</code>“</strong></p></li><li><p><strong>“<code>undefined</code>“</strong></p></li><li><p><strong>“<code>object</code>“</strong></p></li><li><p><strong>“<code>function</code>“</strong></p></li></ol><p>可以看到，<strong><code>typeof</code>无法检测出<code>null</code></strong>这个空值，<code>typeof null</code>会返回”<code>object</code>“，因此，我们可以辅以“<code>truthiness</code>”检测进行真值校验。</p><ul><li><p><strong><code>Truthiness narrowing</code></strong> 真值校验</p><p>利用<code>true</code>和<code>false</code>来进行真值条件判断，从而达到类型缩减的目的。</p></li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Fn</span> = <span class="function">(<span class="params">name?: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">fn2</span>: <span class="title class_">Fn</span> = <span class="keyword">function</span> (<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="comment">// 真值校验</span></span><br><span class="line">  <span class="keyword">if</span> (name) &#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;default name&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>下面列举出使用 <code>if</code> 会得到 <code>false</code> 的值</strong>，根据官方文档的描述，除了以下列举的值之外，其它的值都会返回<code>true</code>。</p><ol><li><p><strong><code>0</code></strong></p></li><li><p><strong><code>NaN</code></strong></p></li><li><p><strong>“”</strong> 空字符串</p></li><li><p><strong><code>0n</code></strong> 数字<code>0</code> + 字母<code>n</code>，是<code>bigint</code>类型的 <code>0</code></p></li><li><p><strong><code>null</code></strong></p></li><li><p><strong><code>undefined</code></strong></p></li></ol><p>如果我们想把任何值转化为相应的<code>boolean</code>类型，可以利用布尔否定符”<code>!</code>“，任何值经过双重否定之后都会转化为相应的布尔值。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">!!<span class="number">0</span>; <span class="comment">// false</span></span><br><span class="line">!!<span class="title class_">NaN</span>; <span class="comment">// false</span></span><br><span class="line">!!<span class="string">&quot;&quot;</span>; <span class="comment">// false</span></span><br><span class="line">!!<span class="string">&quot;name&quot;</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li><p><strong><code>Equality narrowing</code></strong> 等值校验</p><p>利用已知条件进行等值校验，从而 TS 可以推断出相应的参数类型，达到类型缩减的目的。</p></li><li><p><strong><code>in</code> 操作符</strong></p><p>使用表达式 <strong><code>&quot;value&quot; in x</code></strong>，来判断对象里是否存在某个属性，来进行类型缩减。</p></li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Fish</span> = &#123;</span><br><span class="line">  <span class="attr">swim</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Dog</span> = &#123;</span><br><span class="line">  <span class="attr">bark</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params">obj: Fish | Dog</span>) &#123;</span><br><span class="line">  <span class="comment">// 有bark方法的则是Dog</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&quot;bark&quot;</span> <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;汪汪汪&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 否则是Fish</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;I am Fish&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>使用 <strong><code>instanceof</code></strong></p><p>用于<code>Array</code>，<code>Date</code>等引用类型。</p></li></ul><h3 id="二-类型预言"><a href="#二-类型预言" class="headerlink" title="(二) 类型预言"></a>(二) 类型预言</h3><p>想要定义一个自定义的类型守卫，我们通常可以使用一个返回值是类型预言的函数。</p><p>类型预言格式：<strong><code>param is Type</code></strong>，随后我们可以用该函数来进行类型缩减。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Fish</span> = &#123;</span><br><span class="line">  <span class="attr">swim</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Dog</span> = &#123;</span><br><span class="line">  <span class="attr">bark</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我可能不是人，才是真的狗</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isDog</span>(<span class="params">obj: Fish | Dog</span>): obj is <span class="title class_">Dog</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;bark&quot;</span> <span class="keyword">in</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">animal</span>: <span class="title class_">Fish</span> | <span class="title class_">Dog</span> = &#123;</span><br><span class="line">  <span class="attr">swim</span>: <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;I am Fish&quot;</span>),</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 进行类型缩减</span></span><br><span class="line"><span class="keyword">if</span> (<span class="title function_">isDog</span>(animal)) &#123;</span><br><span class="line">  animal.<span class="title function_">bark</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  animal.<span class="title function_">swim</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意如果<code>animal</code>的的方法不是<code>swim</code>而是<code>bark</code>，则<code>TS</code>将会进行类型推论，得到这个<code>animal</code>是<code>Dog</code>，便已经排除了<code>Fish</code>类型。此时，在我们的 if 分支里包含了<code>animal</code>是<code>Dog</code>的情况，而在<code>else</code>分支里 <code>animal</code> 就是<code>never</code>类型了。</p><h3 id="三-解析联合类型"><a href="#三-解析联合类型" class="headerlink" title="(三) 解析联合类型"></a>(三) 解析联合类型</h3><p>在上面的例子中，我们分析了一些较为简单的类型。但是实际上，稍微复杂些的类型也是非常常见的。在官方文档中，给了一个例子：我们定义一个用于表示形状的接口<code>Shape</code>，用 <code>kind</code> 属性来表示是圆形<code>circle</code>还是正方形<code>square</code>（字面量联合类型，防止单词拼写错误），圆形仅需要一个半径<code>radius</code>属性，正方形仅需要边长属性 <code>side_length</code>。因此我们使用可选属性，如果是<code>circle</code>，则有<code>radius</code>属性而没有<code>side_length</code>属性，反之同理。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">  <span class="attr">kind</span>: <span class="string">&quot;circle&quot;</span> | <span class="string">&quot;square&quot;</span>;</span><br><span class="line">  radius?: <span class="built_in">number</span>;</span><br><span class="line">  side?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们需要一个求面积的函数，参数为<code>Shape</code>类型。由于参数<code>radius</code>和<code>side</code>都是可选的，因此都可能为空值。按照常理，我们会根据 <code>kind</code> 属性的值来判断是圆形还是方形，从而使用不同的面积公式：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getArea</span>(<span class="params">obj: Shape</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj.<span class="property">kind</span> === <span class="string">&quot;circle&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 圆形面积，会报错，obj.radius可能是空的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">PI</span> * obj.<span class="property">radius</span> ** <span class="number">2</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 方形面积，会报错，obj.side可能是空的</span></span><br><span class="line">    <span class="keyword">return</span> obj.<span class="property">side</span> ** <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是此时你会发现，在严格空值检查下，这段代码会报错。因为<code>radius</code>和<code>side</code>都是可选属性，因此它们都可能为空值。当然，这里我们可以使用<strong>非空断言</strong>，但是也许我们可以用更合理的方式：给<code>circle</code>和<code>square</code>定义不同的接口，毕竟它们是两个完全不同的东西。此时我们的<code>getArea</code>函数就不会再出现上述的问题。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">  <span class="attr">kind</span>: <span class="string">&quot;circle&quot;</span>;</span><br><span class="line">  <span class="attr">radius</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Square</span> &#123;</span><br><span class="line">  <span class="attr">kind</span>: <span class="string">&quot;square&quot;</span>;</span><br><span class="line">  <span class="attr">side</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Shape</span> = <span class="title class_">Circle</span> | <span class="title class_">Square</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getArea</span>(<span class="params">obj: Shape</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj.<span class="property">kind</span> === <span class="string">&quot;circle&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 是Circle，必然有radius属性</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">PI</span> * obj.<span class="property">radius</span> ** <span class="number">2</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 是Square，必然有side属性</span></span><br><span class="line">    <span class="keyword">return</span> obj.<span class="property">side</span> ** <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过合理设计接口，能使问题得到更加优雅的解决方案。</p><h3 id="四-never-类型"><a href="#四-never-类型" class="headerlink" title="(四) never 类型"></a>(四) <code>never</code> 类型</h3><p>当我们进行类型缩减时，一旦所有可能的类型都被缩减完了，如果继续缩减，例如再加一个<code>else</code>分支，我们就会得到一个<strong><code>never</code></strong>类型。<code>TS</code>使用<code>never</code>类型来告诉我们，当前的情况是<code>tan ( Math.PI / 2 )</code>。<strong><code>never</code>类型可以被赋值给任意类型，但是任意其它类型都不能被赋值给<code>never</code>类型(除了<code>never</code>本身之外)</strong>。这个特性常用于穷举校验。</p><h3 id="五-穷举校验"><a href="#五-穷举校验" class="headerlink" title="(五) 穷举校验"></a>(五) 穷举校验</h3><p>我们在进行类型缩减时，有时候无法考虑到所有的情况。因此，可以使用穷举校验，为了避免有类型被遗漏。穷举校验利用了上述<code>never</code>类型的特性，在控制流的最后一个分支里，(如<code>switch</code>语句的<code>default</code>分支，<code>if</code> 语句末尾的<code>else</code>分支)，尝试把 进行类型缩减的参数 赋值给一个 <code>never</code> 类型的变量。由于只有<code>never</code>类型可以被赋值给<code>never</code>类型，一旦有我们考虑不周全，参数有类型遗漏了，那么在最后的分支里，该参数的类型就不会是<code>never</code>，无法被赋值给<code>never</code>类型的变量，<code>TS</code>便会报错来提示我们。而如果我们考虑完了所有的类型情况，则该参数在最后一个分支里便是<code>never</code>类型，可以被赋值给<code>never</code>类型的变量，<code>TS</code>就不会报错。因此，通过穷举检查的方式，我们只需要关注最后一个分支里是否有相应的报错，就能知晓我们是否考虑到了所有的类型情况。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">  <span class="attr">kind</span>: <span class="string">&quot;circle&quot;</span>;</span><br><span class="line">  <span class="attr">radius</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Square</span> &#123;</span><br><span class="line">  <span class="attr">kind</span>: <span class="string">&quot;square&quot;</span>;</span><br><span class="line">  <span class="attr">side</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Triangle</span> &#123;</span><br><span class="line">  <span class="attr">kind</span>: <span class="string">&quot;triangle&quot;</span>;</span><br><span class="line">  <span class="attr">side</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Shape</span> = <span class="title class_">Circle</span> | <span class="title class_">Square</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getArea</span>(<span class="params">obj: Shape</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj.<span class="property">kind</span> === <span class="string">&quot;circle&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 是Circle，必然有radius属性</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">PI</span> * obj.<span class="property">radius</span> ** <span class="number">2</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj.<span class="property">kind</span> === <span class="string">&quot;square&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 是Square，必然有side属性</span></span><br><span class="line">    <span class="keyword">return</span> obj.<span class="property">side</span> ** <span class="number">2</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 在最后一个分支进行穷举校验</span></span><br><span class="line">    <span class="keyword">const</span> <span class="attr">_isExhaustive</span>: <span class="built_in">never</span> = obj;</span><br><span class="line">    <span class="keyword">return</span> _isExhaustive;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、函数进阶"><a href="#五、函数进阶" class="headerlink" title="五、函数进阶"></a>五、函数进阶</h2><p>前面已经介绍了函数类型表达式，下面我们来了解下更多关于函数的知识。</p><h3 id="一-函数签名"><a href="#一-函数签名" class="headerlink" title="(一) 函数签名"></a>(一) 函数签名</h3><ol><li><mark><strong>调用签名</strong></mark></li></ol><p>函数也是一种对象，可以有自己的属性。但是使用函数类型表达式的时候无法同时声明函数的属性。<strong>调用签名描述了一种函数类型，包含了函数的属性、调用函数时应传递的参数以及返回值</strong>。使用调用签名可以很方便地解决函数类型表达式的不足。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明调用签名，调用签名是一种类型，其名字可以任意取</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">CallSignatureFn</span> = &#123;</span><br><span class="line">  <span class="comment">// 函数的属性</span></span><br><span class="line">  <span class="attr">grade</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="comment">// 函数的形参和返回值</span></span><br><span class="line">  (<span class="attr">arg1</span>: <span class="built_in">number</span>, <span class="attr">arg2</span>: <span class="built_in">string</span>): <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">logInfo</span>(<span class="params">fn: CallSignatureFn</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(fn.<span class="property">grade</span> + <span class="string">&quot; returned &quot;</span> + <span class="title function_">fn</span>(<span class="number">6</span>, <span class="string">&quot;A&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>调用签名 vs 函数类型表达式：</strong></p><ul><li>函数类型表达式十分简洁</li><li>调用签名可以声明函数的属性</li><li>调用前面在 参数列表 和 返回值 之间使用冒号 “<code>:</code>“ ，而函数类型表达式使用箭头 “<code>=&gt;</code>“</li></ul><ol><li><mark><strong>构造签名</strong></mark></li></ol><p>函数除了可以被直接调用之外，还可以使用 <strong><code>new</code></strong> 操作符来调用。构造签名描述了函数在使用 <code>new</code> 操作符调用时的传参和返回值。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ConstructSignatureFn</span> = &#123;</span><br><span class="line">  <span class="keyword">new</span> (<span class="attr">_type</span>: <span class="built_in">string</span>, <span class="attr">_num</span>: <span class="built_in">number</span>): <span class="built_in">string</span>[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">ctor: ConstructSignatureFn</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">ctor</span>(<span class="string">&quot;hello&quot;</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><mark><strong>混合签名</strong></mark></li></ol><p>对于有些比较特殊的函数比如<code>Date</code>，直接调用和使用<code>new</code>操作符调用得到的结果是一样的，这种函数类型可以使用混合签名，将调用签名和构造签名写在一个类型对象里。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">CallOrConstruct</span> &#123;</span><br><span class="line">  <span class="keyword">new</span> (<span class="attr">s</span>: <span class="built_in">string</span>): <span class="title class_">Date</span>;</span><br><span class="line">  (n?: <span class="built_in">number</span>): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><mark><strong>重载签名</strong></mark> 和 <mark><strong>实现签名</strong></mark></li></ol><p>将在<strong>函数重载</strong>章节介绍。</p><h3 id="二-泛型函数"><a href="#二-泛型函数" class="headerlink" title="(二) 泛型函数"></a>(二) 泛型函数</h3><ol><li><strong>基础</strong></li></ol><p>此前，我们在声明函数时，会直接给 <strong>形参</strong> 和 <strong>返回值</strong> 添加类型注释，在调用时传入相应类型的值。以这样的形式声明的函数，其传参和返回值的类型都是固定的。那有没有什么方式，能让我们调用函数时传参的类型能灵活多样呢？<strong>泛型函数</strong>正是我们想要的。</p><p><mark><strong>泛型函数</strong></mark>：高度抽象化的类型。在声明函数时将类型抽象化( 可以是多个类型 )：在函数名后面加上尖括号，里面为抽象化的类型名 (例如：<strong><code>&lt;T, K, U, ... &gt;</code>，其中 <code>T, K, U</code>是<mark>类型参数</mark>，各代表一种类型，至于具体是什么类型，在调用函数时由传入的类型决定。</strong>)，在调用函数时再具体化，传入实际的类型，一旦传入类型，所有出现该泛型的地方，都会替换为这个传入的类型。如果没有传入明确的类型，则<code>TS</code>会进行类型推论，自动判断<code>Type</code>的类型。(<code>T，K，U</code>等可以用任何你喜欢的词来替代，不过用这些字母会显得比较简洁。)</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;Type&gt;为泛型，Tpye任意代表一种类型，</span></span><br><span class="line"><span class="comment">// 在调用函数时，需要传入实际的类型，一旦传入类型，所有出现Type的地方都会替换</span></span><br><span class="line"><span class="keyword">function</span> firstElement&lt;<span class="title class_">Type</span>&gt;(<span class="attr">arr</span>: <span class="title class_">Type</span>[]): <span class="title class_">Type</span> | <span class="literal">undefined</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用函数时可以传入任意实际类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型推论判断Type为string</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="title function_">firstElement</span>([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]);</span><br><span class="line"><span class="comment">// 类型推论判断Type为number</span></span><br><span class="line"><span class="keyword">const</span> n = <span class="title function_">firstElement</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="comment">// 类型推论判断Type为undefined类型</span></span><br><span class="line"><span class="keyword">const</span> u = <span class="title function_">firstElement</span>([]);</span><br></pre></td></tr></table></figure><p>泛型的概念将类型进行了抽象化，使得函数可以在调用时传入需要的类型，从而增加了函数的通用性。泛型的名字 Type 可以随意取，注意相同的泛型代表着同一种类型。</p><ol><li><strong>泛型约束</strong></li></ol><p>我们知道，泛型可以定义多个，例如<code>&lt;Type1, Type2, ...&gt;</code>，每个泛型都代表着一种类型，它们可以相同，也可以不同，具体分别是什么类型，都由该函数调用时传入的类型来决定。然而，到目前为止，我们定义的泛型都是和其它类型无关的。很多时候，我们会希望给泛型做一定的约束，让它只能是某些类型之中的一种。这时候，可以使用<strong><code>extends</code></strong>关键字，来实现泛型约束。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 泛型T继承了Person类型，因此T必须有name和age属性</span></span><br><span class="line"><span class="keyword">function</span> getInfo&lt;T <span class="keyword">extends</span> <span class="title class_">Person</span>&gt;(<span class="attr">user</span>: T): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> user.<span class="property">name</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user1 = &#123; <span class="attr">age</span>: <span class="number">16</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> user2 = &#123; <span class="attr">name</span>: <span class="string">&quot;cc&quot;</span>, <span class="attr">age</span>: <span class="number">18</span>, <span class="attr">gender</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="comment">// 报错，user1中没有name属性，不符合类型要求</span></span><br><span class="line"><span class="title function_">getInfo</span>(user1);</span><br><span class="line"><span class="comment">// ok</span></span><br><span class="line"><span class="title function_">getInfo</span>(user2);</span><br></pre></td></tr></table></figure><ol><li><strong>指定类型参数</strong></li></ol><p>在前面的例子中，我们都没有手动传入类型，来指定泛型的实际类型，而是由<code>TS</code>自动进行类型推论得出的。有一说一，<code>TS</code>确实够机智。不过有些时候，由于泛型太抽象，仅仅靠<code>TS</code>的类型推论，可能无法得出正确的结果。这时候，我们可以在调用函数时手动传入类型，来指定类型参数。毕竟<strong>我们永远比<code>TS</code>知道的更多</strong>。下面来看一个官方的示例：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> combine&lt;<span class="title class_">Type</span>&gt;(<span class="attr">arr1</span>: <span class="title class_">Type</span>[], <span class="attr">arr2</span>: <span class="title class_">Type</span>[]): <span class="title class_">Type</span>[] &#123;</span><br><span class="line">  <span class="keyword">return</span> arr1.<span class="title function_">concat</span>(arr2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会报错，TS根据第一个参数数组[1,2,3]，将Type推论为number，</span></span><br><span class="line"><span class="comment">// 于是第二个字符串数组就无法通过类型校验, 因为Type[]此时应为number[]</span></span><br><span class="line"><span class="title function_">combine</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]);</span><br></pre></td></tr></table></figure><p>这种情况下，便需要指定参数类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = combine&lt;<span class="built_in">string</span> | <span class="built_in">number</span>&gt;([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="string">&quot;hello&quot;</span>]);</span><br></pre></td></tr></table></figure><ol><li><strong>三个小细节写好泛型函数</strong></li></ol><ul><li>尽可能少地使用泛型约束，让 TS 进行类型推论</li><li>尽可能少地使用类型参数</li><li>不要将没有重复使用的类型作为类型参数</li></ul><h3 id="三-函数重载"><a href="#三-函数重载" class="headerlink" title="(三) 函数重载"></a>(三) 函数重载</h3><ol><li><strong>函数的可选参数</strong></li></ol><p>在前面的类型缩减章节中，我们知道，函数可以有可选参数，调用函数时，如果没有给可选参数传值，那么该参数的值便是<code>undefined</code>, 这容易引发意想不到的错误。在函数中，我们可以通过<strong>真值校验</strong>来解决，也可以<strong>给参数一个默认值</strong>来解决 (同<code>JS</code>)。但是，如果一个函数的参数中有回调函数，且该<strong>回调函数也有可选参数，则尤其容易引发错误</strong>。偷个懒，继续搬运官方的栗子：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myForEach</span>(<span class="params">arr: <span class="built_in">any</span>[], callback: (arg: <span class="built_in">any</span>, index?: <span class="built_in">number</span>) =&gt; <span class="built_in">void</span></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 如果调用callback时没有传入index参数，则index为undefined</span></span><br><span class="line">    <span class="title function_">callback</span>(arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">myForEach</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function">(<span class="params">a, i</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 即此处的i为undefined，undefined上没有toFixed方法，便会报错</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i.<span class="title function_">toFixed</span>());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可见，使用可选参数不仅处理起来会有些麻烦，而且容易引发错误。因此，函数当有有限个不定数量或不同类型的参数时，更好的方案是<strong>函数重载</strong>。</p><ol><li><mark><strong>函数重载</strong></mark></li></ol><p>规定函数的形参与返回值的是<mark><strong>重载签名</strong></mark>，可以有多个重载签名；</p><p>兼容多个重载签名并进行逻辑处理的是<mark><strong>实现签名</strong></mark>，由于要兼容多套重载签名，因此会出现可选参数；</p><p>我们可以通过编写多套<strong>重载签名</strong>，来规定函数的不同调用方式 (传入不同数量或不同类型的参数以及不同类型的返回值)。然后通过<strong>实现签名</strong>来进行兼容的逻辑处理。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义两套重载签名</span></span><br><span class="line"><span class="comment">// 允许调用函数时只传入name参数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setUserInfo</span>(<span class="params">name: <span class="built_in">string</span></span>): <span class="built_in">boolean</span>;</span><br><span class="line"><span class="comment">// 允许调用函数时传入name, age, gender三个参数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setUserInfo</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span>, gender: <span class="number">1</span> | <span class="number">2</span></span>): <span class="built_in">string</span>;</span><br><span class="line"><span class="comment">// 实现签名，统一处理逻辑</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setUserInfo</span>(<span class="params">name: <span class="built_in">string</span>, age?: <span class="built_in">number</span>, gender?: <span class="number">1</span> | <span class="number">2</span></span>) &#123;</span><br><span class="line">  <span class="comment">// 真值校验，由于两套重载签名规定，调用函数时要么传入三个参数</span></span><br><span class="line">  <span class="comment">// 因此，传入了age，则必定也传入了gender</span></span><br><span class="line">  <span class="keyword">if</span> (age) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`我叫 <span class="subst">$&#123;name&#125;</span>, 今年 <span class="subst">$&#123;age&#125;</span> 岁啦！`</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入一个参数，正确</span></span><br><span class="line"><span class="title function_">setUserInfo</span>(<span class="string">&quot;cc&quot;</span>);</span><br><span class="line"><span class="comment">// 传入三个参数，正确</span></span><br><span class="line"><span class="title function_">setUserInfo</span>(<span class="string">&quot;cc&quot;</span>, <span class="number">18</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 传入两个参数，报错，因为没有定义两个参数的重载签名</span></span><br><span class="line"><span class="title function_">setUserInfo</span>(<span class="string">&quot;cc&quot;</span>, <span class="number">18</span>);</span><br></pre></td></tr></table></figure><p>可以看到，实现签名 和 我们之前普通地使用可选参数的处理很相似，区别也很明显：尽管<code>age</code>和<code>gender</code>都是可选参数，但是通过重载签名，规定了<code>age</code>和<code>gender</code>必须同时传入或同时都不传，即规定了该函数的调用只能传入一个或三个参数。如果不进行函数重载，那么将多出一种只传入<code>name</code>和<code>age</code>这两个参数的情况要进行处理。可见，通过函数重载来规定函数不同的调用方式，可以使逻辑与结构更加清晰优雅。当我们进行函数重载时，一定要<strong>注意让实现签名兼容所有的重载签名(参数和返回值都要兼容处理)</strong>。</p><h3 id="四-在函数中声明-this"><a href="#四-在函数中声明-this" class="headerlink" title="(四) 在函数中声明 this"></a>(四) 在函数中声明 this</h3><p>一般而言，<code>TS</code>会如同<code>JS</code>一样，自动推断 this 的指向。<code>JS</code>中不允许<code>this</code>作为参数，不过<code>TS</code>允许我们在函数中声明<code>this</code>的类型，这种情况尤其在函数的回调参数<code>callback</code>中较为常见。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filterUser个方法，其后是其调用签名</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">  <span class="title function_">filterUsers</span>(<span class="attr">filter</span>: <span class="function">(<span class="params"><span class="variable language_">this</span>: User</span>) =&gt;</span> <span class="built_in">boolean</span>): <span class="title class_">User</span>[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>起初这个官方的示例我看了好几分钟没看懂，后来发现它的<code>filterUsers</code>就是一个函数的调用签名，੯ੁૂ‧̀͡u\。这里声明了<code>this</code>是<code>User</code>类型，如果在该方法执行时，<code>callback</code>中的<code>this</code>不是<code>User</code>类型，<code>TS</code>就会提示我们代码写的有误。在函数中声明<code>this</code>时，需要注意一点是，虽然在构造签名中，<code>callback</code>使用箭头形式，但是<strong>在我们实际调用该方法时，<code>callback</code>不能使用箭头函数，只能用<code>function</code>关键字</strong>。毕竟众所周知，箭头函数没有自己作用域的<code>this</code>，它使用的的<code>this</code>同定义箭头函数时的上下文的 this。</p><h3 id="五-其它的类型"><a href="#五-其它的类型" class="headerlink" title="(五) 其它的类型"></a>(五) 其它的类型</h3><ul><li><p><strong><code>void</code></strong></p><p>函数的返回值设置为<code>void</code>，则返回空值。<strong><code>void</code>不等同于<code>undefined</code></strong>。</p><p>返回值为<code>void</code>类型的函数，并不一定不能写<code>return</code> 语句。<strong>如果是通过函数表达式、函数签名等定义的函数类型，该类型的实例函数体中可以有<code>return</code>语句，并且后面可以接任意类型的值，只不过它的返回值会被忽略</strong>。如果我们把这样的函数调用结果赋值给某个变量，则该变量的类型依然是<code>void</code>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> voidFunc = <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">f1</span>: voidFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 可以return任意类型的值，但是会被忽略</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// v1 的类型依然是void</span></span><br><span class="line"><span class="keyword">const</span> v1 = <span class="title function_">f1</span>();</span><br></pre></td></tr></table></figure><p>但是，<strong>如果是通过字面量声明函数的返回值为<code>void</code>，则函数体内不能有<code>return</code>语句</strong>。虽然官方文档里这么说，下面的栗子也摘自官方文档，但是我的<code>vs code</code>编辑器里这样写并没有报错 ？。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f2</span>(<span class="params"></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="comment">// @ts-expect-error</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> f3 = <span class="keyword">function</span> (<span class="params"></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="comment">// @ts-expect-error</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>object</code></strong></p><p>是小写的<code>object</code>，而不是大写的<code>Object</code>。这两者意义不同。</p></li><li><p><strong><code>unknown</code></strong></p></li><li><p><strong><code>never</code></strong></p><p>有的函数永远没有返回值，例如在函数体内 <code>return</code> 之前抛出错误。<code>never</code>类型也常用来做穷举校验。</p></li><li><p><strong><code>Funtion</code></strong></p><p>这些类型基本都在[# <code>Typescript</code>系列：基础篇(一)]<a href="https://juejin.cn/post/7069940384515751973">2022年了，了解一下 typescript系列：基础篇(一)？ - 掘金</a>介绍过了，此处不再赘述。</p></li></ul><h3 id="六-剩余参数"><a href="#六-剩余参数" class="headerlink" title="(六) 剩余参数"></a>(六) 剩余参数</h3><ul><li>我才发现，原来<strong><code>parameters</code>表示形参</strong>，<strong><code>arguments</code>表示实参</strong>。</li><li><strong>剩余形参</strong></li></ul><p>剩余形参的使用基本同<code>JS</code>一致，偷个懒直接拿官方栗子：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 倍乘函数，第一个参数为倍数，会返回后续所有参数各自乘以倍数而形成的数组</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">multiply</span>(<span class="params">n: <span class="built_in">number</span>, ...m: <span class="built_in">number</span>[]</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> m.<span class="title function_">map</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> n * x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a 的值</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="title function_">multiply</span>(<span class="number">10</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>剩余实参</strong></li></ul><p>剩余实参常用于函数调用时对传递的参数 (数组、对象等) 进行展开，然而这里容易踩坑。以数组为例：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">arr1.<span class="title function_">push</span>(...arr2);</span><br></pre></td></tr></table></figure><p>数组的<code>push</code>可以接收无限制个参数，因此可以直接展开参数<code>arr2</code>。但是有的方法只能接收指定数量的参数，而在一般情况下，<code>TS</code>认为数组的是可变的。如果直接对这类方法的进行数组参数的展开，会引起报错，因为<code>TS</code>会认为数组里的成员数量可能是<code>0</code>个或者多个，不符合该方法只接受指定数量的参数的要求。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 虽然数组现在只有两个成员，但是它的类型被推断为 number[]，</span></span><br><span class="line"><span class="comment">// 即args数组可能会发生变化，可能有0个或多个参数</span></span><br><span class="line"><span class="comment">// 而Math.atan2方法只接收两个参数，因此会报错</span></span><br><span class="line"><span class="keyword">const</span> args = [<span class="number">8</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> angle = <span class="title class_">Math</span>.<span class="title function_">atan2</span>(...args);s);</span><br></pre></td></tr></table></figure><p>解决的办法也很简单，使用 <strong><code>as const</code></strong>将数组的类型断言为不可变类型。此时的数组便被推论为元组类型。有关元组类型的内容，会在下一篇 <strong>对象类型篇</strong>中介绍。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此时args长度不可变，被推论为元组类型</span></span><br><span class="line"><span class="keyword">const</span> args = [<span class="number">8</span>, <span class="number">5</span>] <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line"><span class="comment">// ok</span></span><br><span class="line"><span class="keyword">const</span> angle = <span class="title class_">Math</span>.<span class="title function_">atan2</span>(...args);</span><br></pre></td></tr></table></figure><ul><li><strong>形参结构</strong></li></ul><p>没啥好说的，直接上官方示例。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">NumberABC</span> = &#123; <span class="attr">a</span>: <span class="built_in">number</span>; <span class="attr">b</span>: <span class="built_in">number</span>; <span class="attr">c</span>: <span class="built_in">number</span> &#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">&#123; a, b, c &#125;: NumberABC</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a + b + c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TS系列基础篇(一) TS类型指南</title>
      <link href="/onlyy-blog/articals/21eaede9a8d8/"/>
      <url>/onlyy-blog/articals/21eaede9a8d8/</url>
      
        <content type="html"><![CDATA[<h1 id="TS-系列基础篇-一-TS-类型指南"><a href="#TS-系列基础篇-一-TS-类型指南" class="headerlink" title="TS 系列基础篇(一) TS 类型指南"></a>TS 系列基础篇(一) TS 类型指南</h1><p>这段时间以来，TS 的发展可谓是如日中天，本想偷个懒去看看别人写的分享贴来学习，找了近十篇之后，发现要么是比较浅显，要么有些偏差，没有找到很满意的。于是决定去看<a href="https://www.typescriptlang.org/docs/handbook/declaration-files/consumption.html#consuming">官方文档</a>。学习了一段时间后，准备写一个系列，从基础类型，对象，函数，模块等 TS 知识，到在<code>vue</code>、<code>react</code>中的应用，供有需要的同学们参考。其中，我套用了不少官方文档的示例，觉得我的学习经验不好或不正确的朋友，欢迎批评指正。</p><p><code>TS</code>是<code>JS</code>的超集。在学 TS 之前，最好有一定的<code>JS</code>基础。本篇只介绍<code>typescript</code>的安装和各种基础类型。需要了解其它内容的同学可以看其它篇章或查阅官方文档。</p><p>[toc]</p><h2 id="一-、安装与编译"><a href="#一-、安装与编译" class="headerlink" title="(一)、安装与编译"></a>(一)、安装与编译</h2><p>想要使用<code>TS</code>，得先会安装。Typescript 需要<code>node</code>环境，确保你已经安装了<code>node</code>。如果还没有安装<code>node</code>，可以去<a href="[`Node.js`](https://nodejs.org/zh-cn/"><code>Node.js</code>官网</a>下载，傻瓜式安装。</p><p>打开项目目录进行初始化：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init <span class="literal">-y</span></span><br></pre></td></tr></table></figure><p>官方推荐了<code>npm</code>，<code>yarn</code>，<code>pnpm</code>三种工具，任选其一即可（<code>npm</code>工具为<code>node</code>自带的包管理工具，可自由使用；<code>yarn</code>或<code>pnpm</code>工具需要提前安装）。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># with npm</span></span><br><span class="line">npm install typescript <span class="literal">--save-dev</span></span><br><span class="line"><span class="comment"># with yarn</span></span><br><span class="line">yarn add typescript <span class="literal">--dev</span></span><br><span class="line"><span class="comment"># with pnpm</span></span><br><span class="line">pnpm add typescript <span class="literal">-D</span></span><br></pre></td></tr></table></figure><p>在安装 ts 时，编译工具<code>tsc</code>也会被自动安装。待安装完成，在项目根目录下新建一个<code>app.ts</code>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.ts</span></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;app&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">charAt</span>(<span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>即可通过以下任一方式运行<code>tsc</code>，编译成功后会在和<code>app.ts</code>同级目录下多出一个<code>app.js</code>文件。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前目录下的app.ts文件编译为app.js</span></span><br><span class="line"><span class="comment"># npm</span></span><br><span class="line">npx tsc app.ts</span><br><span class="line"><span class="comment"># yarn</span></span><br><span class="line">yarn tsc app.ts</span><br><span class="line"><span class="comment"># pnpm</span></span><br><span class="line">pnpm tsc app.ts</span><br></pre></td></tr></table></figure><p><code>app.js</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;app&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">charAt</span>(<span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>这个<code>js</code>文件和<code>app.ts</code>看起来没有差别，这是因为我们没有在<code>app.ts</code>里没有进行类型约束。与类型的相关内容会在后面谈到。现在我们来让<code>app.ts</code>出一点“错误”，将<code>str</code>换成数组，编辑器会把错误代码用红色波浪线标出，如果此时在命令行运行<code>yarn tsc app.ts</code>，控制台便会报错。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.ts</span></span><br><span class="line"><span class="keyword">const</span> str = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;p&quot;</span>, <span class="string">&quot;p&quot;</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">charAt</span>(<span class="number">0</span>)); <span class="comment">// charAt会被</span></span><br></pre></td></tr></table></figure><p>尽管如此，报错了的代码依旧会被编译成<code>js</code>文件。我们可以在<code>tsc</code>命令后加上编译的相关配置指令来进行控制。比如，加上<strong><code>--noEmitOnError</code></strong>之后，一旦报错便不会生成<code>js</code>文件。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc <span class="literal">--noEmitOnError</span> hello.ts</span><br></pre></td></tr></table></figure><p>但是 ts 的编译配置项非常多，如果每次都通过在命令行加入指令来进行相关控制，无疑非常繁琐。因此我们可以在<strong><code>tsconfig.json</code></strong>里编写相关配置，这样我们执行<code>tsc</code>命令时，编译器会默认从当前目录逐步向上层目录查找并读取<code>tsconfig.json</code>里的配置项。</p><h2 id="二-、配置文件：tsconfig-json"><a href="#二-、配置文件：tsconfig-json" class="headerlink" title="(二)、配置文件：tsconfig.json"></a>(二)、配置文件：<code>tsconfig.json</code></h2><p>在运行<code>tsc</code>命令时，我们可以在后面添加指令来指定相关配置。但是我们会更倾向于在<code>tsconfig.json</code>里对相关指令进行配置，以减少重复、繁琐的操作。在<code>Vue</code>、<code>React</code>等框架搭建的项目里，一般都已生成初步配置好了的<code>tsconfig.json</code>文件。本篇只进行解基础内容的分享，有关配置的章节将在后续推出。</p><h2 id="三-、类型基础"><a href="#三-、类型基础" class="headerlink" title="(三)、类型基础"></a>(三)、类型基础</h2><p>这里介绍部分 TS 基础类型，关于类型的进阶将在后续篇章中单独介绍。注意不要将基础类型和 js 基本数据类型混为一谈。基础类型可以理解为 ts 内置的各种类型，而非我们人为定义出的类型。TS 有多种基础类型，这些类型可以用来进行组合，从而得到我们需要的人为定义的类型。TS 在声明变量时，在变量名后加上冒号<mark>: </mark>和类型名来进行变量的类型注释。如果不添加类型注释，则 TS 会根据变量的初始值进行<mark><strong>类型推论</strong></mark>，自动推断出该变量属于什么类型。如果也没有初始值，则会被推断为<strong>any</strong>类型。</p><h3 id="1-原有的基本数据类型"><a href="#1-原有的基本数据类型" class="headerlink" title="1. 原有的基本数据类型"></a>1. 原有的基本数据类型</h3><ul><li><strong><code>string</code></strong>：字符串类型，注意<code>String</code>在<code>js</code>里已经有特殊意义了，而小写的<code>string</code>才是<code>Typescript</code>用来表示字符串的类型名称，即在注释变量类型为字符串时，使用小写的<code>string</code>，而不是大写的<code>String</code>，注意不要混淆了两者；<code>number</code>和<code>boolean</code>同理。</li><li><strong><code>number</code></strong>：数字类型；</li><li><p><strong><code>boolean</code></strong>：布尔类型；</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明变量类型，可以不赋初值，后续给num赋的值必须是number类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">num</span>: <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">str</span>: <span class="built_in">string</span> = <span class="string">&quot;typescript&quot;</span>;</span><br><span class="line"><span class="comment">// 类型推断：TS会自动推断出bool的类型为boolean</span></span><br><span class="line"><span class="keyword">let</span> bool = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-Array"><a href="#2-Array" class="headerlink" title="2. Array"></a>2. <code>Array</code></h3><p><code>Array</code>是数组类型，属于对象类型的一种。由于数组内会有数组成员，因此，在声明数组变量的时候，还要给数组成员添加类型注释，一般有两种常见方式：<strong><code>Type[]</code></strong>、<strong><code>Array&lt;Type&gt;</code></strong>。后者涉及<strong>泛型</strong>概念，将在后续介绍。其中，<code>Type</code>指代数组成员的类型，可以是基础类型，也可以是人为定义的类型 (关于数组的变形，元组类型，将在对象类型的章节介绍)。例如，要声明一个存放字符串的数组变量：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">arr1</span>: <span class="built_in">string</span>[];</span><br><span class="line"><span class="comment">// 也可以像下面</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr2</span>: <span class="title class_">Array</span>&lt;<span class="built_in">string</span>&gt;;</span><br></pre></td></tr></table></figure><h3 id="3-object"><a href="#3-object" class="headerlink" title="3. object"></a>3. <code>object</code></h3><p>对象类型是我们平时更为常见的类型。在本篇只给出一些简单定义，后续篇章中会进行单独介绍。一个对象类型的变量可以通过键值对来存储多个数据。定义一个对象类型，可以简单地列出它的各个属性及属性的类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个包含name, age, gender属性的变量obj</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>: &#123; <span class="attr">name</span>: <span class="built_in">string</span>; <span class="attr">age</span>: <span class="built_in">number</span>; <span class="attr">gender</span>: <span class="string">&quot;gg&quot;</span> | <span class="string">&quot;mm&quot;</span> &#125;;</span><br></pre></td></tr></table></figure><p>之后给 obj 赋值时<strong>必须有且只能有</strong><code>name</code>，<code>age</code>，<code>gender</code>三个属性，且属性值应为相应的类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 会报错,多了一个beauty属性,因此类型不合</span></span><br><span class="line">obj = &#123; <span class="attr">name</span>: <span class="string">&quot;yy&quot;</span>, <span class="attr">age</span>: <span class="number">22</span>, <span class="attr">gender</span>: <span class="string">&quot;mm&quot;</span>, <span class="attr">beauty</span>: <span class="number">100</span> &#125;;</span><br><span class="line"><span class="comment">// 报错，缺少了gender属性</span></span><br><span class="line">obj = &#123; <span class="attr">name</span>: <span class="string">&quot;yy&quot;</span>, <span class="attr">age</span>: <span class="number">22</span> &#125;;</span><br><span class="line"><span class="comment">// 正确赋值</span></span><br><span class="line">obj = &#123; <span class="attr">name</span>: <span class="string">&quot;yy&quot;</span>, <span class="attr">age</span>: <span class="number">22</span>, <span class="attr">gender</span>: <span class="string">&quot;mm&quot;</span> &#125;;</span><br></pre></td></tr></table></figure><p>如果想要让某个属性变为可选项，则可以在定义对象类型时在属性名后使用问号”?”：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将gender定义为可选项</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>: &#123; <span class="attr">name</span>: <span class="built_in">string</span>; <span class="attr">age</span>: <span class="built_in">number</span>; gender?: <span class="string">&quot;gg&quot;</span> | <span class="string">&quot;mm&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line">obj = &#123; <span class="attr">name</span>: <span class="string">&quot;yy&quot;</span>, <span class="attr">age</span>: <span class="number">22</span>, <span class="attr">gender</span>: <span class="string">&quot;mm&quot;</span> &#125;;</span><br><span class="line"><span class="comment">// 也正确，因为gender是可选的</span></span><br><span class="line">obj = &#123; <span class="attr">name</span>: <span class="string">&quot;yy&quot;</span>, <span class="attr">age</span>: <span class="number">22</span> &#125;;</span><br></pre></td></tr></table></figure><p>在某个属性被定义为可选项之后，一旦给该对象赋值时，没有传入该属性，它的取值便会成为<code>undefined</code> (注意<strong>这与一开始边定义<code>gender: &#39;gg&#39; | &#39;mm&#39; | undefined</code>不同</strong>。)</p><p>使用可选项有些地方需要注意，如<strong>在函数的形参中</strong>存在可选项，此时由于<code>gender</code>属性可能为<code>undefined</code>，我们在使用时需要在该属性后面加上英文感叹号”<code>!</code>“进行<strong>非空断言</strong>，明确它不是<code>undefined</code>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">obj: &#123; name: <span class="built_in">string</span>; age: <span class="built_in">number</span>; gender?: <span class="string">&quot;gg&quot;</span> | <span class="string">&quot;mm&quot;</span> &#125;</span>) &#123;</span><br><span class="line">  <span class="comment">// 使用!进行非空断言</span></span><br><span class="line">  obj.<span class="property">gender</span>!.<span class="title function_">replace</span>(<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-Union-Types-联合类型"><a href="#4-Union-Types-联合类型" class="headerlink" title="4. Union Types 联合类型"></a>4. <code>Union Types</code> 联合类型</h3><p><code>Union Types</code>是指使用 “<code>|</code>“符号来把多个类型联合成一个类型，一个联合类型的变量，其值可以是联合类型的任何一个子类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义a为联合类型，则a可以是string类型也可以是number类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"><span class="comment">// a可以是string</span></span><br><span class="line">a = <span class="string">&quot;union types&quot;</span>;</span><br><span class="line"><span class="comment">// a也可以是number</span></span><br><span class="line">a = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>在<strong>函数的形参中</strong>使用联合类型时有一些注意事项，如在上面的例子中，<code>a</code> 的类型是<code>string | number</code>，此时<code>a</code>无法调用字符串方法，因为<code>a</code>有可能是一个<code>number</code>；同理，也不能直接调用数字类型的方法。当然，也不能直接赋值给<code>string</code>类型的变量或者<code>number</code>类型的变量。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"><span class="comment">// a可以是string</span></span><br><span class="line">a = <span class="string">&quot;union types&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">b</span>: <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>: <span class="built_in">number</span>;</span><br><span class="line"><span class="comment">// 当开启了严格空值检查时，以下两次赋值都不合法</span></span><br><span class="line">b = a;</span><br><span class="line">c = a;</span><br></pre></td></tr></table></figure><p>当然，如果每个子类型都具有共同的方法，则可以调用该共同的方法。例如：数组和字符串都具有<code>slice</code>方法，则联合类型<code>string | number[]</code> 的变量可以调用<code>slice</code>方法。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params">obj: <span class="built_in">string</span> | <span class="built_in">number</span>[]</span>) &#123;</span><br><span class="line">  <span class="comment">// 可以直接调用slice方法</span></span><br><span class="line">  <span class="keyword">const</span> a = obj.<span class="title function_">slice</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-Type-Alias-类型别名"><a href="#5-Type-Alias-类型别名" class="headerlink" title="5. Type Alias 类型别名"></a>5. <code>Type Alias</code> 类型别名</h3><p>使用<strong><code>type</code></strong>关键字给你的类型起一个别名，以后就可以使用别名来指代这个类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Point</span> = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">ID</span> = <span class="built_in">number</span> | <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类型别名Point</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">p</span>: <span class="title class_">Point</span> = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">123</span>,</span><br><span class="line">  <span class="attr">y</span>: <span class="number">222</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="6-Interfaces"><a href="#6-Interfaces" class="headerlink" title="6. Interfaces"></a>6. Interfaces</h3><p>通过关键字<strong><code>interface</code></strong>，来定义一个接口，实际是一个对象类型，用于规定一个对象的形状。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printCoord</span>(<span class="params">pt: Point</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;The coordinate&#x27;s x value is &quot;</span> + pt.<span class="property">x</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;The coordinate&#x27;s y value is &quot;</span> + pt.<span class="property">y</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">printCoord</span>(&#123; <span class="attr">x</span>: <span class="number">100</span>, <span class="attr">y</span>: <span class="number">100</span> &#125;);</span><br></pre></td></tr></table></figure><p>简单说说<strong><code>interface</code>与类型别名的区别</strong>：</p><ul><li><code>interface</code> 可以通过 <strong><code>extends</code></strong>关键字来<strong>继承</strong>另一个<code>interface</code>，而<code>type</code>通过 <code>&amp;</code>符号来连接不同的对象属性；</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承Animal接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">skull</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承了Animal接口的属性name</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">dog</span>: <span class="title class_">Dog</span> = &#123;</span><br><span class="line">  <span class="attr">skull</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;wangcai&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型别名通过&amp;符号来拓展属性</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Dog2</span> = <span class="title class_">Animal</span> &amp; &#123;</span><br><span class="line">  <span class="attr">skull</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>interface</code>可以进行拓展，<code>Type</code>不可以</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">skull</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拓展interface的内容</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时Dog类型包含name,skull,age三个</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">dog</span>: <span class="title class_">Dog</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;wangcai&quot;</span>,</span><br><span class="line">  <span class="attr">skull</span>: <span class="number">12</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个Dog2类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Dog2</span> = &#123;</span><br><span class="line">  <span class="attr">skull</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会报错，Dog2重复了</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Dog2</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>interface</code>定义对象的形状，<code>type</code>不仅可以用于对象，也可以用于其它类型</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">TypeA</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TypeB</span> = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TypeC</span> = <span class="title class_">TypeA</span> | <span class="title class_">TypeB</span>;</span><br></pre></td></tr></table></figure><h3 id="7-Intersection-Types-交叉类型"><a href="#7-Intersection-Types-交叉类型" class="headerlink" title="7. Intersection Types 交叉类型"></a>7. <code>Intersection Types</code> 交叉类型</h3><p>用 <code>&amp;</code> 符号来连接多个类型，属于交叉类型 <code>A &amp; B</code> 的变量，既满足<code>A</code>的约束，又满足<code>B</code>的约束。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">TypeA</span> = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TypeB</span> = <span class="title class_">Array</span>&lt;<span class="built_in">boolean</span>&gt; | <span class="built_in">number</span>;</span><br><span class="line"><span class="comment">// TypeC既满足TypeA又满足TypeB，因此TypeC是number</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TypeC</span> = <span class="title class_">TypeA</span> &amp; <span class="title class_">TypeB</span>;</span><br><span class="line"><span class="comment">// a是number类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="title class_">TypeC</span> = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// b是TypeA类型，它的值是个string，因此不能赋值给a</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">b</span>: <span class="title class_">TypeA</span> = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">a = b; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>也可以用来拓展对象类型的属性：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> B = &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">gender</span>: <span class="string">&quot;男&quot;</span> | <span class="string">&quot;女&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 类型C是既满足A又满足B，即C既包含A的所有属性，又包含B的所有属性，</span></span><br><span class="line"><span class="comment">// 从而实现属性拓展</span></span><br><span class="line"><span class="keyword">type</span> C = A &amp; B;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>: C = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;cc&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">gender</span>: <span class="string">&quot;男&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意 <strong><code>&amp;</code> 和 | 的区别</strong>：”<code>&amp;</code>“可以合并多个对象类型的属性，使得到的新的对象类型包含其它所有类型的全部属性；”<code>&amp;</code>“可以获得多个类型之间的公共子类型；”<code>|</code>“可以联合多个类型，得到的新类型的值，只需满足其中一种子类型即可。</p><h3 id="8-Literal-Types-字面量类型"><a href="#8-Literal-Types-字面量类型" class="headerlink" title="8. Literal Types 字面量类型"></a>8. <code>Literal Types</code> 字面量类型</h3><p>通过字面量来定义类型，字面量的值可以是任意一个类型的值，可以将多个不同类型的字面量进行组合，此时得到的变量上的方法无法进行合法调用，因为变量可能为其它不含该方法的类型（与联合类型同理）。因此需要进行类型精简或类型断言。注意在变量声明时进行类型注释了的才能被字面量类型约束，如果没有类型注释，则会按照类型推论的结果来判定类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义gender只能取值为 &#x27;男&#x27; 或 &#x27;女&#x27; 中的一种</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">gender</span>: <span class="string">&quot;男&quot;</span> | <span class="string">&quot;女&quot;</span> = <span class="string">&quot;男&quot;</span>;</span><br><span class="line"><span class="comment">// gender2经类型推论string类型</span></span><br><span class="line"><span class="keyword">let</span> gender2 = <span class="string">&quot;男&quot;</span>;</span><br><span class="line"><span class="comment">// 多种类型字面量的组合</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="string">&quot;未知数&quot;</span> | <span class="number">1</span> | &#123; <span class="attr">y</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="comment">// 严格类型检查时不能合法调用</span></span><br><span class="line">x.<span class="title function_">split</span>(<span class="string">&quot;知&quot;</span>) &lt;</span><br><span class="line">  <span class="comment">// 进行类型断言后可合法</span></span><br><span class="line">  <span class="built_in">string</span> &gt;</span><br><span class="line">  x.<span class="title function_">split</span>(<span class="string">&quot;知&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="9-null-和-undefined-与-非空断言"><a href="#9-null-和-undefined-与-非空断言" class="headerlink" title="9. null 和 undefined 与 非空断言"></a>9. <code>null</code> 和 <code>undefined</code> 与 非空断言</h3><p>两个空值类型，和在<code>js</code>里的区别一致。开启/关闭严格空值检查会影响到空值类型的行为。当我们知道一个变量不会为空时，可以在该变量后使用英文感叹号 “<code>!</code>“ ，进行临时<strong>非空断言 （<code>Non-null Assertion</code>）</strong>。这点在函数中尤为重要。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyType</span> = <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">value</span>: <span class="title class_">MyType</span> = <span class="string">&quot;I love China&quot;</span>;</span><br><span class="line"><span class="comment">// 对value进行非空断言</span></span><br><span class="line">value!.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="10-Enums-枚举类型"><a href="#10-Enums-枚举类型" class="headerlink" title="10. Enums 枚举类型"></a>10. <code>Enums</code> 枚举类型</h3><p>枚举类型是一组被有意义地命名了的常量的集合。与其它类型本质上不同的是，其它的类型都只是类型，而枚举类型却是可以使用的值。<strong>通过<code>enum</code>关键字声明某个变量为枚举类型的值</strong>，使用枚举类型，可以让我们不去关注变量实际的值，而使用更有意义的名字来代表实际的值。例如，在表示性别时，我们可以简单地用数字 1 和 2 来表示 男 和 女。那么在实际使用中，我们需要知道到底是 1 代表男还是 1 代表女。当数据从前端传到后端，后端的小伙伴又需要去了解哪个数字代表哪个性别。这对我们来说就不太友好。所以，我们可以使用枚举类型来定义一组表示性别的常量，之后使用时，只需取常量的名字即可。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Gender</span> &#123;</span><br><span class="line">  <span class="attr">male</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">female</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">secret</span>: <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举类型包括数字型枚举、字符串型枚举、异构枚举等等。此处只简要了解一下枚举类型的的存在，后续会写一篇枚举类型的深入。</p><h3 id="11-any"><a href="#11-any" class="headerlink" title="11. any"></a>11. <code>any</code></h3><p><code>any</code>可以指代任何类型，可以被赋值给任意类型的变量。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给变量anyscript一个any类型，其值为数字123</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">anyscript</span>: <span class="built_in">any</span> = <span class="number">123</span>;</span><br><span class="line"><span class="comment">// 给变量typescript一个string类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">typescript</span>: <span class="built_in">string</span> = <span class="string">&quot;typescript&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值操作后，typescript变成了123，其类型发生了改变</span></span><br><span class="line">typescript = anyscript;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 而编译器会认为typescript变量为string类型，且允许我们调用string类型的方法</span></span><br><span class="line">typescript.<span class="title function_">split</span>(<span class="string">&quot;c&quot;</span>);</span><br><span class="line"><span class="comment">// 而事实上此时变量typescript的值已经变为了数字123，调用string的方法就会</span></span><br></pre></td></tr></table></figure><p>这个看起来很便捷的<code>any</code>类型，在这种时候就会引发问题，造成类型污染。因此，我们应该避免使用<code>any</code>，以免走进<code>Anyscript</code>的误区。</p><h3 id="12-unknown与类型断言"><a href="#12-unknown与类型断言" class="headerlink" title="12. unknown与类型断言"></a>12. <code>unknown</code>与类型断言</h3><p><code>unknown</code>用来表示未知类型，和<code>any</code>相似，它的值可以是任何类型。不同的是，如果一个变量是<code>unknown</code>类型，那么它在被明确为某个确切的类型之前，不能调用任何方法，也不能被赋值给其它变量。你可以使用<mark><strong>类型断言</strong></mark>来<strong>临时</strong>人为明确一个 unknown 变量的确切类型。毕竟<strong>你永远比<code>Typescript</code>知道的多</strong>！类型断言一般有两种方式：使用 <code>a as Type</code> 或者 在需要进行类型断言的变量前使用尖括号：<code>&lt;Type&gt;a</code>，来明确变量<code>a</code>为<code>Type</code>类型。注意类型断言是临时的，因此它不会改变原来<code>unknown</code>变量的类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个unknown变量a，一个字符串变量b</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="built_in">unknown</span> = <span class="string">&quot;I am unknown type&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">b</span>: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里会报错，因为a为unknown类型，而且并没有明确它的具体类型，</span></span><br><span class="line"><span class="comment">// 不能被赋值给字符串变量b，哪怕a本身实际的值为字符串</span></span><br><span class="line">b = a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类型断言来明确a的具体类型为字符串string，</span></span><br><span class="line"><span class="comment">// 之后便可以赋值给字符串b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用as进行类型断言，可以用括号将其整体包裹起来，以进行对断言之后的变量a的操作</span></span><br><span class="line">b = a <span class="keyword">as</span> <span class="built_in">string</span>;</span><br><span class="line">b = (a <span class="keyword">as</span> <span class="built_in">string</span>) + <span class="string">&quot;!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以使用&lt;Type&gt;a的形式进行类型断言</span></span><br><span class="line">b = &lt;<span class="built_in">string</span>&gt;a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 之后 a 的类型依然是unknown</span></span><br></pre></td></tr></table></figure><p>也许你会觉得使用<code>unknown</code>类型有些繁琐。但相比起<code>any</code>类型容易引发的错误，<code>unknown</code>类型的使用足够安全。因此，如果有需要使用不明确的类型时，应该首选<code>unknown</code>而不是<code>any</code>。毕竟谁也不愿意，一杯茶，一个圈，一个<code>BUG</code>改一天(甚至还在排查错误原因)。</p><h3 id="13-never-和-void"><a href="#13-never-和-void" class="headerlink" title="13. never 和 void"></a>13. <code>never</code> 和 <code>void</code></h3><p><code>void</code>用于表示函数返回空值；<code>never</code>用于表示不该使用的值或者函数不应该有返回值，在我们平常的工作中<code>never</code>的应用场景较少。</p><h3 id="14-不常用的类型"><a href="#14-不常用的类型" class="headerlink" title="14.不常用的类型"></a>14.不常用的类型</h3><p><strong><code>Bigint</code>和<code>Symbol</code></strong>是<code>ES6</code>之后加入的基本数据类型，目前在日常工作中的使用并不多见。<code>TS</code>中的这两种类型和<code>JS</code>中一致。</p><ul><li><p><strong><code>bigint</code></strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用BigInt函数来创建一个bigint类型的变量</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">oneHundred</span>: <span class="built_in">bigint</span> = <span class="title class_">BigInt</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用字面量语法 数字 + n 来创建bigint类型的变量</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">anotherHundred</span>: <span class="built_in">bigint</span> = <span class="number">100n</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>Symbol</code></strong></p><p><code>Symbol</code>是<code>ES6</code>之后新增的一种基本数据类型，每个<code>Symbol</code>类型的变量，其值都是唯一的，即使传入相同的参数，返回的结果也永远不会相等。一般使用<code>Symbol</code>函数来创建。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Symbol函数创建Symbol类型的变量/常量</span></span><br><span class="line"><span class="keyword">const</span> first1 = <span class="title class_">Symbol</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> first2 = <span class="title class_">Symbol</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"></span><br><span class="line">first1 === first2; <span class="comment">// 永远是false</span></span><br></pre></td></tr></table></figure></li></ul><p>类型基础的内容就介绍到这里啦，下一篇将着重介绍在函数中使用各种类型时需要注意的问题，例如如何进行类型精确。如果文章描述有不妥之处，恳请不吝指出，我们下一篇再见！</p>]]></content>
      
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

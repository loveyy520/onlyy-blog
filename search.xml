<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>TS系列基础篇(一) TS类型指南</title>
      <link href="/onlyy-blog/2022/03/01/Typescript%E7%B3%BB%E5%88%97-%E5%9F%BA%E7%A1%80%E7%AF%87-%E4%B8%80-TS%E7%B1%BB%E5%9E%8B%E6%8C%87%E5%8D%97/"/>
      <url>/onlyy-blog/2022/03/01/Typescript%E7%B3%BB%E5%88%97-%E5%9F%BA%E7%A1%80%E7%AF%87-%E4%B8%80-TS%E7%B1%BB%E5%9E%8B%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<p>这段时间以来，TS 的发展可谓是如日中天，本想偷个懒去看看别人写的分享贴来学习，找了近十篇之后，发现要么是比较浅显，要么有些偏差，没有找到很满意的。于是决定去看<a href="https://www.typescriptlang.org/docs/handbook/declaration-files/consumption.html#consuming">官方文档</a>。学习了一段时间后，准备写一个系列，从基础类型，对象，函数，模块等 TS 知识，到在<code>vue</code>、<code>react</code>中的应用，供有需要的同学们参考。其中，我套用了不少官方文档的示例，觉得我的学习经验不好或不正确的朋友，欢迎批评指正。</p><p><code>TS</code>是<code>JS</code>的超集。在学 TS 之前，最好有一定的<code>JS</code>基础。本篇只介绍<code>typescript</code>的安装和各种基础类型。需要了解其它内容的同学可以看其它篇章或查阅官方文档。</p><p>[toc]</p><h2 id="一-、安装与编译"><a href="#一-、安装与编译" class="headerlink" title="(一)、安装与编译"></a>(一)、安装与编译</h2><p>想要使用<code>TS</code>，得先会安装。Typescript 需要<code>node</code>环境，确保你已经安装了<code>node</code>。如果还没有安装<code>node</code>，可以去<a href="[`Node.js`](https://nodejs.org/zh-cn/"><code>Node.js</code>官网</a>下载，傻瓜式安装。</p><p>打开项目目录进行初始化：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init <span class="literal">-y</span></span><br></pre></td></tr></table></figure><p>官方推荐了<code>npm</code>，<code>yarn</code>，<code>pnpm</code>三种工具，任选其一即可（<code>npm</code>工具为<code>node</code>自带的包管理工具，可自由使用；<code>yarn</code>或<code>pnpm</code>工具需要提前安装）。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># with npm</span></span><br><span class="line">npm install typescript <span class="literal">--save-dev</span></span><br><span class="line"><span class="comment"># with yarn</span></span><br><span class="line">yarn add typescript <span class="literal">--dev</span></span><br><span class="line"><span class="comment"># with pnpm</span></span><br><span class="line">pnpm add typescript <span class="literal">-D</span></span><br></pre></td></tr></table></figure><p>在安装 ts 时，编译工具<code>tsc</code>也会被自动安装。待安装完成，在项目根目录下新建一个<code>app.ts</code>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.ts</span></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;app&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">charAt</span>(<span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>即可通过以下任一方式运行<code>tsc</code>，编译成功后会在和<code>app.ts</code>同级目录下多出一个<code>app.js</code>文件。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前目录下的app.ts文件编译为app.js</span></span><br><span class="line"><span class="comment"># npm</span></span><br><span class="line">npx tsc app.ts</span><br><span class="line"><span class="comment"># yarn</span></span><br><span class="line">yarn tsc app.ts</span><br><span class="line"><span class="comment"># pnpm</span></span><br><span class="line">pnpm tsc app.ts</span><br></pre></td></tr></table></figure><p><code>app.js</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;app&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">charAt</span>(<span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>这个<code>js</code>文件和<code>app.ts</code>看起来没有差别，这是因为我们没有在<code>app.ts</code>里没有进行类型约束。与类型的相关内容会在后面谈到。现在我们来让<code>app.ts</code>出一点“错误”，将<code>str</code>换成数组，编辑器会把错误代码用红色波浪线标出，如果此时在命令行运行<code>yarn tsc app.ts</code>，控制台便会报错。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.ts</span></span><br><span class="line"><span class="keyword">const</span> str = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;p&quot;</span>, <span class="string">&quot;p&quot;</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">charAt</span>(<span class="number">0</span>)); <span class="comment">// charAt会被</span></span><br></pre></td></tr></table></figure><p>尽管如此，报错了的代码依旧会被编译成<code>js</code>文件。我们可以在<code>tsc</code>命令后加上编译的相关配置指令来进行控制。比如，加上<strong><code>--noEmitOnError</code></strong>之后，一旦报错便不会生成<code>js</code>文件。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc <span class="literal">--noEmitOnError</span> hello.ts</span><br></pre></td></tr></table></figure><p>但是 ts 的编译配置项非常多，如果每次都通过在命令行加入指令来进行相关控制，无疑非常繁琐。因此我们可以在<strong><code>tsconfig.json</code></strong>里编写相关配置，这样我们执行<code>tsc</code>命令时，编译器会默认从当前目录逐步向上层目录查找并读取<code>tsconfig.json</code>里的配置项。</p><h2 id="二-、配置文件：tsconfig-json"><a href="#二-、配置文件：tsconfig-json" class="headerlink" title="(二)、配置文件：tsconfig.json"></a>(二)、配置文件：<code>tsconfig.json</code></h2><p>在运行<code>tsc</code>命令时，我们可以在后面添加指令来指定相关配置。但是我们会更倾向于在<code>tsconfig.json</code>里对相关指令进行配置，以减少重复、繁琐的操作。在<code>Vue</code>、<code>React</code>等框架搭建的项目里，一般都已生成初步配置好了的<code>tsconfig.json</code>文件。本篇只进行解基础内容的分享，有关配置的章节将在后续推出。</p><h2 id="三-、类型基础"><a href="#三-、类型基础" class="headerlink" title="(三)、类型基础"></a>(三)、类型基础</h2><p>这里介绍部分 TS 基础类型，关于类型的进阶将在后续篇章中单独介绍。注意不要将基础类型和 js 基本数据类型混为一谈。基础类型可以理解为 ts 内置的各种类型，而非我们人为定义出的类型。TS 有多种基础类型，这些类型可以用来进行组合，从而得到我们需要的人为定义的类型。TS 在声明变量时，在变量名后加上冒号<mark>: </mark>和类型名来进行变量的类型注释。如果不添加类型注释，则 TS 会根据变量的初始值进行<mark><strong>类型推论</strong></mark>，自动推断出该变量属于什么类型。如果也没有初始值，则会被推断为<strong>any</strong>类型。</p><h3 id="1-原有的基本数据类型"><a href="#1-原有的基本数据类型" class="headerlink" title="1. 原有的基本数据类型"></a>1. 原有的基本数据类型</h3><ul><li><strong><code>string</code></strong>：字符串类型，注意<code>String</code>在<code>js</code>里已经有特殊意义了，而小写的<code>string</code>才是<code>Typescript</code>用来表示字符串的类型名称，即在注释变量类型为字符串时，使用小写的<code>string</code>，而不是大写的<code>String</code>，注意不要混淆了两者；<code>number</code>和<code>boolean</code>同理。</li><li><strong><code>number</code></strong>：数字类型；</li><li><p><strong><code>boolean</code></strong>：布尔类型；</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明变量类型，可以不赋初值，后续给num赋的值必须是number类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">num</span>: <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">str</span>: <span class="built_in">string</span> = <span class="string">&quot;typescript&quot;</span>;</span><br><span class="line"><span class="comment">// 类型推断：TS会自动推断出bool的类型为boolean</span></span><br><span class="line"><span class="keyword">let</span> bool = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-Array"><a href="#2-Array" class="headerlink" title="2. Array"></a>2. <code>Array</code></h3><p><code>Array</code>是数组类型，属于对象类型的一种。由于数组内会有数组成员，因此，在声明数组变量的时候，还要给数组成员添加类型注释，一般有两种常见方式：<strong><code>Type[]</code></strong>、<strong><code>Array&lt;Type&gt;</code></strong>。后者涉及<strong>泛型</strong>概念，将在后续介绍。其中，<code>Type</code>指代数组成员的类型，可以是基础类型，也可以是人为定义的类型 (关于数组的变形，元组类型，将在对象类型的章节介绍)。例如，要声明一个存放字符串的数组变量：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">arr1</span>: <span class="built_in">string</span>[];</span><br><span class="line"><span class="comment">// 也可以像下面</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr2</span>: <span class="title class_">Array</span>&lt;<span class="built_in">string</span>&gt;;</span><br></pre></td></tr></table></figure><h3 id="3-object"><a href="#3-object" class="headerlink" title="3. object"></a>3. <code>object</code></h3><p>对象类型是我们平时更为常见的类型。在本篇只给出一些简单定义，后续篇章中会进行单独介绍。一个对象类型的变量可以通过键值对来存储多个数据。定义一个对象类型，可以简单地列出它的各个属性及属性的类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个包含name, age, gender属性的变量obj</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>: &#123; <span class="attr">name</span>: <span class="built_in">string</span>; <span class="attr">age</span>: <span class="built_in">number</span>; <span class="attr">gender</span>: <span class="string">&quot;gg&quot;</span> | <span class="string">&quot;mm&quot;</span> &#125;;</span><br></pre></td></tr></table></figure><p>之后给 obj 赋值时<strong>必须有且只能有</strong><code>name</code>，<code>age</code>，<code>gender</code>三个属性，且属性值应为相应的类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 会报错,多了一个beauty属性,因此类型不合</span></span><br><span class="line">obj = &#123; <span class="attr">name</span>: <span class="string">&quot;yy&quot;</span>, <span class="attr">age</span>: <span class="number">22</span>, <span class="attr">gender</span>: <span class="string">&quot;mm&quot;</span>, <span class="attr">beauty</span>: <span class="number">100</span> &#125;;</span><br><span class="line"><span class="comment">// 报错，缺少了gender属性</span></span><br><span class="line">obj = &#123; <span class="attr">name</span>: <span class="string">&quot;yy&quot;</span>, <span class="attr">age</span>: <span class="number">22</span> &#125;;</span><br><span class="line"><span class="comment">// 正确赋值</span></span><br><span class="line">obj = &#123; <span class="attr">name</span>: <span class="string">&quot;yy&quot;</span>, <span class="attr">age</span>: <span class="number">22</span>, <span class="attr">gender</span>: <span class="string">&quot;mm&quot;</span> &#125;;</span><br></pre></td></tr></table></figure><p>如果想要让某个属性变为可选项，则可以在定义对象类型时在属性名后使用问号”?”：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将gender定义为可选项</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>: &#123; <span class="attr">name</span>: <span class="built_in">string</span>; <span class="attr">age</span>: <span class="built_in">number</span>; gender?: <span class="string">&quot;gg&quot;</span> | <span class="string">&quot;mm&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line">obj = &#123; <span class="attr">name</span>: <span class="string">&quot;yy&quot;</span>, <span class="attr">age</span>: <span class="number">22</span>, <span class="attr">gender</span>: <span class="string">&quot;mm&quot;</span> &#125;;</span><br><span class="line"><span class="comment">// 也正确，因为gender是可选的</span></span><br><span class="line">obj = &#123; <span class="attr">name</span>: <span class="string">&quot;yy&quot;</span>, <span class="attr">age</span>: <span class="number">22</span> &#125;;</span><br></pre></td></tr></table></figure><p>在某个属性被定义为可选项之后，一旦给该对象赋值时，没有传入该属性，它的取值便会成为<code>undefined</code> (注意<strong>这与一开始边定义<code>gender: &#39;gg&#39; | &#39;mm&#39; | undefined</code>不同</strong>。)</p><p>使用可选项有些地方需要注意，如<strong>在函数的形参中</strong>存在可选项，此时由于<code>gender</code>属性可能为<code>undefined</code>，我们在使用时需要在该属性后面加上英文感叹号”<code>!</code>“进行<strong>非空断言</strong>，明确它不是<code>undefined</code>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">obj: &#123; name: <span class="built_in">string</span>; age: <span class="built_in">number</span>; gender?: <span class="string">&quot;gg&quot;</span> | <span class="string">&quot;mm&quot;</span> &#125;</span>) &#123;</span><br><span class="line">  <span class="comment">// 使用!进行非空断言</span></span><br><span class="line">  obj.<span class="property">gender</span>!.<span class="title function_">replace</span>(<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-Union-Types-联合类型"><a href="#4-Union-Types-联合类型" class="headerlink" title="4. Union Types 联合类型"></a>4. <code>Union Types</code> 联合类型</h3><p><code>Union Types</code>是指使用 “<code>|</code>“符号来把多个类型联合成一个类型，一个联合类型的变量，其值可以是联合类型的任何一个子类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义a为联合类型，则a可以是string类型也可以是number类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"><span class="comment">// a可以是string</span></span><br><span class="line">a = <span class="string">&quot;union types&quot;</span>;</span><br><span class="line"><span class="comment">// a也可以是number</span></span><br><span class="line">a = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>在<strong>函数的形参中</strong>使用联合类型时有一些注意事项，如在上面的例子中，<code>a</code> 的类型是<code>string | number</code>，此时<code>a</code>无法调用字符串方法，因为<code>a</code>有可能是一个<code>number</code>；同理，也不能直接调用数字类型的方法。当然，也不能直接赋值给<code>string</code>类型的变量或者<code>number</code>类型的变量。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"><span class="comment">// a可以是string</span></span><br><span class="line">a = <span class="string">&quot;union types&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">b</span>: <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>: <span class="built_in">number</span>;</span><br><span class="line"><span class="comment">// 当开启了严格空值检查时，以下两次赋值都不合法</span></span><br><span class="line">b = a;</span><br><span class="line">c = a;</span><br></pre></td></tr></table></figure><p>当然，如果每个子类型都具有共同的方法，则可以调用该共同的方法。例如：数组和字符串都具有<code>slice</code>方法，则联合类型<code>string | number[]</code> 的变量可以调用<code>slice</code>方法。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params">obj: <span class="built_in">string</span> | <span class="built_in">number</span>[]</span>) &#123;</span><br><span class="line">  <span class="comment">// 可以直接调用slice方法</span></span><br><span class="line">  <span class="keyword">const</span> a = obj.<span class="title function_">slice</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-Type-Alias-类型别名"><a href="#5-Type-Alias-类型别名" class="headerlink" title="5. Type Alias 类型别名"></a>5. <code>Type Alias</code> 类型别名</h3><p>使用<strong><code>type</code></strong>关键字给你的类型起一个别名，以后就可以使用别名来指代这个类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Point</span> = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">ID</span> = <span class="built_in">number</span> | <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类型别名Point</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">p</span>: <span class="title class_">Point</span> = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">123</span>,</span><br><span class="line">  <span class="attr">y</span>: <span class="number">222</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="6-Interfaces"><a href="#6-Interfaces" class="headerlink" title="6. Interfaces"></a>6. Interfaces</h3><p>通过关键字<strong><code>interface</code></strong>，来定义一个接口，实际是一个对象类型，用于规定一个对象的形状。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printCoord</span>(<span class="params">pt: Point</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;The coordinate&#x27;s x value is &quot;</span> + pt.<span class="property">x</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;The coordinate&#x27;s y value is &quot;</span> + pt.<span class="property">y</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">printCoord</span>(&#123; <span class="attr">x</span>: <span class="number">100</span>, <span class="attr">y</span>: <span class="number">100</span> &#125;);</span><br></pre></td></tr></table></figure><p>简单说说<strong><code>interface</code>与类型别名的区别</strong>：</p><ul><li><code>interface</code> 可以通过 <strong><code>extends</code></strong>关键字来<strong>继承</strong>另一个<code>interface</code>，而<code>type</code>通过 <code>&amp;</code>符号来连接不同的对象属性；</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承Animal接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">skull</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承了Animal接口的属性name</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">dog</span>: <span class="title class_">Dog</span> = &#123;</span><br><span class="line">  <span class="attr">skull</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;wangcai&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型别名通过&amp;符号来拓展属性</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Dog2</span> = <span class="title class_">Animal</span> &amp; &#123;</span><br><span class="line">  <span class="attr">skull</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>interface</code>可以进行拓展，<code>Type</code>不可以</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">skull</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拓展interface的内容</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时Dog类型包含name,skull,age三个</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">dog</span>: <span class="title class_">Dog</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;wangcai&quot;</span>,</span><br><span class="line">  <span class="attr">skull</span>: <span class="number">12</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个Dog2类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Dog2</span> = &#123;</span><br><span class="line">  <span class="attr">skull</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会报错，Dog2重复了</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Dog2</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>interface</code>定义对象的形状，<code>type</code>不仅可以用于对象，也可以用于其它类型</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">TypeA</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TypeB</span> = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TypeC</span> = <span class="title class_">TypeA</span> | <span class="title class_">TypeB</span>;</span><br></pre></td></tr></table></figure><h3 id="7-Intersection-Types-交叉类型"><a href="#7-Intersection-Types-交叉类型" class="headerlink" title="7. Intersection Types 交叉类型"></a>7. <code>Intersection Types</code> 交叉类型</h3><p>用 <code>&amp;</code> 符号来连接多个类型，属于交叉类型 <code>A &amp; B</code> 的变量，既满足<code>A</code>的约束，又满足<code>B</code>的约束。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">TypeA</span> = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TypeB</span> = <span class="title class_">Array</span>&lt;<span class="built_in">boolean</span>&gt; | <span class="built_in">number</span>;</span><br><span class="line"><span class="comment">// TypeC既满足TypeA又满足TypeB，因此TypeC是number</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TypeC</span> = <span class="title class_">TypeA</span> &amp; <span class="title class_">TypeB</span>;</span><br><span class="line"><span class="comment">// a是number类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="title class_">TypeC</span> = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// b是TypeA类型，它的值是个string，因此不能赋值给a</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">b</span>: <span class="title class_">TypeA</span> = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">a = b; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>也可以用来拓展对象类型的属性：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> B = &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">gender</span>: <span class="string">&quot;男&quot;</span> | <span class="string">&quot;女&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 类型C是既满足A又满足B，即C既包含A的所有属性，又包含B的所有属性，</span></span><br><span class="line"><span class="comment">// 从而实现属性拓展</span></span><br><span class="line"><span class="keyword">type</span> C = A &amp; B;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>: C = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;cc&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">gender</span>: <span class="string">&quot;男&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意 <strong><code>&amp;</code> 和 | 的区别</strong>：”<code>&amp;</code>“可以合并多个对象类型的属性，使得到的新的对象类型包含其它所有类型的全部属性；”<code>&amp;</code>“可以获得多个类型之间的公共子类型；”<code>|</code>“可以联合多个类型，得到的新类型的值，只需满足其中一种子类型即可。</p><h3 id="8-Literal-Types-字面量类型"><a href="#8-Literal-Types-字面量类型" class="headerlink" title="8. Literal Types 字面量类型"></a>8. <code>Literal Types</code> 字面量类型</h3><p>通过字面量来定义类型，字面量的值可以是任意一个类型的值，可以将多个不同类型的字面量进行组合，此时得到的变量上的方法无法进行合法调用，因为变量可能为其它不含该方法的类型（与联合类型同理）。因此需要进行类型精简或类型断言。注意在变量声明时进行类型注释了的才能被字面量类型约束，如果没有类型注释，则会按照类型推论的结果来判定类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义gender只能取值为 &#x27;男&#x27; 或 &#x27;女&#x27; 中的一种</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">gender</span>: <span class="string">&quot;男&quot;</span> | <span class="string">&quot;女&quot;</span> = <span class="string">&quot;男&quot;</span>;</span><br><span class="line"><span class="comment">// gender2经类型推论string类型</span></span><br><span class="line"><span class="keyword">let</span> gender2 = <span class="string">&quot;男&quot;</span>;</span><br><span class="line"><span class="comment">// 多种类型字面量的组合</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="string">&quot;未知数&quot;</span> | <span class="number">1</span> | &#123; <span class="attr">y</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="comment">// 严格类型检查时不能合法调用</span></span><br><span class="line">x.<span class="title function_">split</span>(<span class="string">&quot;知&quot;</span>) &lt;</span><br><span class="line">  <span class="comment">// 进行类型断言后可合法</span></span><br><span class="line">  <span class="built_in">string</span> &gt;</span><br><span class="line">  x.<span class="title function_">split</span>(<span class="string">&quot;知&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="9-null-和-undefined-与-非空断言"><a href="#9-null-和-undefined-与-非空断言" class="headerlink" title="9. null 和 undefined 与 非空断言"></a>9. <code>null</code> 和 <code>undefined</code> 与 非空断言</h3><p>两个空值类型，和在<code>js</code>里的区别一致。开启/关闭严格空值检查会影响到空值类型的行为。当我们知道一个变量不会为空时，可以在该变量后使用英文感叹号 “<code>!</code>“ ，进行临时<strong>非空断言 （<code>Non-null Assertion</code>）</strong>。这点在函数中尤为重要。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyType</span> = <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">value</span>: <span class="title class_">MyType</span> = <span class="string">&quot;I love China&quot;</span>;</span><br><span class="line"><span class="comment">// 对value进行非空断言</span></span><br><span class="line">value!.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="10-Enums-枚举类型"><a href="#10-Enums-枚举类型" class="headerlink" title="10. Enums 枚举类型"></a>10. <code>Enums</code> 枚举类型</h3><p>枚举类型是一组被有意义地命名了的常量的集合。与其它类型本质上不同的是，其它的类型都只是类型，而枚举类型却是可以使用的值。<strong>通过<code>enum</code>关键字声明某个变量为枚举类型的值</strong>，使用枚举类型，可以让我们不去关注变量实际的值，而使用更有意义的名字来代表实际的值。例如，在表示性别时，我们可以简单地用数字 1 和 2 来表示 男 和 女。那么在实际使用中，我们需要知道到底是 1 代表男还是 1 代表女。当数据从前端传到后端，后端的小伙伴又需要去了解哪个数字代表哪个性别。这对我们来说就不太友好。所以，我们可以使用枚举类型来定义一组表示性别的常量，之后使用时，只需取常量的名字即可。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Gender</span> &#123;</span><br><span class="line">  <span class="attr">male</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">female</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">secret</span>: <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举类型包括数字型枚举、字符串型枚举、异构枚举等等。此处只简要了解一下枚举类型的的存在，后续会写一篇枚举类型的深入。</p><h3 id="11-any"><a href="#11-any" class="headerlink" title="11. any"></a>11. <code>any</code></h3><p><code>any</code>可以指代任何类型，可以被赋值给任意类型的变量。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给变量anyscript一个any类型，其值为数字123</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">anyscript</span>: <span class="built_in">any</span> = <span class="number">123</span>;</span><br><span class="line"><span class="comment">// 给变量typescript一个string类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">typescript</span>: <span class="built_in">string</span> = <span class="string">&quot;typescript&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值操作后，typescript变成了123，其类型发生了改变</span></span><br><span class="line">typescript = anyscript;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 而编译器会认为typescript变量为string类型，且允许我们调用string类型的方法</span></span><br><span class="line">typescript.<span class="title function_">split</span>(<span class="string">&quot;c&quot;</span>);</span><br><span class="line"><span class="comment">// 而事实上此时变量typescript的值已经变为了数字123，调用string的方法就会</span></span><br></pre></td></tr></table></figure><p>这个看起来很便捷的<code>any</code>类型，在这种时候就会引发问题，造成类型污染。因此，我们应该避免使用<code>any</code>，以免走进<code>Anyscript</code>的误区。</p><h3 id="12-unknown与类型断言"><a href="#12-unknown与类型断言" class="headerlink" title="12. unknown与类型断言"></a>12. <code>unknown</code>与类型断言</h3><p><code>unknown</code>用来表示未知类型，和<code>any</code>相似，它的值可以是任何类型。不同的是，如果一个变量是<code>unknown</code>类型，那么它在被明确为某个确切的类型之前，不能调用任何方法，也不能被赋值给其它变量。你可以使用<mark><strong>类型断言</strong></mark>来<strong>临时</strong>人为明确一个 unknown 变量的确切类型。毕竟<strong>你永远比<code>Typescript</code>知道的多</strong>！类型断言一般有两种方式：使用 <code>a as Type</code> 或者 在需要进行类型断言的变量前使用尖括号：<code>&lt;Type&gt;a</code>，来明确变量<code>a</code>为<code>Type</code>类型。注意类型断言是临时的，因此它不会改变原来<code>unknown</code>变量的类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个unknown变量a，一个字符串变量b</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="built_in">unknown</span> = <span class="string">&quot;I am unknown type&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">b</span>: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里会报错，因为a为unknown类型，而且并没有明确它的具体类型，</span></span><br><span class="line"><span class="comment">// 不能被赋值给字符串变量b，哪怕a本身实际的值为字符串</span></span><br><span class="line">b = a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类型断言来明确a的具体类型为字符串string，</span></span><br><span class="line"><span class="comment">// 之后便可以赋值给字符串b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用as进行类型断言，可以用括号将其整体包裹起来，以进行对断言之后的变量a的操作</span></span><br><span class="line">b = a <span class="keyword">as</span> <span class="built_in">string</span>;</span><br><span class="line">b = (a <span class="keyword">as</span> <span class="built_in">string</span>) + <span class="string">&quot;!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以使用&lt;Type&gt;a的形式进行类型断言</span></span><br><span class="line">b = &lt;<span class="built_in">string</span>&gt;a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 之后 a 的类型依然是unknown</span></span><br></pre></td></tr></table></figure><p>也许你会觉得使用<code>unknown</code>类型有些繁琐。但相比起<code>any</code>类型容易引发的错误，<code>unknown</code>类型的使用足够安全。因此，如果有需要使用不明确的类型时，应该首选<code>unknown</code>而不是<code>any</code>。毕竟谁也不愿意，一杯茶，一个圈，一个<code>BUG</code>改一天(甚至还在排查错误原因)。</p><h3 id="13-never-和-void"><a href="#13-never-和-void" class="headerlink" title="13. never 和 void"></a>13. <code>never</code> 和 <code>void</code></h3><p><code>void</code>用于表示函数返回空值；<code>never</code>用于表示不该使用的值或者函数不应该有返回值，在我们平常的工作中<code>never</code>的应用场景较少。</p><h3 id="14-不常用的类型"><a href="#14-不常用的类型" class="headerlink" title="14.不常用的类型"></a>14.不常用的类型</h3><p><strong><code>Bigint</code>和<code>Symbol</code></strong>是<code>ES6</code>之后加入的基本数据类型，目前在日常工作中的使用并不多见。<code>TS</code>中的这两种类型和<code>JS</code>中一致。</p><ul><li><p><strong><code>bigint</code></strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用BigInt函数来创建一个bigint类型的变量</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">oneHundred</span>: <span class="built_in">bigint</span> = <span class="title class_">BigInt</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用字面量语法 数字 + n 来创建bigint类型的变量</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">anotherHundred</span>: <span class="built_in">bigint</span> = <span class="number">100n</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>Symbol</code></strong></p><p><code>Symbol</code>是<code>ES6</code>之后新增的一种基本数据类型，每个<code>Symbol</code>类型的变量，其值都是唯一的，即使传入相同的参数，返回的结果也永远不会相等。一般使用<code>Symbol</code>函数来创建。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Symbol函数创建Symbol类型的变量/常量</span></span><br><span class="line"><span class="keyword">const</span> first1 = <span class="title class_">Symbol</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> first2 = <span class="title class_">Symbol</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"></span><br><span class="line">first1 === first2; <span class="comment">// 永远是false</span></span><br></pre></td></tr></table></figure></li></ul><p>类型基础的内容就介绍到这里啦，下一篇将着重介绍在函数中使用各种类型时需要注意的问题，例如如何进行类型精确。如果文章描述有不妥之处，恳请不吝指出，我们下一篇再见！</p>]]></content>
      
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

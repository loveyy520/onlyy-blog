<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>如何手写一个符合需求的Babel插件</title>
      <link href="/articals/d92b6379/"/>
      <url>/articals/d92b6379/</url>
      
        <content type="html"><![CDATA[<p>作为一个强大的多功能<code>JS</code>转译器，<code>Babel</code>有许许多多的模块可用于静态分析。而在项目中，有时候我们也需要创建一个符合项目需求的<code>Babel</code>插件。本文旨在帮助大家深入理解<code>Babel</code>插件工作流程的同时，让大家掌握如何按需求编写自己的<code>Babel</code>插件。</p><h2 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h2><h3 id="1-Babel对代码处理分为三个步骤："><a href="#1-Babel对代码处理分为三个步骤：" class="headerlink" title="1. Babel对代码处理分为三个步骤："></a>1. <code>Babel</code>对代码处理分为三个步骤：</h3><p><strong>解析(<code>parse</code>)</strong>、<strong>转换(<code>transform</code>)</strong>、<strong>生成(<code>generate</code>)</strong> 。</p><h3 id="2-解析"><a href="#2-解析" class="headerlink" title="2. 解析"></a>2. 解析</h3><p>在 <strong>解析</strong> 这一步，<code>Babel</code>接收代码，处理后生成 <code>AST</code> 。该步骤分为 <strong>词法分析(<code>Lexical Analysis</code>)</strong> 和 <strong>语法分析(<code>Syntactic Analysis</code>)</strong> 两个阶段。</p><h4 id="2-1-词法分析"><a href="#2-1-词法分析" class="headerlink" title="2.1 词法分析"></a>2.1 词法分析</h4><p><code>Babel</code>接收的源代码为代码字符串，词法分析会把字符串代码转化为 <strong>令牌(<code>tokens</code>)</strong> 流，令牌是对代码词法的描述。可以看作一个扁平的语法片段数组。例如，对于以下语法片段：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n * n;</span><br></pre></td></tr></table></figure><p>将被转化为如下令牌，可以看到，除了具有<code>type</code>和<code>value</code>属性以外，令牌还和<code>AST</code>一样具有<code>start</code>, <code>end</code>, <code>loc</code>属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123; <span class="attr">type</span>: &#123; ... &#125;, <span class="attr">value</span>: <span class="string">&quot;n&quot;</span>, <span class="attr">start</span>: <span class="number">0</span>, <span class="attr">end</span>: <span class="number">1</span>, <span class="attr">loc</span>: &#123; ... &#125; &#125;,</span><br><span class="line">  &#123; <span class="attr">type</span>: &#123; ... &#125;, <span class="attr">value</span>: <span class="string">&quot;*&quot;</span>, <span class="attr">start</span>: <span class="number">2</span>, <span class="attr">end</span>: <span class="number">3</span>, <span class="attr">loc</span>: &#123; ... &#125; &#125;,</span><br><span class="line">  &#123; <span class="attr">type</span>: &#123; ... &#125;, <span class="attr">value</span>: <span class="string">&quot;n&quot;</span>, <span class="attr">start</span>: <span class="number">4</span>, <span class="attr">end</span>: <span class="number">5</span>, <span class="attr">loc</span>: &#123; ... &#125; &#125;,</span><br><span class="line">  ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>其中，每个<code>type</code>都有一组属性来描述该令牌：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">type</span>: &#123;</span><br><span class="line">    <span class="attr">label</span>: <span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">    <span class="attr">keyword</span>: <span class="literal">undefined</span>,</span><br><span class="line">    <span class="attr">beforeExpr</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">startsExpr</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">rightAssociative</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">isLoop</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">isAssign</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">prefix</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">postfix</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">binop</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">updateContext</span>: <span class="literal">null</span></span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-语法分析"><a href="#2-2-语法分析" class="headerlink" title="2.2 语法分析"></a>2.2 语法分析</h4><p>词法分析将字符串代码转化为<code>tokens</code>，语法分析则是根据<code>tokens</code>生成<code>AST</code>的表述结构，这样更易于进行后续操作。</p><h3 id="3-转换"><a href="#3-转换" class="headerlink" title="3. 转换"></a>3. 转换</h3><p><strong>转换</strong> 步骤接收<code>AST</code>并对其进行遍历，这个过程中主要对节点进行增删改，是编译器最为复杂的过程，也是插件将要介入工作的部分。本文的主要内容也将围绕这个部分展开。</p><h3 id="4-生成"><a href="#4-生成" class="headerlink" title="4. 生成"></a>4. 生成</h3><p><strong>生成</strong> 的步骤相对简单，主要是对 经过一系列转化得到的最终 <code>AST</code> 进行 深度优先遍历 来生成字符串形式的代码，并创建 <strong>源码映射(<code>source maps</code>)</strong> 。</p><h3 id="5-抽象语法树-AST"><a href="#5-抽象语法树-AST" class="headerlink" title="5. 抽象语法树 AST"></a>5. 抽象语法树 <code>AST</code></h3><p><code>Babel</code>的处理过程每一步都涉及创建或操作<code>AST</code>，使用的是基于<code>ESTree</code>并修改过的<code>AST</code>。例如对于以下程序片段：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">square</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> n * n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会被处理为如下<code>AST</code>：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- FunctionDeclaration:</span><br><span class="line">  - id:</span><br><span class="line">    - Identifier:</span><br><span class="line">      - name: square</span><br><span class="line">  - params <span class="section">[1]</span></span><br><span class="line">    - Identifier</span><br><span class="line">      - name: n</span><br><span class="line">  - body:</span><br><span class="line">    - BlockStatement</span><br><span class="line">      - body <span class="section">[1]</span></span><br><span class="line">        - ReturnStatement</span><br><span class="line">          - argument</span><br><span class="line">            - BinaryExpression</span><br><span class="line">              - operator: *</span><br><span class="line">              - left</span><br><span class="line">                - Identifier</span><br><span class="line">                  - name: n</span><br><span class="line">              - right</span><br><span class="line">                - Identifier</span><br><span class="line">                  - name: n</span><br></pre></td></tr></table></figure><p>或者以<code>JS</code>对象来表示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&quot;FunctionDeclaration&quot;</span>,</span><br><span class="line">  <span class="attr">id</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;Identifier&quot;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;square&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">params</span>: [&#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;Identifier&quot;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;n&quot;</span></span><br><span class="line">  &#125;],</span><br><span class="line">  <span class="attr">body</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;BlockStatement&quot;</span>,</span><br><span class="line">    <span class="attr">body</span>: [&#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&quot;ReturnStatement&quot;</span>,</span><br><span class="line">      <span class="attr">argument</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&quot;BinaryExpression&quot;</span>,</span><br><span class="line">        <span class="attr">operator</span>: <span class="string">&quot;*&quot;</span>,</span><br><span class="line">        <span class="attr">left</span>: &#123;</span><br><span class="line">          <span class="attr">type</span>: <span class="string">&quot;Identifier&quot;</span>,</span><br><span class="line">          <span class="attr">name</span>: <span class="string">&quot;n&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">right</span>: &#123;</span><br><span class="line">          <span class="attr">type</span>: <span class="string">&quot;Identifier&quot;</span>,</span><br><span class="line">          <span class="attr">name</span>: <span class="string">&quot;n&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，不同的层级各自具有一致的结构：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&quot;FunctionDeclaration&quot;</span>,</span><br><span class="line">  <span class="attr">id</span>: &#123;...&#125;,</span><br><span class="line">  <span class="attr">params</span>: [...],</span><br><span class="line">  <span class="attr">body</span>: &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&quot;Identifier&quot;</span>,</span><br><span class="line">  <span class="attr">name</span>: ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&quot;BinaryExpression&quot;</span>,</span><br><span class="line">  <span class="attr">operator</span>: ...,</span><br><span class="line">  <span class="attr">left</span>: &#123;...&#125;,</span><br><span class="line">  <span class="attr">right</span>: &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的每一层结构叫做 <strong>节点(<code>Node</code>)</strong> 。一个<code>AST</code>可以由一个或许多个节点构成。这些节点组合在一起可用以描述用于静态分析的程序语法。而每一个节点都有如下接口：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="attr">type</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>string</code>形式的<code>type</code>字段表示节点的类型，如<code>&quot;FunctionDeclaration&quot;</code>, <code>&quot;Identifier&quot;</code>, <code>&quot;BinaryExpression&quot;</code> 等。且每种类型的节点，又定义了一些附加属性来进一步描述该节点。此外，<code>Babel</code>还为每个节点生成了额外属性(<code>start</code>, <code>end</code>, <code>loc</code> 等)，用于描述该节点在原始代码中的位置，每个节点都有这些属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">type</span>: ...,</span><br><span class="line">  <span class="attr">start</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">end</span>: <span class="number">38</span>,</span><br><span class="line">  <span class="attr">loc</span>: &#123;</span><br><span class="line">    <span class="attr">start</span>: &#123;</span><br><span class="line">      <span class="attr">line</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">column</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">end</span>: &#123;</span><br><span class="line">      <span class="attr">line</span>: <span class="number">3</span>,</span><br><span class="line">      <span class="attr">column</span>: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-遍历"><a href="#6-遍历" class="headerlink" title="6. 遍历"></a>6. 遍历</h3><p>要想转换<code>AST</code>，则需要对<code>AST</code>进行递归遍历。假如有一个<code>FunctionDeclaration</code>类型，它有如下几个属性：<code>id</code>, <code>params</code>, <code>body</code>，且每个属性都有一些内嵌节点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&quot;FunctionDeclaration&quot;</span>,</span><br><span class="line">  <span class="attr">id</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;Identifier&quot;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;square&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">params</span>: [&#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;Identifier&quot;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;n&quot;</span></span><br><span class="line">  &#125;],</span><br><span class="line">  <span class="attr">body</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;BlockStatement&quot;</span>,</span><br><span class="line">    <span class="attr">body</span>: [&#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&quot;ReturnStatement&quot;</span>,</span><br><span class="line">      <span class="attr">argument</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&quot;BinaryExpression&quot;</span>,</span><br><span class="line">        <span class="attr">operator</span>: <span class="string">&quot;*&quot;</span>,</span><br><span class="line">        <span class="attr">left</span>: &#123;</span><br><span class="line">          <span class="attr">type</span>: <span class="string">&quot;Identifier&quot;</span>,</span><br><span class="line">          <span class="attr">name</span>: <span class="string">&quot;n&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">right</span>: &#123;</span><br><span class="line">          <span class="attr">type</span>: <span class="string">&quot;Identifier&quot;</span>,</span><br><span class="line">          <span class="attr">name</span>: <span class="string">&quot;n&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照如下顺序遍历以上<code>AST</code>：</p><ul><li>我们从<code>FunctionDeclaration</code>开始依次访问每一个属性及其子节点；</li><li>随后来带<code>id</code>，是个<code>Identifier</code>，且它没有任何子节点属性；</li><li>于是继续访问下一个属性<code>params</code>，而<code>params</code>是一个数组节点，因此要遍历访问其中的每一个，它们都是<code>Identifier</code>类型的单一节点；</li><li>继续下去，变来到了<code>body</code>，是个<code>BlockStatement</code>，且内部还有个<code>body</code>节点，内部的<code>body</code>节点是个数组节点，因此我们遍历访问其中的每一个；</li><li>而在这里，内部的<code>body</code>节点唯一的子节点是个<code>ReturnStatement</code>，它有个<code>argument</code>，访问这个<code>argument</code>便找到了<code>BinaryExpression</code>。</li><li><code>BinaryExpression</code>有一个<code>operator</code>，一个<code>left</code>，一个<code>right</code>。</li><li><code>operator</code>只是一个值而不是一个节点，因此，我们只需要访问<code>left</code>和<code>right</code>。</li></ul><h3 id="7-Visitors-访问者"><a href="#7-Visitors-访问者" class="headerlink" title="7. Visitors (访问者)"></a>7. <code>Visitors</code> (访问者)</h3><p>说到 “进入” 一个节点，实际上是说我们在 <strong>访问</strong> 他们。这个术语出自 <strong>访问者模式(<code>visitor</code>) </strong>的概念。访问者是一个用于<code>AST</code>遍历的跨语言的模式。简单的说，他们就是一个对象，定义了用于在一个树状结构中获取具体节点的方法。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问者</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MyVisitor</span> = &#123;</span><br><span class="line">  <span class="title class_">Identifier</span>() &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Called!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 你也可以先创建一个访问者对象，并在稍后给它添加方法。</span></span><br><span class="line"><span class="keyword">let</span> visitor = &#123;&#125;;</span><br><span class="line">visitor.<span class="property">MemberExpression</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line">visitor.<span class="property">FunctionDeclaration</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br></pre></td></tr></table></figure><p>这便是一个极为简单的访问者，每当在<code>AST</code>中遇到<code>Identifier</code>时，就会调用<code>Identifier</code>方法。如果将这个访问者应用到如下代码中，<code>Identifier</code>方法便会执行<code>4</code>次(<code>square</code>和<code>3</code>个<code>n</code>各一次)：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">square</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> n * n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">path.<span class="title function_">traverse</span>(<span class="title class_">MyVisitor</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Called!</span></span><br><span class="line"><span class="comment"> * Called!</span></span><br><span class="line"><span class="comment"> * Called!</span></span><br><span class="line"><span class="comment"> * Called!</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>这些调用都发生在 <strong>进入</strong> 节点时，有时候我们也可以在 <strong>退出</strong> 节点时调用访问者方法。例如对于如下树状结构：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">FunctionDeclaration</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Identifier</span> <span class="string">(id)</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Identifier</span> <span class="string">(params[0])</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">BlockStatement</span> <span class="string">(body)</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReturnStatement</span> <span class="string">(body)</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">BinaryExpression</span> <span class="string">(argument)</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Identifier</span> <span class="string">(left)</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Identifier</span> <span class="string">(right)</span></span><br></pre></td></tr></table></figure><p>当向下遍历每一个分支时，会走到该分支的尽头，此时，便要向上遍历回去，以便访问下一个节点。向下遍历时我们 <strong>进入(enter)</strong> 每个节点，而向上遍历时我们 <strong>退出(exit)</strong> 每个节点。以遍历上面的树为例：</p><ul><li><p>进入<code>FunctionDeclaration</code></p><ul><li>进入 <code>Identifier (id)</code></li><li>走到尽头</li><li><p>退出 <code>Identifier (id)</code></p></li><li><p>进入 <code>Identifier (params[0])</code></p></li><li><p>走到尽头</p></li><li><p>退出 <code>Identifier (params[0])</code></p></li><li><p>进入 <code>BlockStatement (body)</code></p><ul><li><p>进入 <code>ReturnStatement (body)</code></p><ul><li><p>进入 <code>BinaryExpression (argument)</code></p><ul><li>进入 <code>Identifier (left)</code></li><li>走到尽头</li><li>退出 <code>Identifier (left)</code></li><li>进入 <code>Identifier (right)</code></li><li>走到尽头</li><li>退出 <code>Identifier (right)</code></li></ul></li><li><p>退出 <code>BinaryExpression (argument)</code></p></li></ul></li><li><p>退出 <code>ReturnStatement (body)</code></p></li></ul></li><li><p>退出 <code>BlockStatement (body)</code></p></li></ul></li><li><p>退出 <code>FunctionDeclarati</code></p></li></ul><p>因此，当创建访问者时，我们实际上有两次机会来访问一个节点，分别是 <strong>进入(<code>enter</code>)</strong> 和 <strong>退出(<code>exit</code>)</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MyVisitor</span> = &#123;</span><br><span class="line">  <span class="title class_">Identifier</span>: &#123;</span><br><span class="line">    <span class="title function_">enter</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Entered!&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">exit</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Exited!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而我们之前写的<code>Identifier() &#123; ... &#125;</code> 则是 <code>Identifier: &#123; enter() &#123; ... &#125; &#125;</code> 的简写形式，表示在进入时访问节点。</p><p>在有需要的情况下，也可以使用<code>|</code>来把方法名分隔为<code>Idenfifier|MemberExpression</code>形式的字符串，把同一个函数应用到多个访问节点。注意此时需要给方法名加上引号：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MyVisitor</span> = &#123;</span><br><span class="line">  <span class="string">&quot;ExportNamedDeclaration|Flow&quot;</span>(path) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>也可以使用别名作为方法名，例如<code>Function</code>是<code>FunctionDeclaration</code>、<code>FunctionExpression</code>、<code>ArrowFunctionExpression</code>、<code>ObjectMethod</code>和<code>ClassMethod</code>的别名。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MyVisitor</span> = &#123;</span><br><span class="line">  <span class="title class_">Function</span>(path) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="8-Paths-路径"><a href="#8-Paths-路径" class="headerlink" title="8. Paths 路径"></a>8. <code>Paths</code> 路径</h3><p>现在我们知道了，<code>AST</code>中有许多的节点。那么如何去把节点进行相互关联呢？我们可以使用一个巨大的可操作对象来描述节点之间的关系，但是显然这会比较麻烦。而使用 <strong>路径(<code>Paths</code>)</strong> 便能够解决这个问题。</p><p><code>Path</code>是一个对象，用来描述两个节点之间的连接。例如，对于以下节点和其子节点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&quot;FunctionDeclaration&quot;</span>,</span><br><span class="line">  <span class="attr">id</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;Identifier&quot;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;square&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将子节点表示为一个路径(<code>Path</code>)：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;parent&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;FunctionDeclaration&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>...<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    ....</span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;node&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Identifier&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;square&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>同时，它还会包含该路径的其它元数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;parent&quot;</span>: &#123;...&#125;,</span><br><span class="line">  <span class="string">&quot;node&quot;</span>: &#123;...&#125;,</span><br><span class="line">  <span class="string">&quot;hub&quot;</span>: &#123;...&#125;,</span><br><span class="line">  <span class="string">&quot;contexts&quot;</span>: [],</span><br><span class="line">  <span class="string">&quot;data&quot;</span>: &#123;&#125;,</span><br><span class="line">  <span class="string">&quot;shouldSkip&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">&quot;shouldStop&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">&quot;removed&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">&quot;state&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="string">&quot;opts&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="string">&quot;skipKeys&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="string">&quot;parentPath&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="string">&quot;context&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="string">&quot;container&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="string">&quot;listKey&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="string">&quot;inList&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">&quot;parentKey&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="string">&quot;key&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="string">&quot;scope&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="string">&quot;typeAnnotation&quot;</span>: <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，<strong>路径对象上还包含了增删、更新、移动等许多其它方法</strong>。在某种意义上说，路径是一个节点在<code>AST</code>中的位置以及和节点相关的信息的<strong>响应式(<code>Reactive</code>)</strong>表示。每当调用了修改树的方法，相关路径信息也会随之更新，而这些都由<code>Babel</code>管理，使得我们操作节点更加简单，尽可能地做到无状态。</p><h4 id="Path-in-Visitors-存在于访问者中的路径"><a href="#Path-in-Visitors-存在于访问者中的路径" class="headerlink" title="Path in Visitors 存在于访问者中的路径"></a><code>Path in Visitors</code> 存在于访问者中的路径</h4><p>当我们有一个<code>Identifier()</code>方法的<code>Visitor</code>时，实际上我们访问的是路径，而不是节点。通过这种方式，我们操作的就是节点的响应式表示（即路径），而非节点本身。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MyVisitor</span> = &#123;</span><br><span class="line">  <span class="title class_">Identifier</span>(path) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Visiting: &quot;</span> + path.<span class="property">node</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a + b + c;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">path.<span class="title function_">traverse</span>(<span class="title class_">MyVisitor</span>);</span><br><span class="line"><span class="comment">// Visiting: a</span></span><br><span class="line"><span class="comment">// Visiting: b</span></span><br><span class="line"><span class="comment">// Visiting: c</span></span><br></pre></td></tr></table></figure><h3 id="9-State-状态"><a href="#9-State-状态" class="headerlink" title="9. State 状态"></a>9. <code>State</code> 状态</h3><p>对于<code>AST</code>而言，状态管理是极其麻烦的，往往会有一些未考虑到的语法来推翻我们之前对状态的假设。例如，对于以下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">square</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> n * n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们要写一个把<code>n</code>重命名为<code>x</code>的实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> paramName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MyVisitor</span> = &#123;</span><br><span class="line">  <span class="title class_">FunctionDeclaration</span>(path) &#123;</span><br><span class="line">    <span class="keyword">const</span> param = path.<span class="property">node</span>.<span class="property">params</span>[<span class="number">0</span>];</span><br><span class="line">    paramName = param.<span class="property">name</span>;</span><br><span class="line">    param.<span class="property">name</span> = <span class="string">&quot;x&quot;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title class_">Identifier</span>(path) &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.<span class="property">node</span>.<span class="property">name</span> === paramName) &#123;</span><br><span class="line">      path.<span class="property">node</span>.<span class="property">name</span> = <span class="string">&quot;x&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上访问者可以将函数参数中的<code>n</code>重命名为<code>x</code>，且之后所有名为<code>n</code>的<code>Identifier</code>，都将重命名为<code>x</code>。确实可以让<code>square</code>函数中的<code>n</code>重命名为<code>x</code>，但是也会出现预料之外的情况，因为全局的名字为<code>n</code>的<code>Identifier</code>都被会污染：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">square</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> n * n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以下的n也会被重命名为x</span></span><br><span class="line">n;</span><br></pre></td></tr></table></figure><p>因此，给访问者添加方法时，最好使用递归，以便消除对全局状态的影响。如下，可将一个<code>Visitor</code>放进另一个<code>Visitor</code>中，这时候的<code>Identifier()</code>只在<code>MyVisitor</code>的<code>FunctionDeclaration</code>中生效，不会造成全局污染。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> updateParamNameVisitor = &#123;</span><br><span class="line">  <span class="title class_">Identifier</span>(path) &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.<span class="property">node</span>.<span class="property">name</span> === <span class="variable language_">this</span>.<span class="property">paramName</span>) &#123;</span><br><span class="line">      path.<span class="property">node</span>.<span class="property">name</span> = <span class="string">&quot;x&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MyVisitor</span> = &#123;</span><br><span class="line">  <span class="title class_">FunctionDeclaration</span>(path) &#123;</span><br><span class="line">    <span class="keyword">const</span> param = path.<span class="property">node</span>.<span class="property">params</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">const</span> paramName = param.<span class="property">name</span>;</span><br><span class="line">    param.<span class="property">name</span> = <span class="string">&quot;x&quot;</span>;</span><br><span class="line"></span><br><span class="line">    path.<span class="title function_">traverse</span>(updateParamNameVisitor, &#123; paramName &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">path.<span class="title function_">traverse</span>(<span class="title class_">MyVisitor</span>);</span><br></pre></td></tr></table></figure><h3 id="10-Scopes-作用域"><a href="#10-Scopes-作用域" class="headerlink" title="10. Scopes 作用域"></a>10. <code>Scopes</code> 作用域</h3><p><code>JS</code>支持词法作用域，在树状嵌套结构中代码块创建出新的作用域。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// global scope 全局作用域</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">scopeOne</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 局部作用域1</span></span><br><span class="line">  <span class="comment">// scope 1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">scopeTwo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 局部作用域2</span></span><br><span class="line">    <span class="comment">// scope 2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>JS</code>中，当一个引用被创建出来，无论是通过变量(<code>variable</code>)，函数(<code>function</code>)，类型(<code>class</code>)，参数(<code>params</code>)，模块导入(<code>import</code>) 还是 标签(<code>label</code>)，它都属于当前作用域。更深的内部作用域可以使用其外部作用域中的引用，也可以创建和外部作用域同名的引用。当编写转换时，尤其需要注意作用域，确保在改变代码各个部分时不会破坏已经存在的代码。</p><ul><li>当添加一个新的引用时，确保不会和已有的引用发生冲突；</li><li>查找使用某个引用的所有变量时，确保是在给定的作用域中进行；</li></ul><p>作用域可以表示为如下形式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>: path,</span><br><span class="line">  <span class="attr">block</span>: path.<span class="property">node</span>,</span><br><span class="line">  <span class="attr">parentBlock</span>: path.<span class="property">parent</span>,</span><br><span class="line">  <span class="attr">parent</span>: parentScope,</span><br><span class="line">  <span class="attr">bindings</span>: [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每当创建一个新的作用域时，需要给出它的路径和父作用域。之后在遍历过程中它会收集所有的引用(“<code>Bindings</code>”)，一旦收集完毕，就可以在作用域上使用各种方法，这些方法会在后续介绍。</p><h4 id="Bindings-绑定"><a href="#Bindings-绑定" class="headerlink" title="Bindings 绑定"></a><code>Bindings</code> 绑定</h4><p>每个 引用 都属于特定的 作用域，引用 和 作用域 之间的这种关系被称为 <strong>绑定(binding)</strong>。单个绑定看起来如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">identifier</span>: node,</span><br><span class="line">  <span class="attr">scope</span>: scope,</span><br><span class="line">  <span class="attr">path</span>: path,</span><br><span class="line">  <span class="attr">kind</span>: <span class="string">&#x27;var&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">referenced</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">references</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">referencePaths</span>: [path, path, path],</span><br><span class="line"></span><br><span class="line">  <span class="attr">constant</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">constantViolations</span>: [path]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据这些信息，就可以查找到一个绑定的所有引用，以及该绑定的类型信息、所属作用域、是否是常量，或者拷贝它的标识符等等。</p><p>有些情况下，知道一个绑定是否是常量非常有帮助，最有用的一种情形就是压缩代码时：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">scopeOne</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> ref1 = <span class="string">&quot;This is a constant binding&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 没有修改ref1，则ref1是常量</span></span><br><span class="line">  <span class="title function_">becauseNothingEverChangesTheValueOf</span>(ref1);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">scopeTwo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> ref2 = <span class="string">&quot;This is *not* a constant binding&quot;</span>;</span><br><span class="line">    ref2 = <span class="string">&quot;Because this changes the value&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、API"><a href="#二、API" class="headerlink" title="二、API"></a>二、<code>API</code></h2><p><code>Babel</code>是一组模块的集合，这里我们介绍一些主要模块的功能与使用。</p><h3 id="1-babylon"><a href="#1-babylon" class="headerlink" title="1. babylon"></a>1. <code>babylon</code></h3><p><code>Babylon</code>是<code>Babel</code>的解析器。</p><ul><li>安装</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save babylon</span><br></pre></td></tr></table></figure><p>先来试着使用<code>Babylon</code>的<code>parse()</code>方法，来解析一个简单的代码字符串：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> babylon <span class="keyword">from</span> <span class="string">&quot;babylon&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> code = <span class="string">`function square(n) &#123;</span></span><br><span class="line"><span class="string">  return n * n;</span></span><br><span class="line"><span class="string">&#125;`</span>;</span><br><span class="line"></span><br><span class="line">babylon.<span class="title function_">parse</span>(code);</span><br><span class="line"><span class="comment">// 将会被解析为如下形式的ast</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Node &#123;</span></span><br><span class="line"><span class="comment">//   type: &quot;File&quot;,</span></span><br><span class="line"><span class="comment">//   start: 0,</span></span><br><span class="line"><span class="comment">//   end: 38,</span></span><br><span class="line"><span class="comment">//   loc: SourceLocation &#123;...&#125;,</span></span><br><span class="line"><span class="comment">//   program: Node &#123;...&#125;,</span></span><br><span class="line"><span class="comment">//   comments: [],</span></span><br><span class="line"><span class="comment">//   tokens: [...]</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p><code>parse()</code>方法还能接收第二个参数，用于指示<code>Babylon</code>如何解析。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">babylon.<span class="title function_">parse</span>(code, &#123;</span><br><span class="line">  <span class="attr">sourceType</span>: <span class="string">&quot;module&quot;</span>, <span class="comment">// default: &quot;script&quot;</span></span><br><span class="line">  <span class="attr">plugins</span>: [<span class="string">&quot;jsx&quot;</span>] <span class="comment">// default: []</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>sourceType</code> 可以是 <code>&quot;module&quot;</code> 或者 <code>&quot;script&quot;</code>，它表示 Babylon 应该用哪种模式来解析。 <code>&quot;module&quot;</code> 将会在严格模式下解析并且允许模块定义，<code>&quot;script&quot;</code> 则不会。默认值为<code>&quot;script&quot;</code>，该模式下如果发现<code>import</code>或者<code>export</code>则会报错，需要指定<code>scourceType: &quot;module&quot;</code> 来避免这些错误。</p><p><code>Babylon</code>使用了基于插件的架构，有一个<code>plugins</code>来控制内部插件的启用和关闭。对于详细的插件列表，可参考<a href="https://github.com/babel/babylon/blob/master/README.md#plugins">Babylon README文件</a>。</p><h3 id="2-babel-traverse"><a href="#2-babel-traverse" class="headerlink" title="2. babel-traverse"></a>2. <code>babel-traverse</code></h3><p>这个模块负责维护整个树的状态，且负责替换、移除、添加节点。</p><ul><li>安装</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save babel-traverse</span><br></pre></td></tr></table></figure><p>可以将其和<code>Babylon</code>一起使用来遍历和更新节点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> babylon <span class="keyword">from</span> <span class="string">&quot;babylon&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> traverse <span class="keyword">from</span> <span class="string">&quot;babel-traverse&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> code = <span class="string">`function square(n) &#123;</span></span><br><span class="line"><span class="string">  return n * n;</span></span><br><span class="line"><span class="string">&#125;`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ast = babylon.<span class="title function_">parse</span>(code);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历这段 AST，在进入节点时将其中所有命名为 n 的 Identifier 重命名为 x</span></span><br><span class="line"><span class="title function_">traverse</span>(ast, &#123;</span><br><span class="line">  <span class="title function_">enter</span>(<span class="params">path</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      path.<span class="property">node</span>.<span class="property">type</span> === <span class="string">&quot;Identifier&quot;</span> &amp;&amp;</span><br><span class="line">      path.<span class="property">node</span>.<span class="property">name</span> === <span class="string">&quot;n&quot;</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      path.<span class="property">node</span>.<span class="property">name</span> = <span class="string">&quot;x&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="3-babel-types"><a href="#3-babel-types" class="headerlink" title="3. babel-types"></a>3. <code>babel-types</code></h3><p>这是一个用于<code>AST</code>节点的工具库，包含了构造、验证以及变换<code>AST</code>节点的工具方法。</p><ul><li>安装</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save babel-types</span><br></pre></td></tr></table></figure><ul><li>使用</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import traverse from <span class="string">&quot;babel-traverse&quot;</span>;</span><br><span class="line">import * as t from <span class="string">&quot;babel-types&quot;</span>;</span><br><span class="line"></span><br><span class="line">traverse(ast<span class="punctuation">,</span> <span class="punctuation">&#123;</span></span><br><span class="line">  enter(path) <span class="punctuation">&#123;</span></span><br><span class="line">    if (t.isIdentifier(path.node<span class="punctuation">,</span> <span class="punctuation">&#123;</span> name<span class="punctuation">:</span> <span class="string">&quot;n&quot;</span> <span class="punctuation">&#125;</span>)) <span class="punctuation">&#123;</span></span><br><span class="line">      path.node.name = <span class="string">&quot;x&quot;</span>;</span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span>);</span><br></pre></td></tr></table></figure><h4 id="3-1-Definitions-定义"><a href="#3-1-Definitions-定义" class="headerlink" title="3.1 Definitions 定义"></a>3.1 <code>Definitions</code> 定义</h4><p>每一个但一类型的节点都具有相应的定义，包括节点包含哪些属性，什么是合法值，如何构建节点、遍历节点，节点的别名信息等。单一类型节点的定义形式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">defineType</span>(<span class="string">&quot;BinaryExpression&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">builder</span>: [<span class="string">&quot;operator&quot;</span>, <span class="string">&quot;left&quot;</span>, <span class="string">&quot;right&quot;</span>],</span><br><span class="line">  <span class="attr">fields</span>: &#123;</span><br><span class="line">    <span class="attr">operator</span>: &#123;</span><br><span class="line">      <span class="attr">validate</span>: <span class="title function_">assertValueType</span>(<span class="string">&quot;string&quot;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">left</span>: &#123;</span><br><span class="line">      <span class="attr">validate</span>: <span class="title function_">assertNodeType</span>(<span class="string">&quot;Expression&quot;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">right</span>: &#123;</span><br><span class="line">      <span class="attr">validate</span>: <span class="title function_">assertNodeType</span>(<span class="string">&quot;Expression&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">visitor</span>: [<span class="string">&quot;left&quot;</span>, <span class="string">&quot;right&quot;</span>],</span><br><span class="line">  <span class="attr">aliases</span>: [<span class="string">&quot;Binary&quot;</span>, <span class="string">&quot;Expression&quot;</span>]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="3-2-Builders-构建器"><a href="#3-2-Builders-构建器" class="headerlink" title="3.2 Builders 构建器"></a>3.2 <code>Builders</code> 构建器</h4><p>在上面的<code>DefineType</code>中，有一个<code>builder</code>字段：<code>builder: [&quot;operator&quot;, &quot;left&quot;, &quot;right&quot;]</code>。每一个节点类型都有构造器方法，按类似以下方式使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// builder: [&quot;operator&quot;, &quot;left&quot;, &quot;right&quot;]</span></span><br><span class="line"><span class="comment">// a * b</span></span><br><span class="line">t.<span class="title function_">binaryExpression</span>(<span class="string">&quot;*&quot;</span>, t.<span class="title function_">identifier</span>(<span class="string">&quot;a&quot;</span>), t.<span class="title function_">identifier</span>(<span class="string">&quot;b&quot;</span>));</span><br></pre></td></tr></table></figure><p>创建的<code>AST</code>如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&quot;BinaryExpression&quot;</span>,</span><br><span class="line">  <span class="attr">operator</span>: <span class="string">&quot;*&quot;</span>,</span><br><span class="line">  <span class="attr">left</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;Identifier&quot;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;a&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">right</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;Identifier&quot;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;b&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印出来则是：<code>a * b</code>。</p><p>构建器还会验证自身创建的节点，并在错误使用的情形下抛出描述性错误。验证时使用了验证器方法。</p><h4 id="3-3-Validators-验证器"><a href="#3-3-Validators-验证器" class="headerlink" title="3.3 Validators 验证器"></a>3.3 <code>Validators</code> 验证器</h4><p><code>BinaryExpression</code> 的定义中包含了节点的字段 <code>fields</code> 信息，以及如何验证这些字段。</p><p>可以创建两种验证方法：</p><ul><li><code>isX</code>:</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.<span class="title function_">isBinaryExpression</span>(maybeBinaryExpressionNode);</span><br></pre></td></tr></table></figure><p>也可以传入第二个参数来确保节点包含特定的属性和值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.<span class="title function_">isBinaryExpression</span>(maybeBinaryExpressionNode, &#123; <span class="attr">operator</span>: <span class="string">&quot;*&quot;</span> &#125;);</span><br></pre></td></tr></table></figure><ul><li><code>assertX</code>：</li></ul><p>断言式校验版本，会抛出异常而不是返回 <code>true</code> 或 <code>false</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t.<span class="title function_">assertBinaryExpression</span>(maybeBinaryExpressionNode);</span><br><span class="line">t.<span class="title function_">assertBinaryExpression</span>(maybeBinaryExpressionNode, &#123; <span class="attr">operator</span>: <span class="string">&quot;*&quot;</span> &#125;);</span><br><span class="line"><span class="comment">// Error: Expected type &quot;BinaryExpression&quot; with option &#123; &quot;operator&quot;: &quot;*&quot; &#125;</span></span><br></pre></td></tr></table></figure><h4 id="3-4-Converts-变换器"><a href="#3-4-Converts-变换器" class="headerlink" title="3.4 Converts 变换器"></a>3.4 <code>Converts</code> 变换器</h4><p>此处不做介绍。</p><h3 id="4-babel-generator"><a href="#4-babel-generator" class="headerlink" title="4. babel-generator"></a>4. <code>babel-generator</code></h3><p>这是<code>Babel</code>的代码生成器，负责读取<code>AST</code>并将其转化为代码和源码映射(<code>source maps</code>)。</p><ul><li>安装</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save babel-generator</span><br></pre></td></tr></table></figure><ul><li>使用</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> babylon <span class="keyword">from</span> <span class="string">&quot;babylon&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> generate <span class="keyword">from</span> <span class="string">&quot;babel-generator&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> code = <span class="string">`function square(n) &#123;</span></span><br><span class="line"><span class="string">  return n * n;</span></span><br><span class="line"><span class="string">&#125;`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ast = babylon.<span class="title function_">parse</span>(code);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收AST，生成代码 code 和 源码映射 map</span></span><br><span class="line"><span class="title function_">generate</span>(ast, &#123;&#125;, code);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   code: &quot;...&quot;,</span></span><br><span class="line"><span class="comment">//   map: &quot;...&quot;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>也可以通过第二个参数传递一些选项：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">generate</span>(ast, &#123;</span><br><span class="line">  <span class="attr">retainLines</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">compact</span>: <span class="string">&quot;auto&quot;</span>,</span><br><span class="line">  <span class="attr">concise</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">quotes</span>: <span class="string">&quot;double&quot;</span>,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;, code);</span><br></pre></td></tr></table></figure><h3 id="5-babel-template"><a href="#5-babel-template" class="headerlink" title="5. babel-template"></a>5. <code>babel-template</code></h3><p>这个模块能让我们编写字符串形式且带有占位符的代码来代替手动编码，在生成大规模<code>AST</code>的时候尤其有用。</p><ul><li>安装</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save babel-template</span><br></pre></td></tr></table></figure><ul><li>使用</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> template <span class="keyword">from</span> <span class="string">&quot;babel-template&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> generate <span class="keyword">from</span> <span class="string">&quot;babel-generator&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> t <span class="keyword">from</span> <span class="string">&quot;babel-types&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义模板</span></span><br><span class="line"><span class="keyword">const</span> buildRequire = <span class="title function_">template</span>(<span class="string">`</span></span><br><span class="line"><span class="string">  var IMPORT_NAME = require(SOURCE);</span></span><br><span class="line"><span class="string">`</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成AST</span></span><br><span class="line"><span class="keyword">const</span> ast = <span class="title function_">buildRequire</span>(&#123;</span><br><span class="line">  <span class="attr">IMPORT_NAME</span>: t.<span class="title function_">identifier</span>(<span class="string">&quot;myModule&quot;</span>),</span><br><span class="line">  <span class="attr">SOURCE</span>: t.<span class="title function_">stringLiteral</span>(<span class="string">&quot;my-module&quot;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由AST生成代码</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">generate</span>(ast).<span class="property">code</span>);</span><br></pre></td></tr></table></figure><p>于是<code>generate(ast).code</code>便能得到：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myModule = <span class="built_in">require</span>(<span class="string">&quot;my-module&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="三-编写第一个-Babel-插件"><a href="#三-编写第一个-Babel-插件" class="headerlink" title="三. 编写第一个 Babel 插件"></a>三. 编写第一个 <code>Babel</code> 插件</h2><p>终于熟悉了<code>Babel</code>的基础知识了，现在可以愉快地写插件了。</p><p>先从一个接收当前<code>babel</code>对象作为参数的<code>function</code>开始：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params">babel</span>) &#123;</span><br><span class="line">  <span class="comment">// plugin contents 插件内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>babel</code>对象里常用的是<code>babel.types</code>，因此可以在参数中解构以方便使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params">&#123; types: t &#125;</span>) &#123;</span><br><span class="line">  <span class="comment">// plugin contents</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后返回一个对象，其中的<code>visitor</code>属性是这个插件的主要访问者：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params">&#123; types: t &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">visitor</span>: &#123;</span><br><span class="line">      <span class="comment">// visitor contents</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>visitor</code>的每个方法都接收两个参数：<code>path</code>和<code>state</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params">&#123; types: t &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">visitor</span>: &#123;</span><br><span class="line">      <span class="title class_">Identifier</span>(path, state) &#123;&#125;,</span><br><span class="line">      <span class="title class_">ASTNodeTypeHere</span>(path, state) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来完成一个简单的插件，来展示一下插件是如何工作的，假设要处理的源代码为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo === bar;</span><br></pre></td></tr></table></figure><p>其<code>AST</code>形式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&quot;BinaryExpression&quot;</span>,</span><br><span class="line">  <span class="attr">operator</span>: <span class="string">&quot;===&quot;</span>,</span><br><span class="line">  <span class="attr">left</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;Identifier&quot;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;foo&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">right</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;Identifier&quot;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;bar&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，有<code>BinaryExpression</code>和<code>Identifier</code>两种节点。我们先从添加<code>BinaryExpression</code>访问者方法开始。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params">&#123; types: t &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">visitor</span>: &#123;</span><br><span class="line">      <span class="title class_">BinaryExpression</span>(path) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于源代码<code>foo === bar;</code>，我们可以更加精确一点，只关注操作符为 <code>===</code> 的<code>BinaryExpression</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">visitor</span>: &#123;</span><br><span class="line">  <span class="title class_">BinaryExpression</span>(path) &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.<span class="property">node</span>.<span class="property">operator</span> !== <span class="string">&quot;===&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，用新的标识符来替换<code>left</code>属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">BinaryExpression</span>(path) &#123;</span><br><span class="line">  <span class="keyword">if</span> (path.<span class="property">node</span>.<span class="property">operator</span> !== <span class="string">&quot;===&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用babel-types模块提供的方法</span></span><br><span class="line">  path.<span class="property">node</span>.<span class="property">left</span> = t.<span class="title function_">identifier</span>(<span class="string">&quot;cc&quot;</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，如果运行这个插件，则会将源代码转换成:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cc === bar;</span><br></pre></td></tr></table></figure><p>接下来，就剩下替换右边的标识符的工作了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">BinaryExpression</span>(path) &#123;</span><br><span class="line">  <span class="keyword">if</span> (path.<span class="property">node</span>.<span class="property">operator</span> !== <span class="string">&quot;===&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  path.<span class="property">node</span>.<span class="property">left</span> = t.<span class="title function_">identifier</span>(<span class="string">&quot;cc&quot;</span>);</span><br><span class="line">  path.<span class="property">node</span>.<span class="property">right</span> = t.<span class="title function_">identifier</span>(<span class="string">&quot;yy&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候运行这个插件，就能得到最终结果了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cc === yy;</span><br></pre></td></tr></table></figure><p>于是，轻松实现了第一个<code>Babel</code>插件！</p><h2 id="四、转换操作"><a href="#四、转换操作" class="headerlink" title="四、转换操作"></a>四、转换操作</h2><p>项目中需要用到的插件，应用场景往往没这么简单。因此，我们还得学会更多的操作，来使我们拥有能编写更强大的插件的能力。</p><h3 id="1-访问"><a href="#1-访问" class="headerlink" title="1. 访问"></a>1. 访问</h3><h4 id="1-1-获取子节点的-Path"><a href="#1-1-获取子节点的-Path" class="headerlink" title="1.1 获取子节点的 Path"></a>1.1 获取子节点的 <code>Path</code></h4><p>要得到一个<code>AST</code>节点的属性值，我们一般先访问到该节点，再通过<code>path.node.property</code>即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BinaryExpression AST 节点 有三个属性: `left`, `right`, `operator`</span></span><br><span class="line"><span class="title class_">BinaryExpression</span>(path) &#123;</span><br><span class="line">  path.<span class="property">node</span>.<span class="property">left</span>;</span><br><span class="line">  path.<span class="property">node</span>.<span class="property">right</span>;</span><br><span class="line">  path.<span class="property">node</span>.<span class="property">operator</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要访问到该属性内部的<code>path</code>，则需要用到<code>path</code>对象的<code>get</code>方法，传递该属性的字符串形式作为参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">BinaryExpression</span>(path) &#123;</span><br><span class="line">  path.<span class="title function_">get</span>(<span class="string">&#x27;left&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Program</span>(path) &#123;</span><br><span class="line">  <span class="comment">// 数字索引也是用 . 分隔</span></span><br><span class="line">  path.<span class="title function_">get</span>(<span class="string">&#x27;body.0&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-检查节点的类型"><a href="#1-2-检查节点的类型" class="headerlink" title="1.2 检查节点的类型"></a>1.2 检查节点的类型</h4><p>检查节点的类型可以通过<code>path.node</code>来进行，但是不建议这么做：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">BinaryExpression</span>(path) &#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    path.<span class="property">node</span>.<span class="property">left</span> != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">    path.<span class="property">node</span>.<span class="property">left</span>.<span class="property">type</span> === <span class="string">&quot;Identifier&quot;</span> &amp;&amp;</span><br><span class="line">    path.<span class="property">node</span>.<span class="property">left</span>.<span class="property">name</span> === <span class="string">&quot;n&quot;</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>推荐的做法是使用<code>babel-types</code>模块提供的方法来进行检查：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">BinaryExpression</span>(path) &#123;</span><br><span class="line">  <span class="keyword">if</span> (t.<span class="title function_">isIdentifier</span>(path.<span class="property">node</span>.<span class="property">left</span>, &#123; <span class="attr">name</span>: <span class="string">&quot;n&quot;</span> &#125;)) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-检查路径类型"><a href="#1-3-检查路径类型" class="headerlink" title="1.3 检查路径类型"></a>1.3 检查路径类型</h4><p>路径具有和<code>babel-types</code>提供的相同的检查方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">BinaryExpression</span>(path) &#123;</span><br><span class="line">  <span class="keyword">if</span> (path.<span class="title function_">get</span>(<span class="string">&#x27;left&#x27;</span>).<span class="title function_">isIdentifier</span>(&#123; <span class="attr">name</span>: <span class="string">&quot;n&quot;</span> &#125;)) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就相当于：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">BinaryExpression</span>(path) &#123;</span><br><span class="line">  <span class="keyword">if</span> (t.<span class="title function_">isIdentifier</span>(path.<span class="property">node</span>.<span class="property">left</span>, &#123; <span class="attr">name</span>: <span class="string">&quot;n&quot;</span> &#125;)) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-检查标识符-Identifier-是否被引用"><a href="#1-4-检查标识符-Identifier-是否被引用" class="headerlink" title="1.4 检查标识符(Identifier)是否被引用"></a>1.4 检查标识符(<code>Identifier</code>)是否被引用</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Identifier</span>(path) &#123;</span><br><span class="line">  <span class="keyword">if</span> (path.<span class="title function_">isReferencedIdentifier</span>()) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者使用<code>babel-types</code>提供的能力：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Identifier</span>(path) &#123;</span><br><span class="line">  <span class="keyword">if</span> (t.<span class="title function_">isReferenced</span>(path.<span class="property">node</span>, path.<span class="property">parent</span>)) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-5-找到特定的父路径"><a href="#1-5-找到特定的父路径" class="headerlink" title="1.5 找到特定的父路径"></a>1.5 找到特定的父路径</h4><p>有时候需要向上遍历<code>AST</code>，直到满足某些条件。</p><ul><li>以下方法，对于每一个父路径调用<code>cb</code>，当<code>cb</code>返回真值，则将其<code>NodePath</code>返回。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path.<span class="title function_">findParent</span>(<span class="function">(<span class="params">path</span>) =&gt;</span> path.<span class="title function_">isObjectExpression</span>());</span><br></pre></td></tr></table></figure><ul><li>如果是从当前节点开始遍历，则使用<code>find</code>方法：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path.<span class="title function_">find</span>(<span class="function">(<span class="params">path</span>) =&gt;</span> path.<span class="title function_">isObjectExpression</span>());</span><br></pre></td></tr></table></figure><ul><li>查找最临近的父函数或者程序：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path.<span class="title function_">getFunctionParent</span>();</span><br></pre></td></tr></table></figure><ul><li>向上遍历语法树，知道找到在列表中的父节点路径：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path.<span class="title function_">getStatementParent</span>();</span><br></pre></td></tr></table></figure><h4 id="1-6-查找同级路径"><a href="#1-6-查找同级路径" class="headerlink" title="1.6 查找同级路径"></a>1.6 查找同级路径</h4><p>当一个路径是在一个<code>Function/Program</code>中的列表里面，则它会有同级路径。</p><ul><li>使用 <code>path.inList</code> 可以判断是否有同级路径；</li><li>使用 <code>path.getSibling(index)</code>来获得同级路径;</li><li>使用 <code>path.key</code>获取路径在容器中的索引;</li><li>使用 <code>path.container</code>获取路径的容器（包含所有同级节点的数组）;</li><li>使用 <code>path.listKey</code>获取容器的key。</li></ul><p>在<code>transform-merge-sibling-variables</code>插件中使用到了这些<code>API</code>。</p><h4 id="1-7-停止遍历"><a href="#1-7-停止遍历" class="headerlink" title="1.7 停止遍历"></a>1.7 停止遍历</h4><p>如果需要插件在某些情况下不继续运作，应该尽早返回。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">BinaryExpression</span>(path) &#123;</span><br><span class="line">  <span class="keyword">if</span> (path.<span class="property">node</span>.<span class="property">operator</span> !== <span class="string">&#x27;**&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是在顶级的<code>path</code>中进行子遍历，则可以通过<code>path.skip</code>或者<code>path.stop</code>来停止遍历。</p><ul><li><code>path.skip</code>：跳过当前路径的子遍历；</li><li><code>path.stop</code>：停止当前路径的遍历（包括子遍历）。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">outerPath.<span class="title function_">traverse</span>(&#123;</span><br><span class="line">  <span class="title class_">Function</span>(innerPath) &#123;</span><br><span class="line">    innerPath.<span class="title function_">skip</span>(); <span class="comment">// if checking the children is irrelevant</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title class_">ReferencedIdentifier</span>(innerPath, state) &#123;</span><br><span class="line">    state.<span class="property">iife</span> = <span class="literal">true</span>;</span><br><span class="line">    innerPath.<span class="title function_">stop</span>(); <span class="comment">// if you want to save some state and then stop traversal, or deopt</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="2-处理"><a href="#2-处理" class="headerlink" title="2. 处理"></a>2. 处理</h3><p>在实际编写插件时，我们常需要进行各种增删改等处理。</p><h4 id="2-1-替换一个节点"><a href="#2-1-替换一个节点" class="headerlink" title="2.1 替换一个节点"></a>2.1 替换一个节点</h4><p>使用<code>path.replaceWith</code>来替换一个节点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">BinaryExpression</span>(path) &#123;</span><br><span class="line">  path.<span class="title function_">replaceWith</span>(</span><br><span class="line">    <span class="comment">// [operator, left, right]</span></span><br><span class="line">    t.<span class="title function_">binaryExpression</span>(<span class="string">&quot;**&quot;</span>, path.<span class="property">node</span>.<span class="property">left</span>, t.<span class="title function_">numberLiteral</span>(<span class="number">2</span>))</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  function square(n) &#123;</span><br><span class="line"><span class="deletion">-   return n * n;</span></span><br><span class="line"><span class="addition">+   return n ** 2;</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-用多节点来替换单节点"><a href="#2-2-用多节点来替换单节点" class="headerlink" title="2.2 用多节点来替换单节点"></a>2.2 用多节点来替换单节点</h4><p><code>path.replaceWithMultiple</code>方法用多节点来替换单个节点。注意，参数是声明数组。<strong>当用多个节点替换一个表达式时，它们必须是 声明</strong>。 这是因为<code>Babel</code>在更换节点时广泛使用启发式算法，这意味着您可以做一些非常疯狂的转换，否则将会非常冗长。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ReturnStatement</span>(path) &#123;</span><br><span class="line">  path.<span class="title function_">replaceWithMultiple</span>([</span><br><span class="line">    <span class="comment">// 声明（字符串字面量节点）</span></span><br><span class="line">    t.<span class="title function_">expressionStatement</span>(t.<span class="title function_">stringLiteral</span>(<span class="string">&quot;Is this the real life?&quot;</span>)),</span><br><span class="line">    t.<span class="title function_">expressionStatement</span>(t.<span class="title function_">stringLiteral</span>(<span class="string">&quot;Is this just fantasy?&quot;</span>)),</span><br><span class="line">    t.<span class="title function_">expressionStatement</span>(t.<span class="title function_">stringLiteral</span>(<span class="string">&quot;(Enjoy singing the rest of the song in your head)&quot;</span>)),</span><br><span class="line">  ]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  function square(n) &#123;</span><br><span class="line"><span class="deletion">-   return n * n;</span></span><br><span class="line"><span class="addition">+   &quot;Is this the real life?&quot;;</span></span><br><span class="line"><span class="addition">+   &quot;Is this just fantasy?&quot;;</span></span><br><span class="line"><span class="addition">+   &quot;(Enjoy singing the rest of the song in your head)&quot;;</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-用字符串源码替换节点"><a href="#2-3-用字符串源码替换节点" class="headerlink" title="2.3 用字符串源码替换节点"></a>2.3 用字符串源码替换节点</h4><p>使用<code>path.replaceWithSourceString</code>，将直接用源码字符串来替换当前节点(<strong>不建议使用</strong>)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">FunctionDeclaration</span>(path) &#123; </span><br><span class="line">path.<span class="title function_">replaceWithSourceString</span>(</span><br><span class="line">    <span class="string">`function add(a, b) &#123; </span></span><br><span class="line"><span class="string">return a + b; </span></span><br><span class="line"><span class="string">&#125;`</span></span><br><span class="line">  ); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- function square(n) &#123;</span></span><br><span class="line"><span class="deletion">-   return n * n;</span></span><br><span class="line"><span class="addition">+ function add(a, b) &#123;</span></span><br><span class="line"><span class="addition">+   return a + b;</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-插入兄弟节点"><a href="#2-4-插入兄弟节点" class="headerlink" title="2.4 插入兄弟节点"></a>2.4 插入兄弟节点</h4><p>使用<code>path.insertBefore</code>和<code>path.insertAfter</code>来在前或后一个位置插入兄弟节点。如果是<strong>插入单个节点，则使用声明，如果是插入多个节点，则应使用声明数组。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">FunctionDeclaration</span>(path) &#123; </span><br><span class="line">path.<span class="title function_">insertBefore</span>(</span><br><span class="line">t.<span class="title function_">expressionStatement</span>(</span><br><span class="line">t.<span class="title function_">stringLiteral</span>(<span class="string">&quot;Because I&#x27;m easy come, easy go.&quot;</span>)</span><br><span class="line">)</span><br><span class="line">); </span><br><span class="line">path.<span class="title function_">insertAfter</span>(</span><br><span class="line">t.<span class="title function_">expressionStatement</span>(</span><br><span class="line">t.<span class="title function_">stringLiteral</span>(<span class="string">&quot;A little high, little low.&quot;</span>)</span><br><span class="line">)</span><br><span class="line">); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+ &quot;Because I&#x27;m easy come, easy go.&quot;;</span></span><br><span class="line">  function square(n) &#123;</span><br><span class="line">    return n * n;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="addition">+ &quot;A little high, little low.&quot;;</span></span><br></pre></td></tr></table></figure><h4 id="2-5-插入到容器中"><a href="#2-5-插入到容器中" class="headerlink" title="2.5 插入到容器中"></a>2.5 插入到容器中</h4><p>在容器中插入节点和插入兄弟节点类似，只不过需要指定<code>listKey</code>。注意要使用声明。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ClassMethod</span>(path) &#123; </span><br><span class="line">path</span><br><span class="line">.<span class="title function_">get</span>(<span class="string">&#x27;body&#x27;</span>)</span><br><span class="line">.<span class="title function_">unshiftContainer</span>(</span><br><span class="line"><span class="string">&#x27;body&#x27;</span>, </span><br><span class="line">t.<span class="title function_">expressionStatement</span>(t.<span class="title function_">stringLiteral</span>(<span class="string">&#x27;before&#x27;</span>))</span><br><span class="line">);</span><br><span class="line">path</span><br><span class="line">.<span class="title function_">get</span>(<span class="string">&#x27;body&#x27;</span>)</span><br><span class="line">.<span class="title function_">pushContainer</span>(</span><br><span class="line"><span class="string">&#x27;body&#x27;</span>, </span><br><span class="line">t.<span class="title function_">expressionStatement</span>(t.<span class="title function_">stringLiteral</span>(<span class="string">&#x27;after&#x27;</span>))</span><br><span class="line">); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line"><span class="addition">+   &quot;before&quot;</span></span><br><span class="line">    var a = &#x27;middle&#x27;;</span><br><span class="line"><span class="addition">+   &quot;after&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="2-6-删除一个节点"><a href="#2-6-删除一个节点" class="headerlink" title="2.6 删除一个节点"></a>2.6 删除一个节点</h4><p>使用<code>path.remove</code>即可轻松删除当前节点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">FunctionDeclaration</span>(path) &#123;</span><br><span class="line">  path.<span class="title function_">remove</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- function square(n) &#123;</span></span><br><span class="line"><span class="deletion">-   return n * n;</span></span><br><span class="line"><span class="deletion">- &#125;</span></span><br></pre></td></tr></table></figure><h4 id="2-7-替换父节点"><a href="#2-7-替换父节点" class="headerlink" title="2.7 替换父节点"></a>2.7 替换父节点</h4><p>只需要获取到父节点的路径<code>parentPath</code>，然后调用<code>replaceWith</code>方法即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">BinaryExpression</span>(path) &#123;</span><br><span class="line">  path.<span class="property">parentPath</span>.<span class="title function_">replaceWith</span>(</span><br><span class="line">    t.<span class="title function_">expressionStatement</span>(</span><br><span class="line">      t.<span class="title function_">stringLiteral</span>(<span class="string">&quot;Anyway the wind blows, doesn&#x27;t really matter to me, to me.&quot;</span>))</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-8-删除父节点"><a href="#2-8-删除父节点" class="headerlink" title="2.8 删除父节点"></a>2.8 删除父节点</h4><p>获取父节点并执行<code>remove</code>方法即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">BinaryExpression</span>(path) &#123;</span><br><span class="line">  path.<span class="property">parentPath</span>.<span class="title function_">remove</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  function square(n) &#123;</span><br><span class="line"><span class="deletion">-   return n * n;</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="2-9-处理作用域"><a href="#2-9-处理作用域" class="headerlink" title="2.9 处理作用域"></a>2.9 处理作用域</h4><ul><li><code>path.scope.hasBinding()</code>：检查本地变量是否被绑定</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">FunctionDeclaration</span>(path) &#123;</span><br><span class="line">  <span class="keyword">if</span> (path.<span class="property">scope</span>.<span class="title function_">hasBinding</span>(<span class="string">&quot;n&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法会遍历范围树来检查特定的绑定。</p><ul><li><code>path.scope.hasOwnBinding()</code>：检查一个作用域是否有自己的绑定。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">FunctionDeclaration</span>(path) &#123;</span><br><span class="line">  <span class="keyword">if</span> (path.<span class="property">scope</span>.<span class="title function_">hasOwnBinding</span>(<span class="string">&quot;n&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>path.scope.generateUidIdentifierBasedOnNode</code>：创建<code>UID</code>。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">FunctionDeclaration</span>(path) &#123;</span><br><span class="line">  path.<span class="property">scope</span>.<span class="title function_">generateUidIdentifier</span>(<span class="string">&quot;uid&quot;</span>);</span><br><span class="line">  <span class="comment">// Node &#123; type: &quot;Identifier&quot;, name: &quot;_uid&quot; &#125;</span></span><br><span class="line">  path.<span class="property">scope</span>.<span class="title function_">generateUidIdentifier</span>(<span class="string">&quot;uid&quot;</span>);</span><br><span class="line">  <span class="comment">// Node &#123; type: &quot;Identifier&quot;, name: &quot;_uid2&quot; &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>path.scope.parent.push</code>：提升变量声明到父级作用域。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">FunctionDeclaration</span>(path) &#123;</span><br><span class="line">  <span class="keyword">const</span> id = path.<span class="property">scope</span>.<span class="title function_">generateUidIdentifierBasedOnNode</span>(path.<span class="property">node</span>.<span class="property">id</span>);</span><br><span class="line">  path.<span class="title function_">remove</span>();</span><br><span class="line">  path.<span class="property">scope</span>.<span class="property">parent</span>.<span class="title function_">push</span>(&#123; id, <span class="attr">init</span>: path.<span class="property">node</span> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- function square(n) &#123;</span></span><br><span class="line"><span class="addition">+ var _square = function square(n) &#123;</span></span><br><span class="line">    return n * n;</span><br><span class="line"><span class="deletion">- &#125;</span></span><br><span class="line"><span class="addition">+ &#125;;</span></span><br></pre></td></tr></table></figure><ul><li><code>path.scope.rename</code>：重命名绑定及其引用。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">FunctionDeclaration</span>(path) &#123;</span><br><span class="line">  path.<span class="property">scope</span>.<span class="title function_">rename</span>(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;x&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- function square(n) &#123;</span></span><br><span class="line"><span class="deletion">-   return n * n;</span></span><br><span class="line"><span class="addition">+ function square(x) &#123;</span></span><br><span class="line"><span class="addition">+   return x * x;</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>也可以将绑定重命名为唯一的标识符：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">FunctionDeclaration</span>(path) &#123;</span><br><span class="line">  path.<span class="property">scope</span>.<span class="title function_">rename</span>(<span class="string">&quot;n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- function square(n) &#123;</span></span><br><span class="line"><span class="deletion">-   return n * n;</span></span><br><span class="line"><span class="addition">+ function square(_n) &#123;</span></span><br><span class="line"><span class="addition">+   return _n * _n;</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="五、插件选项"><a href="#五、插件选项" class="headerlink" title="五、插件选项"></a>五、插件选项</h2><h3 id="1-插件选项的使用"><a href="#1-插件选项的使用" class="headerlink" title="1. 插件选项的使用"></a>1. 插件选项的使用</h3><p>接收插件选项，可以允许用户自定义插件的某些行为，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    [<span class="string">&quot;my-plugin&quot;</span>, &#123;</span><br><span class="line">      <span class="string">&quot;option1&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="string">&quot;option2&quot;</span>: <span class="literal">false</span></span><br><span class="line">    &#125;]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些选项通过状态参数<code>state</code>来传递给访问者。这些选项是特定于插件的，我们不能访问其它插件中的选项。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params">&#123; types: t &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">visitor</span>: &#123;</span><br><span class="line">      <span class="title class_">FunctionDeclaration</span>(path, state) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(state.<span class="property">opts</span>);</span><br><span class="line">        <span class="comment">// &#123; option1: true, option2: false &#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-插件的准备和收尾工作"><a href="#2-插件的准备和收尾工作" class="headerlink" title="2. 插件的准备和收尾工作"></a>2. 插件的准备和收尾工作</h3><p>插件可以具有在插件之前(<code>pre</code>)或之后(<code>post</code>)执行的函数，他们可用于设置或清理/分析的目的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params">&#123; types: t &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="title function_">pre</span>(<span class="params">state</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">cache</span> = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">visitor</span>: &#123;</span><br><span class="line">      <span class="title class_">StringLiteral</span>(path) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">set</span>(path.<span class="property">node</span>.<span class="property">value</span>, <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">post</span>(<span class="params">state</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">cache</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-在插件中启用其它语法"><a href="#3-在插件中启用其它语法" class="headerlink" title="3. 在插件中启用其它语法"></a>3. 在插件中启用其它语法</h3><p>插件可以启用<code>babylon plugins</code>，以便不需要用户来安装/启用他们。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params">&#123; types: t &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">inherits</span>: <span class="built_in">require</span>(<span class="string">&quot;babel-plugin-syntax-jsx&quot;</span>)</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以结合<code>babel-code-frame</code>来抛出错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params">&#123; types: t &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">visitor</span>: &#123;</span><br><span class="line">      <span class="title class_">StringLiteral</span>(path) &#123;</span><br><span class="line">        <span class="keyword">throw</span> path.<span class="title function_">buildCodeFrameError</span>(<span class="string">&quot;Error message here&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六。构建节点"><a href="#六。构建节点" class="headerlink" title="六。构建节点"></a>六。构建节点</h2><p>在编写转换时，往往需要构建一些要插入的节点进<code>AST</code>。可以使用<code>babel-types</code>包中的<code>builder</code>方法来简化操作。</p><p>构建器的方法名称就是我们想要的节点类型的名称，除了首字母小写。例如想建立一个<code>Identifier</code>则可以使用<code>t.identifier(...)</code>。这些构建器的参数由节点定义决定。</p><p>这里正好再复习一下节点定义的形式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">defineType</span>(<span class="string">&quot;MemberExpression&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">builder</span>: [<span class="string">&quot;object&quot;</span>, <span class="string">&quot;property&quot;</span>, <span class="string">&quot;computed&quot;</span>],</span><br><span class="line">  <span class="attr">visitor</span>: [<span class="string">&quot;object&quot;</span>, <span class="string">&quot;property&quot;</span>],</span><br><span class="line">  <span class="attr">aliases</span>: [<span class="string">&quot;Expression&quot;</span>, <span class="string">&quot;LVal&quot;</span>],</span><br><span class="line">  <span class="attr">fields</span>: &#123;</span><br><span class="line">    <span class="attr">object</span>: &#123;</span><br><span class="line">      <span class="attr">validate</span>: <span class="title function_">assertNodeType</span>(<span class="string">&quot;Expression&quot;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">property</span>: &#123;</span><br><span class="line">      <span class="title function_">validate</span>(<span class="params">node, key, val</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> expectedType = node.<span class="property">computed</span> ? <span class="string">&quot;Expression&quot;</span> : <span class="string">&quot;Identifier&quot;</span>;</span><br><span class="line">        <span class="title function_">assertNodeType</span>(expectedType)(node, key, val);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">computed</span>: &#123;</span><br><span class="line">      <span class="attr">default</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里附上<a href="https://github.com/babel/babel/tree/master/packages/babel-types/src/definitions">全部节点定义</a>。</p><h2 id="七、最佳实践"><a href="#七、最佳实践" class="headerlink" title="七、最佳实践"></a>七、最佳实践</h2><h3 id="1-创建-构建器-和-校验器-辅助函数"><a href="#1-创建-构建器-和-校验器-辅助函数" class="headerlink" title="1.创建 构建器 和 校验器 辅助函数"></a>1.创建 构建器 和 校验器 辅助函数</h3><p>将节点检验和节点类型抽离出来作为单独的函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isAssignment</span>(<span class="params">node</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> node &amp;&amp; node.<span class="property">operator</span> === opts.<span class="property">operator</span> + <span class="string">&quot;=&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">buildAssignment</span>(<span class="params">left, right</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> t.<span class="title function_">assignmentExpression</span>(<span class="string">&quot;=&quot;</span>, left, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-尽量避免遍历-AST"><a href="#2-尽量避免遍历-AST" class="headerlink" title="2. 尽量避免遍历 AST"></a>2. 尽量避免遍历 <code>AST</code></h3><p>遍历<code>AST</code>是一项消耗巨大的任务，应尽量避免不必要的<code>AST</code>遍历。</p><h3 id="3-及时合并访问者"><a href="#3-及时合并访问者" class="headerlink" title="3. 及时合并访问者"></a>3. 及时合并访问者</h3><p>另外，如果合并后能子一次遍历中完成多个访问者的工作，那就将访问者合并到一起。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">path.<span class="title function_">traverse</span>(&#123;</span><br><span class="line">  <span class="title class_">Identifier</span>(path) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">path.<span class="title function_">traverse</span>(&#123;</span><br><span class="line">  <span class="title class_">BinaryExpression</span>(path) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>以上可以合并到一个<code>visitor</code>中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">path.<span class="title function_">traverse</span>(&#123;</span><br><span class="line">  <span class="title class_">Identifier</span>(path) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title class_">BinaryExpression</span>(path) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="4-优化嵌套的访问者对象"><a href="#4-优化嵌套的访问者对象" class="headerlink" title="4. 优化嵌套的访问者对象"></a>4. 优化嵌套的访问者对象</h3><p>将访问者进行嵌套往往是有意义的，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MyVisitor</span> = &#123;</span><br><span class="line">  <span class="title class_">FunctionDeclaration</span>(path) &#123;</span><br><span class="line">    path.<span class="title function_">traverse</span>(&#123;</span><br><span class="line">      <span class="title class_">Identifier</span>(path) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是，每当调用<code>FunctionDeclaration()</code>时，都会创建一个新的访问者对象。因此，将该访问者保存在一个变量里进行复用，可以减少开销。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nestedVisitor = &#123;</span><br><span class="line">  <span class="title class_">Identifier</span>(path) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MyVisitor</span> = &#123;</span><br><span class="line">  <span class="title class_">FunctionDeclaration</span>(path) &#123;</span><br><span class="line">    path.<span class="title function_">traverse</span>(nestedVisitor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果嵌套的访问者中需要一些状态:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MyVisitor</span> = &#123;</span><br><span class="line">  <span class="title class_">FunctionDeclaration</span>(path) &#123;</span><br><span class="line">    <span class="keyword">var</span> exampleState = path.<span class="property">node</span>.<span class="property">params</span>[<span class="number">0</span>].<span class="property">name</span>;</span><br><span class="line"></span><br><span class="line">    path.<span class="title function_">traverse</span>(&#123;</span><br><span class="line">      <span class="title class_">Identifier</span>(path) &#123;</span><br><span class="line">        <span class="comment">// 需要状态</span></span><br><span class="line">        <span class="keyword">if</span> (path.<span class="property">node</span>.<span class="property">name</span> === exampleState) &#123;</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以将状态通过<code>traverse</code>方法来传递，在内嵌的<code>visitor</code>中就可以通过<code>this</code>来访问：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nestedVisitor = &#123;</span><br><span class="line">  <span class="title class_">Identifier</span>(path) &#123;</span><br><span class="line">    <span class="comment">// 嵌套的visitor可以通过this来访问状态</span></span><br><span class="line">    <span class="keyword">if</span> (path.<span class="property">node</span>.<span class="property">name</span> === <span class="variable language_">this</span>.<span class="property">exampleState</span>) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MyVisitor</span> = &#123;</span><br><span class="line">  <span class="title class_">FunctionDeclaration</span>(path) &#123;</span><br><span class="line">    <span class="keyword">var</span> exampleState = path.<span class="property">node</span>.<span class="property">params</span>[<span class="number">0</span>].<span class="property">name</span>;</span><br><span class="line">    <span class="comment">// traverse传递状态</span></span><br><span class="line">    path.<span class="title function_">traverse</span>(nestedVisitor, &#123; exampleState &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>事实上，可以优化的点还有不少，例如结构嵌套、手动查找代替遍历等，以及对<code>Babel</code>插件进行单元测试等，就不在此展开了。掌握了这些知识，想必写出一个符合需要的<code>Babel</code>插件也不再是什么难事。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Babel </tag>
            
            <tag> 前端工程化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ade, 武汉</title>
      <link href="/articals/71570a99/"/>
      <url>/articals/71570a99/</url>
      
        <content type="html"><![CDATA[<script src=/js/crypto-js.js></script><script>function doDecrypt (pwd, onError) {console.log('in doDecrypt');const txt = document.getElementById('enc_content').innerHTML;let plantext;try {const bytes = CryptoJS.AES.decrypt(txt, pwd);var plaintext = bytes.toString(CryptoJS.enc.Utf8);} catch(err) {if(onError) {onError(err);}return;}document.getElementById('enc_content').innerHTML = plaintext;document.getElementById('enc_content').style.display = 'block';document.getElementById('enc_passwd').style.display = 'none';if(typeof MathJax !== 'undefined') {MathJax.Hub.Queue(['resetEquationNumbers', MathJax.InputJax.TeX],['PreProcess', MathJax.Hub],['Reprocess', MathJax.Hub]);}}</script><div id="enc_content" style="display:none">U2FsdGVkX1+X19/AQU8sRH2mwDIWBHI13VkhLNP7k5Cl/Q6azormqYR+Pe39NSa0P2C/hplw4sFaorRxQsWExfv66enBnFcymdhk5esxiGBYXWOG0pghnzCBjadpLDJNQaBnh7HHr5ZoVxrVsaZPgntWyYgtgepq0MjGfd26vXKmRsC52CdpcHM8gBQ2Em2Jt35joplPH7LTsVvKomgt5f0V6A5EBaX7SBbmGZQeWQSEWkc7dElx8Kcxl5Oe3MQK72xXc2BZF4aLxddu3JGirXnEo4MhPm2pw0W45cr9Kl3vkuhB7dKefbM2pCSHoIIQ5ZpPR10dLt5wEZWyo/NtWUEMlsFkW+/u1uE4A/+o7TK3ftoNS6FlwCJwKkZdTldMVHhITb3qg1IwVDYO4YCX9AgvoVChLLTTs4ACUMhaJwiMpNw53+d6BCoBsJyW2shkrY5iSi68gq58aSfUd2t5v8Vj+zLLBsvnWw1/4vMHLo2WoD+D+ABGYKOjjn5jRg5XlsC8HPNIyG4VuOPYWY+dTdnckyvAQ079GifooKbjXs12hRT0a0VhdHY2kGZ5+6sWBvrQVdzc5/NPlwpNOGnoxqlL6PmqwD3krKw15ktYwrtOsV6nXas1g6RDOIQEr067eFdcA+UEsmYImUzRqChsE77ztwCOifT4bNVsEcgCqd6CLADXyWCELrusU7FZaYgxpHNKdzDfkhy52HgLPEzcnYvxyf7VsVdZg/MVa85OExi6dNMWflyK3k7Udhn1/4cv3OAkkOS2wc0p7m+ucC4WMnFvbDF8Hpl+yFsp3JEzcoE0DmzFseeDNcqcQkMDGO972MUBQRLA+HRLjuKOi9l8tsoVLjwRkm5twTRYLmCf+l/P4zsHrPg1mvT7p+O1grmqE5MSvyfKfMHnqMSn0q/5MXphu023KOegOw7sfLYzby0z6if8THj5ClFtU7S4tMYE9txBk56wbr/AdETtKqJ9WDvay9cHEa71Fs4SwQNWGq4SwO7rguH7Li5J0PCIcNH+my2ojTd6mjtqT/lO5nlNzJ7rSsgo9Sm6jhTiReFmT2DOXKOr3iR+UQwhc0IMZ/eFc0wQB3BnBxz+0fXJxIH6xEI8DpwfCHh++JD36mOyNVzCtpgwvjrU2vFD1tl0ZOfbJ36h8HKFOoX6G6kbZIStFp+rjpEoGwgQ1pcd7pUxfXc/ZG7EHxUeeOe+iLRRbLjPJE7lbv6REOtYz+6hUZhPBVmOr2cL0c0ruE0rofGxsnTzjN93OUD1BfTHGIubVD2jnOX+qfSB6ymdNoB3jVk1ENDD8bKkhU/BgkhuflmtwwuZv4GGWl+RAbEtqzfVtp2qda78KhCKh9Xvyv+OAeCbNZPqK+ea+s8RQL1Civ5jnjXmFmhnnGmQMAmonOS0ZVjHnkzSX9uByzJJu+tbytsc1Z00VCOkWOCAVP2Jtbd8iIemlCQKF3Evw10KzqYDlXWzCoktmULZQsAO+ZSKxE9Is0S3Oc4U+vtu+2KVNptEyCpTOxLNKC4J66GivTUYjul/quinSSV1KF2y5Ox4Q1xDrnZ3rvki+96s1m2rYnSyDj0EdhFXarTUBW+Yh4DCL5hdb7kmjP6626d+eOPvHU1Csbwe6F0NCmFYxbPg4kl/ctETt9eC+iaCaH6lN3Bb3Zw/4maW+3PuMA11zVo7Z8McK3BQ82WckNz3mro2zW/xZHSu8Vm+6Fn2QXsJDoI75/0SySDF5srNsza/tuiXKtN8SX49xd6d59kCujdZUf/3dWG+QOeK1Uv9O2SfbHRChGADbGt6YlMmmyPv+nbBpbPZ5YClnBfl2HSEJo82wGTEMHMBz2yapAdRDE3IURNffdCrWqyCIxYQB+FIB0Vzv+ntrdejWoB8vegh+Rn5moHq0T6nXSIuKR5c1UDO8EEgywGvoddiUa3CrUUTe9rmtwWkt6PzRcSCQGcZrzK29mtDx3dCPkiBPbasJseg83LwSWYfw4/kue4FadpPPvvgc+7KUR1BPz09SC96bv+2uqZQdQZLYNT2V8YZBjF9w7wiKxQqL//bVfgXKDlDIcXbSclqwjmq8aet0AduRoMakYrwZKK3yNSLKBJ/SrGG+nPZ5M8J</div><div id="enc_passwd"> <h1>本页面不对外公开哦, 需要密码才能阅读~</h1> <h2>ps: 如果是你的话,应该能猜到这个8位数密码。</h2> <input type="text" autofocus style="text-align: center;border-radius: 5px;border-style: groove;height: 30px;width: 100px;cursor: auto;font-size: 100%;font-weight: 700;margin: 0 20px 0 30%;color: #137cbd;box-shadow: #182026 1px 1px 3px;border:none;outline: none;outline: none;text-overflow: initial;"> <input type="submit" value="确 定" onclick="decrypt()" style="width: 58px;height: 34px;border-radius: 5px;background-color: #13b3ff;box-shadow: #182026 1px 1px 3px;border: none;color: white;"> <div id="enc_error" style=" display: inline-block; color: #d84527; font: large; "></div> <script> const onError = function(error) { document.getElementById("enc_error").innerHTML = "密码不对啦！偷看别人隐私是不礼貌的哦~"; }; function decrypt() { const passwd = document.querySelector("#enc_passwd input").value; doDecrypt(passwd, onError); } </script> </div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>临冬随笔</title>
      <link href="/articals/71570a95/"/>
      <url>/articals/71570a95/</url>
      
        <content type="html"><![CDATA[<script src=/js/crypto-js.js></script><script>function doDecrypt (pwd, onError) {console.log('in doDecrypt');const txt = document.getElementById('enc_content').innerHTML;let plantext;try {const bytes = CryptoJS.AES.decrypt(txt, pwd);var plaintext = bytes.toString(CryptoJS.enc.Utf8);} catch(err) {if(onError) {onError(err);}return;}document.getElementById('enc_content').innerHTML = plaintext;document.getElementById('enc_content').style.display = 'block';document.getElementById('enc_passwd').style.display = 'none';if(typeof MathJax !== 'undefined') {MathJax.Hub.Queue(['resetEquationNumbers', MathJax.InputJax.TeX],['PreProcess', MathJax.Hub],['Reprocess', MathJax.Hub]);}}</script><div id="enc_content" style="display:none">U2FsdGVkX1+0vyWVplu53qxLa1RnUtRg67Qoth9AuNylxABFG3n+DnbnurEP+mRR4pWpdUSnck4At63N845SOkNLH6S21c7vBg/1aXoyhrHvW5vbQgQHdDZ76lXg8ZL/z5nsIQtRiVmXx2AUNsEnldK8cArFGIaSac3fqlLAKFd5iUUbSpoLSqcQOnQwZq7oIRqZOPqQ0xyXfYSLWzq2uOqYxEjkVbhd8XUJvWdl6HeMLEwxYa+Ig3om7+j8xGtcHSobnZwa8rJeMveung0XGN0h676KjycQfum0qnlvIZGBQx6g33V1egcJMctb8Ekrl+3RbMYPbDID4reIJEvpnbo85qg+w/pEU82yHfvO25jrfNGBdi9/O93f2wZktuioFKFzUHkTkpvZGqFl5fVzMlkn9XFEUGsLhWACthFdeU2X+BCRR7bJTs2D7UL1CT4w7E5wDTFLTg3JdSeVCjzoaLGd+yM5neCRzUvu70rJ6EJgrOHSyAm7Saum2b7dAd/rkybYjfwL2T4iwQb+3W7ty+6qmA1GUYDIOPZR86+KI2UZET+8y9UVoJiMDagbXrIqBj6haMF44wXzb5Gqk8cb83+ht7DRu+2Cg73rChjT9jm2Vx0eiEk+FgVdKfAEIF38O9knQhLmp4xDfX1/1Db894rAFX0N5q/TCg3tWg7XG1++2EozwCYATT9zLkjw3eg9m4TsY8osorg6pxYTSG8CE6/pXQ3kLqCUoG++jbS1f73uWq66rdCH7/1zyVBFlH6IfhLCd9tZPIwI28BU9lGW0gkwVIIB0DnvQlZGUzR7xqRtPHIryzv6IDW9daA4bypYYGqggxSZJCmX5DGx6b1cp/Pbmo8tdMkRaZrIbGDJxl2OwpmCPxYA1+47ZZr3ZoPneAhXtQlLXWJR2Z4aW5NCkEPbRBPl9JYKXhGUFQng057AuBY/Csa0oDL9kximfCGWXT7E37Q/ddPZdMSzf/HPxNftyXg3NnA5GVnII+vuNvIDDEruhR0KNjCYVKJSDO/cEyewln4ioRYmuZPRnHpHvoreJX3VuTigGdH3zEjDHCxA/HdyF4/gNhQsgbsiTc3I56i79c1d4EqxxKWGj2zFh6zVJ0IASwLScQM5XeWN8VKeDApFG+xbqJ/FN66211hwyaX6dsh00AzseaPFmXvCiw2L2iurxPnLIX0dewxxeWXelRsmxndZ75vFmw6pB1bIOS9bG5yek/RkTzHffZp8CyDoNIO4MFt3fk5quGdGM8I7Xg/xzLluqr5FizbFFgtHaTSX1yIQsvGwlvhAnuFJziIG99PsfE0EHx+lzRzxb0OOY7HwBQL6YF2DhMnnSqlTTc5EYqA/B2I5o3nt129YE1FlvJ+LrqPg2DArAFpjPTrL6HglTRBDEqZlRwhhxVRbuW1fYG9uoKlZ9ZTMa3z9rnMQEI0B30mjqn13BIJ/91ZVrPuQ0xJabbOF3Dqw2LGEtXBkBEcsp9P7AaMRnbLFGXQqTfpsh15fZVxfT/+tFw7JO/tgsQD+IdT25xv55HKFyy1OC43Esez9Z5tMBqS/et9F1+m9sZPod2+X//4LL7HezNtjspbwW40xeHgzEdGrMO4rXurVph3O4uZe2xKSewUfn6+VTkQbwKGUzVLsDf/igaE888ZRdjLzVyRJESM7n/T3RLysgRUK0U6OrD0LVRDRRAkMEN+fj/SsA9f+xwZ02q5sDbtCU/MATkTGlsQM0S3St9PdvG3zxAz6DtYUdZ8z24l7XLWDogKnjp1+PEJhLT96feSmYoNcyBZMrWm6S9oaaZX+Is4Lw3kY01z9YOy1tkR7c2ZkB+WShDkQ7HtT0O+WMR+t7iSu2meNHgT3VB6KKx+TYkiHyRAIJqVTRke9MmRs0sy6AFZId/e0UrTRTyjPyB/VL2urj6GSVGcUd7rLc9HudmmL2FIDKXNmmT35ILGrRrbOv3x+kJrQl6ZIcyMtLwfZ0ib3zrjqoAVCOvvGcLX/AeVY4n7mfAxkmdPAxg7Za9SgisomagSCKJnlux4Og8g54MByXuPRoxx7NKbVNuFED1cDT+5vPZZJMqT8vzxYTql64srm71DEISKOiIlbh17mwIV9atGWSgIPdJAg3Zj0YZdTOtY/VKhlmOHlL3/bZ6P93saW6kiuLasZi9St6mLmzbinFXCxsuTcq1FFKhlSxBIMMc2LgaUjo4AtatBJJonScpnbH7DfNY8+HBAwkPjhPGKAUGgKkYvN1h6ApGPkxY8b26fF07lbyLimo72bCuG50xzEhiunVRc3AHLdWepW9EH7kH37G4ZJ8NsQqM5VnT93IxkVWvP6x3IDAYNY+oQVCuh7hL36Xbb/hUMg0pFRCgcKhEIpnWEClw+gvITZthsQugbQD4Gj7OU7QkxWtAmhy2XQOBFu+1KIPDH39U5sOkxSXUN3DFQuvoPqioUwUIBU7m4wKXYqxbW3SVE3rZXq16RUU+7HTSr9BYfev/d5UNFaawRSwUncHc95KeUU4Qtr8SxBBsG0gGR9eS9FMa2adlI+2r+wRhEYpOTYvdPMrk7597eiPhtvQsanxjpBTef5oAtu/3FrGLAVcmW1eNQSKufbvny7UP92b/vTQ+oYzh0j90ZXWVjWuGi6acuOrxSP8OqMQ3aKXBZeTvjEl8Qz45yZrPUiZBw=</div><div id="enc_passwd"> <h1>本页面不对外公开哦, 需要密码才能阅读~</h1> <h2>ps: 如果是你的话,应该能猜到这个8位数密码。</h2> <input type="text" autofocus style="text-align: center;border-radius: 5px;border-style: groove;height: 30px;width: 100px;cursor: auto;font-size: 100%;font-weight: 700;margin: 0 20px 0 30%;color: #137cbd;box-shadow: #182026 1px 1px 3px;border:none;outline: none;outline: none;text-overflow: initial;"> <input type="submit" value="确 定" onclick="decrypt()" style="width: 58px;height: 34px;border-radius: 5px;background-color: #13b3ff;box-shadow: #182026 1px 1px 3px;border: none;color: white;"> <div id="enc_error" style=" display: inline-block; color: #d84527; font: large; "></div> <script> const onError = function(error) { document.getElementById("enc_error").innerHTML = "密码不对啦！偷看别人隐私是不礼貌的哦~"; }; function decrypt() { const passwd = document.querySelector("#enc_passwd input").value; doDecrypt(passwd, onError); } </script> </div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Babel使用指南</title>
      <link href="/articals/b71a7a8/"/>
      <url>/articals/b71a7a8/</url>
      
        <content type="html"><![CDATA[<p>我们知道，<code>ES6+</code>语法目前尚未被各大浏览器全面支持，且<code>ES</code>语法新特性也在逐年增加。若想在项目中愉快地使用较新版本的<code>ES</code>语法，那就需要工具来对我们的代码里的语法进行 “降级” 处理。这里附上<strong><a href="https://babeljs.io/">Babel 官网</a></strong>。依照官网的介绍，<code>Babel</code>便是这么一个我们需要的工具链，能够将使用<code>ES6+</code>语法编写的代码转换为向后兼容的<code>ES</code>语法。除了语法转换，<code>Babel</code>还能以<code>Polyfill</code>的方式向目标环境中添加特性以及完成源码转换等功能。</p><h2 id="一、基本使用"><a href="#一、基本使用" class="headerlink" title="一、基本使用"></a>一、基本使用</h2><p>首先要明确的是，<code>Babel</code>是一个工具链，由许许多多的工具组成。这里简要介绍一下<code>Babel</code>工具的使用，使得我们的<code>ES6+</code>语法的代码被处理成能够在浏览器上运行的代码。</p><h3 id="1-Babel-初体验"><a href="#1-Babel-初体验" class="headerlink" title="1. Babel 初体验"></a>1. <code>Babel</code> 初体验</h3><h4 id="1-1-安装依赖"><a href="#1-1-安装依赖" class="headerlink" title="1.1 安装依赖"></a>1.1 安装依赖</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev @babel/core @babel/cli @babel/preset-env</span><br></pre></td></tr></table></figure><h4 id="1-2-编写配置文件"><a href="#1-2-编写配置文件" class="headerlink" title="1.2 编写配置文件"></a>1.2 编写配置文件</h4><p>在项目的根目录下创建<code>babel.config.json</code>文件(<code>Babel</code>版本<code>&gt;= v7.8.0</code>)，并编写(复制)以下内容：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;presets&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">[</span></span><br><span class="line">      <span class="string">&quot;@babel/preset-env&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;targets&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;edge&quot;</span><span class="punctuation">:</span> <span class="string">&quot;17&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;firefox&quot;</span><span class="punctuation">:</span> <span class="string">&quot;60&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;chrome&quot;</span><span class="punctuation">:</span> <span class="string">&quot;67&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;safari&quot;</span><span class="punctuation">:</span> <span class="string">&quot;11.1&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;useBuiltIns&quot;</span><span class="punctuation">:</span> <span class="string">&quot;usage&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;corejs&quot;</span><span class="punctuation">:</span> <span class="string">&quot;3.6.5&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>如果是旧版本的<code>Babel</code>，则配置文件应是一个<code>js</code>文件，命名为<code>babel.config.js</code>，相应的内容也有所差别：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> presets = [</span><br><span class="line">  [</span><br><span class="line">    <span class="string">&quot;@babel/preset-env&quot;</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">targets</span>: &#123;</span><br><span class="line">        <span class="attr">edge</span>: <span class="string">&quot;17&quot;</span>,</span><br><span class="line">        <span class="attr">firefox</span>: <span class="string">&quot;60&quot;</span>,</span><br><span class="line">        <span class="attr">chrome</span>: <span class="string">&quot;67&quot;</span>,</span><br><span class="line">        <span class="attr">safari</span>: <span class="string">&quot;11.1&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">useBuiltIns</span>: <span class="string">&quot;usage&quot;</span>,</span><br><span class="line">      <span class="attr">corejs</span>: <span class="string">&quot;3.6.4&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123; presets &#125;;</span><br></pre></td></tr></table></figure><h4 id="1-3-编译"><a href="#1-3-编译" class="headerlink" title="1.3 编译"></a>1.3 编译</h4><p>我们知道，<code>npm</code>在安装<code>cli</code>依赖时，会根据依赖包中的<code>package.json</code>文件里的<code>bin</code>字段，在<code>/node_modules/.bin/</code>目录下创建相应的文件以及软链接，于是，<code>@babel/cli</code>使得我们可以在命令行运行相应的命令。我们在命令行运行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./node_modules/.bin/babel src --out-dir lib</span><br></pre></td></tr></table></figure><p>就可以将<code>src</code>目录下的<code>js</code>文件编译并输出到<code>lib</code>目录。当然，更简洁的命令是<code>npx babel src --out-dir lib</code>。</p><h3 id="2-cli-命令行的基本使用"><a href="#2-cli-命令行的基本使用" class="headerlink" title="2. cli 命令行的基本使用"></a>2. <code>cli</code> 命令行的基本使用</h3><p>事实上，每个<code>Babel</code>模块都是一个独立的<code>npm</code>包，而从版本<code>7</code>开始，包的名字都是以<code>@babel</code>开始。下面简要介绍一下核心库<code>@babel/core</code>和命令行工具<code>@babel/cli</code>。</p><h4 id="2-1-babel-core"><a href="#2-1-babel-core" class="headerlink" title="2.1 @babel/core"></a>2.1 <code>@babel/core</code></h4><p><code>@babel/core</code>是<code>Babel</code>的核心模块，包含了<code>Babel</code>的核心功能。</p><p>安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev @babel/core</span><br></pre></td></tr></table></figure><p>可以在<code>js</code>程序中直接使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">&quot;@babel/core&quot;</span>);</span><br><span class="line"></span><br><span class="line">babel.<span class="title function_">transformSync</span>(<span class="string">&quot;code&quot;</span>, optionsObject);</span><br></pre></td></tr></table></figure><p>当然，我们通常不会这么做，而是安装其它的<code>Babel</code>工具并集成到开发流程中。不过，熟悉它的文档依旧十分重要，这不仅能帮助我们理解其它的<code>babel</code>工具，而且我们如果要自制一个<code>Babel</code>插件，也自然离不开<code>@babel/core</code>。</p><h4 id="2-2-babel-cli"><a href="#2-2-babel-cli" class="headerlink" title="2.2 @babel/cli"></a>2.2 <code>@babel/cli</code></h4><p><code>@babel/cli</code>是<code>Babel</code>的命令行工具，为我们提供了在命令行使用<code>Babel</code>的能力。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装cli</span></span><br><span class="line">npm install --save-dev @babel/core @babel/cli</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在命令行使用</span></span><br><span class="line">npx babel src --out-dir lib</span><br></pre></td></tr></table></figure><p>以上两条分明分别是安装和在命令行使用<code>Babel</code>的示例。</p><h3 id="3-插件-plugin-和-预设-preset"><a href="#3-插件-plugin-和-预设-preset" class="headerlink" title="3. 插件 plugin 和 预设 preset"></a>3. 插件 <code>plugin</code> 和 预设 <code>preset</code></h3><p><strong>插件<code>plugin</code>是利用<code>@babel/core</code>写的小型<code>js</code>程序，用于指示<code>Babel</code>如何将<code>js</code>代码进行编译</strong>。除了官方提供的许多插件之外，也可以按需制定自己的插件。一般来说，一个插件实现一个单独的能力，例如<code>@babel/plugin-transform-arrow-functions</code>可以将箭头函数转化为普通函数。然而，对于层出不穷的新特性，如果一个一个去安装使用单独的插件，无疑会给我们这些用户戴上痛苦面具。好在，我们还有预设<code>preset</code>可以使用。<strong>预设是一组预先设定的插件</strong>，使用预设，就不用去一个一个去添加插件了。</p><p>例如，使用最常用的预设：<code>@babel/preset-env</code> 来指定针对目标环境的编译。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装预设</span></span><br><span class="line">npm install --save-dev @babel/preset-env</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过--presets= 来指定预设</span></span><br><span class="line">npx babel src --out-dir lib --presets=@babel/env</span><br></pre></td></tr></table></figure><p>当没有进行参数配置时，这个预设能支持所有最新的<code>ES</code>语法的编译。我们也可以传递参数来进行配置。</p><h3 id="4-babel-配置"><a href="#4-babel-配置" class="headerlink" title="4. babel 配置"></a>4. <code>babel</code> 配置</h3><p>如果使用命令行传参来进行配置，一来没有可复用性，二来参数太多也不便阅读。因此，可以使用配置文件。</p><p>前面提到过，对于<code>7.8.0</code>及更高的版本，配置文件是<code>babel.config.json</code>；而旧版本是<code>babel.config.js</code>。以如下配置文件为示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;presets&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">[</span></span><br><span class="line">      <span class="string">&quot;@babel/preset-env&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;targets&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;edge&quot;</span><span class="punctuation">:</span> <span class="string">&quot;17&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;firefox&quot;</span><span class="punctuation">:</span> <span class="string">&quot;60&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;chrome&quot;</span><span class="punctuation">:</span> <span class="string">&quot;67&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;safari&quot;</span><span class="punctuation">:</span> <span class="string">&quot;11.1&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>其中，<code>targets</code>字段指定了目标浏览器，则该预设只会为目标浏览器中没有的功能加载转换插件。</p><h3 id="5-Polyfill垫片"><a href="#5-Polyfill垫片" class="headerlink" title="5. Polyfill垫片"></a>5. <code>Polyfill</code>垫片</h3><p>事实上，从<code>Babel 7.4.0</code>版本开始，就不建议使用这个包了，推荐的做法是直接包含<code>core-js/stable</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install --save core-js/stable</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;core-js/stable&#x27;</span></span><br></pre></td></tr></table></figure><p>回归正题，<code>@babel/polyfill</code>模块包含<code>core-js</code>以及一个自定义的<code>generator runtime</code>来模拟完整的<code>ES6+</code>环境(全局添加各种新语法的<code>API</code>)，从而让我们可以使用<code>Map</code>、<code>Promise</code>、<code>Array.from</code>等。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save @babel/polyfill</span><br></pre></td></tr></table></figure><p>这样仍有缺陷，对于那些已支持部分新<code>API</code>特性的环境，垫片会造成污染。好在，<code>env</code>这个预设中提供了<code>&quot;useBuiltIns&quot;</code>参数，将其指定为<code>&quot;usage&quot;</code>，可以让垫片模块先进行环境检测，只加载环境中缺失的那些<code>API</code>。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;presets&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">[</span></span><br><span class="line">      <span class="string">&quot;@babel/preset-env&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;targets&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;edge&quot;</span><span class="punctuation">:</span> <span class="string">&quot;17&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;firefox&quot;</span><span class="punctuation">:</span> <span class="string">&quot;60&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;chrome&quot;</span><span class="punctuation">:</span> <span class="string">&quot;67&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;safari&quot;</span><span class="punctuation">:</span> <span class="string">&quot;11.1&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;useBuiltIns&quot;</span><span class="punctuation">:</span> <span class="string">&quot;usage&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>如果不将<code>&quot;useBuiltIns&quot;</code>指定为<code>&quot;usage&quot;</code>，则我们需要在所有代码运行前，先利用<code>require</code>加载一次完整的<code>polyfill</code>，由于<code>@babel/polyfill</code>的弃用，我们可以使用<code>core-js/stable</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &quot;core-js/stable&quot;;</span><br></pre></td></tr></table></figure><h3 id="6-小结"><a href="#6-小结" class="headerlink" title="6. 小结"></a>6. 小结</h3><ul><li><code>@babel/core</code> 提供了<code>Babel</code>的核心能力；</li><li><code>@babel/cli</code>提供了在命令行使用<code>Babel</code>的能力；</li><li><code>@babel/polyfill</code> 能够模拟完整的<code>ES6+</code>的功能；</li><li><code>@babel/presets-env</code>：指定环境，可以让<code>Babel</code>只对我们所使用的且目标浏览器中缺失的功能加载<code>Polyfill</code>以及代码转换。</li></ul><h2 id="二、Babel配置文件"><a href="#二、Babel配置文件" class="headerlink" title="二、Babel配置文件"></a>二、<code>Babel</code>配置文件</h2><h3 id="1-配置文件"><a href="#1-配置文件" class="headerlink" title="1. 配置文件"></a>1. 配置文件</h3><p><code>Babel</code>在根目录(默认情况下为当前工作目录<code>cwd</code>)查找配置文件时，<code>babel.config.*</code>是整个项目内生效的，而<code>.babelrc.*</code>则是只对当前<code>package</code>中生效，对次级<code>package</code>无效。因此，可以根据使用场景进行选择。</p><ul><li>如果采用的是单一仓库模式(<code>monorepo</code>)，或者需要对<code>node_modules</code>进行编译，则建议使用<code>babel.config.json</code>作为配置文件；</li><li>如果配置文件仅需用于项目的一部分，则用<code>.babelrc.json</code>作为配置文件更适合。</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;presets&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>...<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;plugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>...<span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>如果配置需要与<code>js</code>代码结合，则使用<code>babel.config.js</code>或者<code>.babelrc.js</code>作为配置文件：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> presets = [ ... ];</span><br><span class="line"><span class="keyword">const</span> plugins = [ ... ];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123; presets, plugins &#125;;</span><br></pre></td></tr></table></figure><ul><li>此外，也可以将<code>Babel</code>的配置写在<code>package.json</code>里，效果同<code>babelrc.json</code>：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;my-package&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;babel&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;presets&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> ... <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;plugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> ... <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="2-js配置文件API"><a href="#2-js配置文件API" class="headerlink" title="2. js配置文件API"></a>2. <code>js</code>配置文件<code>API</code></h3><p>使用<code>.js</code>配置文件时，导出的可以是一个函数，函数中可以使用<code>Babel</code>提供的<code>API</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> (<span class="params">api</span>) &#123;</span><br><span class="line">  <span class="comment">// 返回配置，这里配置是空的</span></span><br><span class="line">  <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-1-api-version"><a href="#2-1-api-version" class="headerlink" title="2.1 api.version"></a>2.1 <code>api.version</code></h4><p>可以得到加载配置文件的<code>Babel</code>的版本(字符串)。</p><h4 id="2-2-api-cache"><a href="#2-2-api-cache" class="headerlink" title="2.2 api.cache"></a>2.2 <code>api.cache</code></h4><p>当<code>.js</code>配置文件导出的是函数时，<code>Babel</code>每次都要重新执行一边该函数，显然浪费性能。我们可以通过<code>api.cache</code>来缓存函数的执行结果，从而避免重新执行该函数。有多种缓存策略可选：</p><ul><li><code>api.cache.forever()</code>：永久性缓存，函数不会执行第二次；</li><li><code>api.cache.never()</code>：永不缓存，该函数每次都要重新执行；</li><li><code>api.cache.using(() =&gt; process.env.NODE_ENV===&quot;development&quot;)</code>：根据<code>NODE_ENV</code>的值来进行缓存，一旦<code>using()</code>的回调返回一个预期之外的值，则将重新执行配置函数，并添加一个新的缓存入口；</li><li><code>api.cache.invalidate(() =&gt; process.env.NODE_ENV===&quot;development&quot;)</code>：根据<code>NODE_ENV</code>的值来进行缓存，一旦<code>using()</code>的回调返回一个预期之外的值，则将重新执行配置函数，并用执行结果替代原有的所有缓存入口；</li><li><code>api.cache(true)</code>：永久性缓存，等同于<code>api.cache.forever()</code>；</li><li><code>api.cache(false)</code>：用不缓存，等同于<code>api.cache.never()</code>。</li></ul><h4 id="2-3-api-env"><a href="#2-3-api-env" class="headerlink" title="2.3 api.env(...)"></a>2.3 <code>api.env(...)</code></h4><p><code>api.env(...)</code>用于检测运行环境，通常是检查<code>NODE_ENV</code>，有如下几种用法：</p><ul><li><code>api.env(&quot;production&quot;)</code>：如果当前运行环境是<code>production</code>则返回<code>true</code>；</li><li><code>api.env([&quot;development&quot;, &quot;test&quot;])</code>：如果<code>[&quot;development&quot;, &quot;test&quot;]</code>中包含当前运行环境则返回<code>true</code>；</li><li><code>api.env()</code>：返回当前运行环境(字符串)；</li><li><code>api.env(envName =&gt; envName.startsWith(&quot;test-&quot;))</code>：根据回调函数的结果得到<code>true</code>或者<code>false</code>。</li></ul><h4 id="2-4-api-caller-cb"><a href="#2-4-api-caller-cb" class="headerlink" title="2.4 api.caller(cb)"></a>2.4 <code>api.caller(cb)</code></h4><p>用于获取<code>caller</code>信息，回调<code>cb</code>的第一个参数即是<code>caller</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function isBabelRegister(caller) &#123;</span><br><span class="line">  return !!(caller &amp;&amp; caller.name === &quot;@babel/register&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = function(api) &#123;</span><br><span class="line">  const isRegister = api.caller(isBabelRegister);</span><br><span class="line"></span><br><span class="line">  return &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-5-api-assertVersion-range"><a href="#2-5-api-assertVersion-range" class="headerlink" title="2.5 api.assertVersion(range)"></a>2.5 <code>api.assertVersion(range)</code></h4><p>用于声明<code>Babel</code>本版本范围。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> (<span class="params">api</span>) &#123;</span><br><span class="line">  api.<span class="title function_">assertVersion</span>(<span class="string">&quot;^7.2&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="三、Plugin-插件"><a href="#三、Plugin-插件" class="headerlink" title="三、Plugin 插件"></a>三、<code>Plugin</code> 插件</h2><p>现今<code>Babel</code>的代码编译能力基本都是插件提供的</p><h3 id="1-使用插件"><a href="#1-使用插件" class="headerlink" title="1. 使用插件"></a>1. 使用插件</h3><p>在配置文件中通过<code>plugins</code>字段来使用插件，<code>babel</code>插件可以有多个，与预设不同，插件的执行是顺序执行，即从前往后执行，且先于预设。</p><ul><li>安装在<code>node_modules</code>中的插件：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;plugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;babel-plugin-myPlugin&quot;</span><span class="punctuation">,</span> <span class="string">&quot;@babel/plugin-transform-runtime&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>其它目录下的插件（如自己编写的），通过相对路径来使用：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;plugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;./node_modules/asdf/plugin&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="2-插件参数"><a href="#2-插件参数" class="headerlink" title="2. 插件参数"></a>2. 插件参数</h3><p>插件可以带参数。不带参数的插件可以用字符串表示；带参数的插件则用一个二元元组表示，元组的第一个成员为插件本身，第二个成员为参数对象，通过<code>key: value</code>的形式配置参数。这与预设完全一致。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;plugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">[</span></span><br><span class="line">      <span class="string">&quot;transform-async-to-module-method&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;module&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bluebird&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;method&quot;</span><span class="punctuation">:</span> <span class="string">&quot;coroutine&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="3-插件开发"><a href="#3-插件开发" class="headerlink" title="3. 插件开发"></a>3. 插件开发</h3><p>可以参考 <a href="https://github.com/thejameskyle/babel-handbook">babel-handbook</a> 来学习插件开发。</p><p>如下为一个简单的用于反转字符串的插件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// 访问者</span></span><br><span class="line">    <span class="attr">visitor</span>: &#123;</span><br><span class="line">      <span class="comment">// 通过路径（响应式节点）来访问 Identifier</span></span><br><span class="line">      <span class="comment">// 实际上是 &#123;Identifier: &#123;enter()&#123;...&#125;&#125;&#125; 的缩写，即进入节点时触发</span></span><br><span class="line">      <span class="comment">// 每次在 ast 中遇到 Identifier 就会调用一次</span></span><br><span class="line">      <span class="title class_">Identifier</span>(path) &#123;</span><br><span class="line">        <span class="keyword">const</span> name = path.<span class="property">node</span>.<span class="property">name</span>;</span><br><span class="line">        <span class="comment">// reverse the name: JavaScript -&gt; tpircSavaJ</span></span><br><span class="line">        path.<span class="property">node</span>.<span class="property">name</span> = name.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、Preset-预设"><a href="#四、Preset-预设" class="headerlink" title="四、Preset 预设"></a>四、<code>Preset</code> 预设</h2><p>预设是一组插件的集合。</p><h3 id="1-常用的预设"><a href="#1-常用的预设" class="headerlink" title="1. 常用的预设"></a>1. 常用的预设</h3><ul><li><code>@babel/preset-env</code>：处理<code>ES6+</code>语法；</li><li><code>@babel/preset-typescript</code>：处理<code>TS</code>；</li><li><code>@babel/preset-react</code>：处理<code>react</code>语法(<code>JSX</code>等)；</li><li><code>@babel/preset-flow</code>：处理<code>flow</code>。</li></ul><h3 id="2-使用预设"><a href="#2-使用预设" class="headerlink" title="2. 使用预设"></a>2. 使用预设</h3><p>在配置文件中通过<code>presets</code>字段来使用预设，预设可以有多个。不带参数的预设可以直接用字符串表示，带参数的预设则用一个二元元组表示，元组的第一个成员为预设本身，第二个成员为参数对象。</p><ul><li>对于安装到<code>node_modules</code>中的预设：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;presets&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;babel-preset-myPreset&quot;</span><span class="punctuation">,</span> <span class="string">&quot;@babel/preset-env&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>其它的预设（如自己编写的），可以使用相对路径：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;presets&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;./myProject/myPreset&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="3-编写预设"><a href="#3-编写预设" class="headerlink" title="3. 编写预设"></a>3. 编写预设</h3><p>预设是一组插件的集合，因此只需要导出一个配置对象。也可以是一个函数，返回一个具有插件数组的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">plugins</span>: [<span class="string">&quot;pluginA&quot;</span>, <span class="string">&quot;pluginB&quot;</span>, <span class="string">&quot;pluginC&quot;</span>],</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>预设里可以包含其它的预设，在导出或返回的配置对象里用<code>presets</code>字段表示；以及带有参数的插件，将该插件用元组表示，元组的第一个成员为插件本身，第二个成员为插件参数对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">  <span class="comment">// 预设嵌套</span></span><br><span class="line">  <span class="attr">presets</span>: [<span class="built_in">require</span>(<span class="string">&quot;@babel/preset-env&quot;</span>)],</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="comment">// 带有参数的插件</span></span><br><span class="line">    [<span class="built_in">require</span>(<span class="string">&quot;@babel/plugin-proposal-class-properties&quot;</span>), &#123; <span class="attr">loose</span>: <span class="literal">true</span> &#125;],</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">&quot;@babel/plugin-proposal-object-rest-spread&quot;</span>),</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当有多个预设时，预设的顺序是逆向的，即从后往前执行：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;presets&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;a&quot;</span><span class="punctuation">,</span> <span class="string">&quot;b&quot;</span><span class="punctuation">,</span> <span class="string">&quot;c&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>以上预设执行顺序为：<code>c -&gt; b -&gt; a</code></p><p>此外，和插件一样，预设也可以接收参数，且形式也和插件相同，一个预设用一个元组表示，元组的第一个成员为预设本身，第二个成员为预设的参数对象：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;presets&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">[</span></span><br><span class="line">      <span class="string">&quot;@babel/preset-env&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;useBuiltIns&quot;</span><span class="punctuation">:</span> <span class="string">&quot;entry&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;corejs&quot;</span><span class="punctuation">:</span> <span class="string">&quot;3.22&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Babel </tag>
            
            <tag> 前端工程化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3 源码系列 (九)：异步组件 defineAsyncComponent 与 Suspense</title>
      <link href="/articals/2724f441/"/>
      <url>/articals/2724f441/</url>
      
        <content type="html"><![CDATA[<p>前面几篇走完了<code>createApp</code>的流程，理清了<code>diff</code>算法的思路。现在回归到运行时的核心<code>API</code>上。在第一篇和第二篇中有解读过<code>watch</code>和<code>computed</code>，而本文则主要梳理异步组件的<code>API</code>。</p><h2 id="一、defineAsyncComponent"><a href="#一、defineAsyncComponent" class="headerlink" title="一、defineAsyncComponent"></a>一、<code>defineAsyncComponent</code></h2><p>用于定义异步组件。</p><h3 id="1-defineAsyncComponent"><a href="#1-defineAsyncComponent" class="headerlink" title="1. defineAsyncComponent"></a>1. <code>defineAsyncComponent</code></h3><p>入参<code>source</code>，可以是一个异步函数<code>loader</code>，也可以是一个包含有异步函数<code>loader</code>的对象<code>options</code>。当<code>source</code>为<code>options</code>时可以进行更细致的自定义，如推迟时间、异常处理、异常兜底组件、加载组件等。由于<code>import()</code>动态加载得到的是一个<code>Promise</code>，因此，<code>loader</code>常用来结合<code>import()</code>引入单文件组件来构成异步组件。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">AsyncComponentOptions</span>&lt;T = <span class="built_in">any</span>&gt; &#123;</span><br><span class="line">  <span class="attr">loader</span>: <span class="title class_">AsyncComponentLoader</span>&lt;T&gt;;</span><br><span class="line">  loadingComponent?: <span class="title class_">Component</span>;</span><br><span class="line">  errorComponent?: <span class="title class_">Component</span>;</span><br><span class="line">  delay?: <span class="built_in">number</span>;</span><br><span class="line">  timeout?: <span class="built_in">number</span>;</span><br><span class="line">  suspensible?: <span class="built_in">boolean</span>;</span><br><span class="line">  onError?: <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    error: <span class="built_in">Error</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    retry: () =&gt; <span class="built_in">void</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    fail: () =&gt; <span class="built_in">void</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    attempts: <span class="built_in">number</span></span></span></span><br><span class="line"><span class="params"><span class="function">  </span>) =&gt;</span> <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数中主要是定义一个<code>load</code>函数，通过对结构<code>source</code>得到的<code>loader</code>进行异常处理(是否重试)，对加载成功的结果进行校验并得到正常的加载结果。<code>load</code>函数在返回结果中的<code>setup</code>里调用。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// defineComponent</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">defineComponent</span>(<span class="params">options: <span class="built_in">unknown</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">isFunction</span>(options) ? &#123; <span class="attr">setup</span>: options, <span class="attr">name</span>: options.<span class="property">name</span> &#125; : options;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// defineAsyncComponent</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> defineAsyncComponent&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="title class_">Component</span> = &#123; <span class="keyword">new</span> (): <span class="title class_">ComponentPublicInstance</span> &#125;</span><br><span class="line">&gt;(<span class="attr">source</span>: <span class="title class_">AsyncComponentLoader</span>&lt;T&gt; | <span class="title class_">AsyncComponentOptions</span>&lt;T&gt;): T &#123;</span><br><span class="line">  <span class="comment">// 如果source本身是个函数，则包装成有loader的对象，方便后续统一处理</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isFunction</span>(source)) &#123;</span><br><span class="line">    source = &#123; <span class="attr">loader</span>: source &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解构source</span></span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    loader,</span><br><span class="line">    loadingComponent,</span><br><span class="line">    errorComponent,</span><br><span class="line">    delay = <span class="number">200</span>,</span><br><span class="line">    timeout, <span class="comment">// undefined = never times out</span></span><br><span class="line">    suspensible = <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">onError</span>: userOnError,</span><br><span class="line">  &#125; = source;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> <span class="attr">pendingRequest</span>: <span class="title class_">Promise</span>&lt;<span class="title class_">ConcreteComponent</span>&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">resolvedComp</span>: <span class="title class_">ConcreteComponent</span> | <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义函数：失败重试</span></span><br><span class="line">  <span class="keyword">let</span> retries = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">retry</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    retries++;</span><br><span class="line">    pendingRequest = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">load</span>();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义加载函数</span></span><br><span class="line">  <span class="keyword">const</span> load = (): <span class="title class_">Promise</span>&lt;<span class="title class_">ConcreteComponent</span>&gt; =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">thisRequest</span>: <span class="title class_">Promise</span>&lt;<span class="title class_">ConcreteComponent</span>&gt;;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      pendingRequest ||</span><br><span class="line">      (thisRequest = pendingRequest =</span><br><span class="line">        <span class="comment">// loader异步加载</span></span><br><span class="line">        <span class="title function_">loader</span>()</span><br><span class="line">          <span class="comment">// 处理加载异常</span></span><br><span class="line">          .<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">            err = err <span class="keyword">instanceof</span> <span class="title class_">Error</span> ? err : <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="title class_">String</span>(err));</span><br><span class="line">            <span class="comment">// 有userOnError时，失败重试</span></span><br><span class="line">            <span class="keyword">if</span> (userOnError) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="title function_">userRetry</span> = (<span class="params"></span>) =&gt; <span class="title function_">resolve</span>(<span class="title function_">retry</span>());</span><br><span class="line">                <span class="keyword">const</span> <span class="title function_">userFail</span> = (<span class="params"></span>) =&gt; <span class="title function_">reject</span>(err);</span><br><span class="line">                <span class="title function_">userOnError</span>(err, userRetry, userFail, retries + <span class="number">1</span>);</span><br><span class="line">              &#125;);</span><br><span class="line">              <span class="comment">// 否则 失败抛错</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">throw</span> err;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">          <span class="comment">// 加载成功</span></span><br><span class="line">          .<span class="title function_">then</span>(<span class="function">(<span class="params">comp: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (thisRequest !== pendingRequest &amp;&amp; pendingRequest) &#123;</span><br><span class="line">              <span class="keyword">return</span> pendingRequest;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 没有comp告警</span></span><br><span class="line">            <span class="keyword">if</span> (__DEV__ &amp;&amp; !comp) &#123;</span><br><span class="line">              <span class="title function_">warn</span>(</span><br><span class="line">                <span class="string">`Async component loader resolved to undefined. `</span> +</span><br><span class="line">                  <span class="string">`If you are using retry(), make sure to return its return value.`</span></span><br><span class="line">              );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理 es 模块</span></span><br><span class="line">            <span class="comment">// interop module default</span></span><br><span class="line">            <span class="keyword">if</span> (</span><br><span class="line">              comp &amp;&amp;</span><br><span class="line">              (comp.<span class="property">__esModule</span> || comp[<span class="title class_">Symbol</span>.<span class="property">toStringTag</span>] === <span class="string">&quot;Module&quot;</span>)</span><br><span class="line">            ) &#123;</span><br><span class="line">              comp = comp.<span class="property">default</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// comp 必须是对象或函数</span></span><br><span class="line">            <span class="keyword">if</span> (__DEV__ &amp;&amp; comp &amp;&amp; !<span class="title function_">isObject</span>(comp) &amp;&amp; !<span class="title function_">isFunction</span>(comp)) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`Invalid async component load result: <span class="subst">$&#123;comp&#125;</span>`</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 得到 resolveComponent</span></span><br><span class="line">            resolvedComp = comp;</span><br><span class="line">            <span class="keyword">return</span> comp;</span><br><span class="line">          &#125;))</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span>; <span class="comment">// ... 这里暂时省略返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>defineAsyncComponent</code>的返回值是个经过<code>defineComponent</code>处理过的<code>options</code>。而<code>options</code>中的<code>setup</code>有着异步组件的渲染逻辑。主要是调用<code>load</code>，通过<code>createInnerComp</code>来创建加载成功的组件，<code>createVNode</code>来进行异常和加载中的渲染。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> defineAsyncComponent&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="title class_">Component</span> = &#123; <span class="keyword">new</span> (): <span class="title class_">ComponentPublicInstance</span> &#125;</span><br><span class="line">&gt;(<span class="attr">source</span>: <span class="title class_">AsyncComponentLoader</span>&lt;T&gt; | <span class="title class_">AsyncComponentOptions</span>&lt;T&gt;): T &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isFunction</span>(source)) &#123;</span><br><span class="line">    source = &#123; <span class="attr">loader</span>: source &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    loader,</span><br><span class="line">    loadingComponent,</span><br><span class="line">    errorComponent,</span><br><span class="line">    delay = <span class="number">200</span>,</span><br><span class="line">    timeout, <span class="comment">// undefined = never times out</span></span><br><span class="line">    suspensible = <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">onError</span>: userOnError,</span><br><span class="line">  &#125; = source;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;AsyncComponentWrapper&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">__asyncLoader</span>: load,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">__asyncResolved</span>() &#123;</span><br><span class="line">      <span class="keyword">return</span> resolvedComp;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> instance = currentInstance!;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 已加载完成的case</span></span><br><span class="line">      <span class="comment">// already resolved</span></span><br><span class="line">      <span class="keyword">if</span> (resolvedComp) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="title function_">createInnerComp</span>(resolvedComp!, instance);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 定义错误处理程序</span></span><br><span class="line">      <span class="keyword">const</span> <span class="title function_">onError</span> = (<span class="params">err: <span class="built_in">Error</span></span>) =&gt; &#123;</span><br><span class="line">        pendingRequest = <span class="literal">null</span>;</span><br><span class="line">        <span class="title function_">handleError</span>(</span><br><span class="line">          err,</span><br><span class="line">          instance,</span><br><span class="line">          <span class="title class_">ErrorCodes</span>.<span class="property">ASYNC_COMPONENT_LOADER</span>,</span><br><span class="line">          !errorComponent <span class="comment">/* do not throw in dev if user provided error component */</span></span><br><span class="line">        );</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Suspense 或者 SSR：加载并返回</span></span><br><span class="line">      <span class="comment">// suspense-controlled or SSR.</span></span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        (__FEATURE_SUSPENSE__ &amp;&amp; suspensible &amp;&amp; instance.<span class="property">suspense</span>) ||</span><br><span class="line">        (__SSR__ &amp;&amp; isInSSRComponentSetup)</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">load</span>()</span><br><span class="line">          .<span class="title function_">then</span>(<span class="function">(<span class="params">comp</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="title function_">createInnerComp</span>(comp, instance);</span><br><span class="line">          &#125;)</span><br><span class="line">          .<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">onError</span>(err);</span><br><span class="line">            <span class="keyword">return</span> <span class="function">() =&gt;</span></span><br><span class="line">              <span class="comment">// 异常兜底组件</span></span><br><span class="line">              errorComponent</span><br><span class="line">                ? <span class="title function_">createVNode</span>(errorComponent <span class="keyword">as</span> <span class="title class_">ConcreteComponent</span>, &#123;</span><br><span class="line">                    <span class="attr">error</span>: err,</span><br><span class="line">                  &#125;)</span><br><span class="line">                : <span class="literal">null</span>;</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 状态初始化</span></span><br><span class="line">      <span class="keyword">const</span> loaded = <span class="title function_">ref</span>(<span class="literal">false</span>);</span><br><span class="line">      <span class="keyword">const</span> error = <span class="title function_">ref</span>();</span><br><span class="line">      <span class="keyword">const</span> delayed = <span class="title function_">ref</span>(!!delay);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 采用定时器计时</span></span><br><span class="line">      <span class="keyword">if</span> (delay) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          delayed.<span class="property">value</span> = <span class="literal">false</span>;</span><br><span class="line">        &#125;, delay);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 既没有拿到结果，又没有异常，则超时处理</span></span><br><span class="line">      <span class="keyword">if</span> (timeout != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (!loaded.<span class="property">value</span> &amp;&amp; !error.<span class="property">value</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> err = <span class="keyword">new</span> <span class="title class_">Error</span>(</span><br><span class="line">              <span class="string">`Async component timed out after <span class="subst">$&#123;timeout&#125;</span>ms.`</span></span><br><span class="line">            );</span><br><span class="line">            <span class="title function_">onError</span>(err);</span><br><span class="line">            error.<span class="property">value</span> = err;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, timeout);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 加载</span></span><br><span class="line">      <span class="title function_">load</span>()</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          loaded.<span class="property">value</span> = <span class="literal">true</span>;</span><br><span class="line">          <span class="comment">// 对于KeepAlive的内容，加载成功后进行强制更新</span></span><br><span class="line">          <span class="keyword">if</span> (instance.<span class="property">parent</span> &amp;&amp; <span class="title function_">isKeepAlive</span>(instance.<span class="property">parent</span>.<span class="property">vnode</span>)) &#123;</span><br><span class="line">            <span class="comment">// parent is keep-alive, force update so the loaded component&#x27;s</span></span><br><span class="line">            <span class="comment">// name is taken into account</span></span><br><span class="line">            <span class="title function_">queueJob</span>(instance.<span class="property">parent</span>.<span class="property">update</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">onError</span>(err);</span><br><span class="line">          error.<span class="property">value</span> = err;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 加载成功</span></span><br><span class="line">        <span class="keyword">if</span> (loaded.<span class="property">value</span> &amp;&amp; resolvedComp) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="title function_">createInnerComp</span>(resolvedComp, instance);</span><br><span class="line">          <span class="comment">// 异常</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error.<span class="property">value</span> &amp;&amp; errorComponent) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="title function_">createVNode</span>(errorComponent <span class="keyword">as</span> <span class="title class_">ConcreteComponent</span>, &#123;</span><br><span class="line">            <span class="attr">error</span>: error.<span class="property">value</span>,</span><br><span class="line">          &#125;);</span><br><span class="line">          <span class="comment">// 加载中</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (loadingComponent &amp;&amp; !delayed.<span class="property">value</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="title function_">createVNode</span>(loadingComponent <span class="keyword">as</span> <span class="title class_">ConcreteComponent</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;) <span class="keyword">as</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-createInnerComp"><a href="#2-createInnerComp" class="headerlink" title="2. createInnerComp"></a>2. <code>createInnerComp</code></h3><p>当加载成功时，调用<code>createInnerComp</code>根据加载得到的<code>resolvedComp</code>来创建内部组件。实际上还是<code>createVNode</code>来创建的。这里继承了外部组件的<code>ref</code>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createInnerComp</span>(<span class="params"></span></span><br><span class="line"><span class="params">  comp: ConcreteComponent,</span></span><br><span class="line"><span class="params">  &#123;</span></span><br><span class="line"><span class="params">    vnode: &#123; ref, props, children, shapeFlag &#125;,</span></span><br><span class="line"><span class="params">    parent,</span></span><br><span class="line"><span class="params">  &#125;: ComponentInternalInstance</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> vnode = <span class="title function_">createVNode</span>(comp, props, children);</span><br><span class="line">  <span class="comment">// ensure inner component inherits the async wrapper&#x27;s ref owner</span></span><br><span class="line">  vnode.<span class="property">ref</span> = ref;</span><br><span class="line">  <span class="keyword">return</span> vnode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、Suspense"><a href="#二、Suspense" class="headerlink" title="二、Suspense"></a>二、<code>Suspense</code></h2><p>在<code>vue3.2</code>中引入的新特性之一，便是异步组件<code>Suspense</code>。</p><h3 id="1-process"><a href="#1-process" class="headerlink" title="1. process"></a>1. <code>process</code></h3><p>和<code>KeepAlive</code>类型，<code>Suspense</code>暴露一个类似组件的<code>API</code>。当检查到<code>__isSuspense == true</code>时，判定当前组件为<code>&lt;Suspense&gt;</code>，会调用<code>process</code>方法并被传入<code>renderer</code>内部进行渲染。<code>process</code>也会根据旧节点是否存在，选择 挂载 或者 对比新旧节点并更新。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// props</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">SuspenseProps</span> &#123;</span><br><span class="line">  onResolve?: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  onPending?: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  onFallback?: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  timeout?: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Suspense</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">SuspenseImpl</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Suspense&quot;</span>,</span><br><span class="line">  <span class="comment">// In order to make Suspense tree-shakable, we need to avoid importing it</span></span><br><span class="line">  <span class="comment">// directly in the renderer. The renderer checks for the __isSuspense flag</span></span><br><span class="line">  <span class="comment">// on a vnode&#x27;s type and calls the `process` method, passing in renderer</span></span><br><span class="line">  <span class="comment">// internals.</span></span><br><span class="line">  <span class="attr">__isSuspense</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="title function_">process</span>(<span class="params"></span></span><br><span class="line"><span class="params">    n1: VNode | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">    n2: VNode,</span></span><br><span class="line"><span class="params">    container: RendererElement,</span></span><br><span class="line"><span class="params">    anchor: RendererNode | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">    parentComponent: ComponentInternalInstance | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">    parentSuspense: SuspenseBoundary | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">    isSVG: <span class="built_in">boolean</span>,</span></span><br><span class="line"><span class="params">    slotScopeIds: <span class="built_in">string</span>[] | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">    optimized: <span class="built_in">boolean</span>,</span></span><br><span class="line"><span class="params">    <span class="comment">// platform-specific impl passed from renderer</span></span></span><br><span class="line"><span class="params">    rendererInternals: RendererInternals</span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n1 == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="title function_">mountSuspense</span>(</span><br><span class="line">        n2,</span><br><span class="line">        container,</span><br><span class="line">        anchor,</span><br><span class="line">        parentComponent,</span><br><span class="line">        parentSuspense,</span><br><span class="line">        isSVG,</span><br><span class="line">        slotScopeIds,</span><br><span class="line">        optimized,</span><br><span class="line">        rendererInternals</span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">patchSuspense</span>(</span><br><span class="line">        n1,</span><br><span class="line">        n2,</span><br><span class="line">        container,</span><br><span class="line">        anchor,</span><br><span class="line">        parentComponent,</span><br><span class="line">        isSVG,</span><br><span class="line">        slotScopeIds,</span><br><span class="line">        optimized,</span><br><span class="line">        rendererInternals</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">hydrate</span>: hydrateSuspense,</span><br><span class="line">  <span class="attr">create</span>: createSuspenseBoundary,</span><br><span class="line">  <span class="attr">normalize</span>: normalizeSuspenseChildren,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Force-casted public typing for h and TSX props inference</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Suspense</span> = (__FEATURE_SUSPENSE__ ? <span class="title class_">SuspenseImpl</span> : <span class="literal">null</span>) <span class="keyword">as</span> <span class="built_in">any</span> <span class="keyword">as</span> &#123;</span><br><span class="line">  <span class="attr">__isSuspense</span>: <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">new</span> (): &#123; <span class="attr">$props</span>: <span class="title class_">VNodeProps</span> &amp; <span class="title class_">SuspenseProps</span> &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="1-1-mountSuspense"><a href="#1-1-mountSuspense" class="headerlink" title="1.1 mountSuspense"></a>1.1 <code>mountSuspense</code></h4><p>首次加载组件时会进入挂载逻辑。通过<code>mountSuspense</code>来挂载异步组件。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mountSuspense</span>(<span class="params"></span></span><br><span class="line"><span class="params">  vnode: VNode,</span></span><br><span class="line"><span class="params">  container: RendererElement,</span></span><br><span class="line"><span class="params">  anchor: RendererNode | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  parentComponent: ComponentInternalInstance | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  parentSuspense: SuspenseBoundary | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  isSVG: <span class="built_in">boolean</span>,</span></span><br><span class="line"><span class="params">  slotScopeIds: <span class="built_in">string</span>[] | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  optimized: <span class="built_in">boolean</span>,</span></span><br><span class="line"><span class="params">  rendererInternals: RendererInternals</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="attr">p</span>: patch,</span><br><span class="line">    <span class="attr">o</span>: &#123; createElement &#125;,</span><br><span class="line">  &#125; = rendererInternals;</span><br><span class="line">  <span class="comment">// 创建一个 div 作为容器，尚未加入到文档中</span></span><br><span class="line">  <span class="keyword">const</span> hiddenContainer = <span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">  <span class="comment">// 创建 suspense</span></span><br><span class="line">  <span class="keyword">const</span> suspense = (vnode.<span class="property">suspense</span> = <span class="title function_">createSuspenseBoundary</span>(</span><br><span class="line">    vnode,</span><br><span class="line">    parentSuspense,</span><br><span class="line">    parentComponent,</span><br><span class="line">    container,</span><br><span class="line">    hiddenContainer,</span><br><span class="line">    anchor,</span><br><span class="line">    isSVG,</span><br><span class="line">    slotScopeIds,</span><br><span class="line">    optimized,</span><br><span class="line">    rendererInternals</span><br><span class="line">  ));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 旧节点为 null ，挂载</span></span><br><span class="line">  <span class="comment">// start mounting the content subtree in an off-dom container</span></span><br><span class="line">  <span class="title function_">patch</span>(</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    (suspense.<span class="property">pendingBranch</span> = vnode.<span class="property">ssContent</span>!),</span><br><span class="line">    hiddenContainer,</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    parentComponent,</span><br><span class="line">    suspense,</span><br><span class="line">    isSVG,</span><br><span class="line">    slotScopeIds</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查异步依赖</span></span><br><span class="line">  <span class="comment">// now check if we have encountered any async deps</span></span><br><span class="line">  <span class="keyword">if</span> (suspense.<span class="property">deps</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// has async</span></span><br><span class="line">    <span class="comment">// invoke @fallback event</span></span><br><span class="line">    <span class="title function_">triggerEvent</span>(vnode, <span class="string">&quot;onPending&quot;</span>);</span><br><span class="line">    <span class="title function_">triggerEvent</span>(vnode, <span class="string">&quot;onFallback&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有异步依赖，先降级</span></span><br><span class="line">    <span class="comment">// mount the fallback tree</span></span><br><span class="line">    <span class="title function_">patch</span>(</span><br><span class="line">      <span class="literal">null</span>,</span><br><span class="line">      vnode.<span class="property">ssFallback</span>!,</span><br><span class="line">      container,</span><br><span class="line">      anchor,</span><br><span class="line">      parentComponent,</span><br><span class="line">      <span class="literal">null</span>, <span class="comment">// fallback tree will not have suspense context</span></span><br><span class="line">      isSVG,</span><br><span class="line">      slotScopeIds</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 活跃分支</span></span><br><span class="line">    <span class="title function_">setActiveBranch</span>(suspense, vnode.<span class="property">ssFallback</span>!);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 没有异步依赖</span></span><br><span class="line">    <span class="comment">// Suspense has no async deps. Just resolve.</span></span><br><span class="line">    suspense.<span class="title function_">resolve</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-patchSuspense"><a href="#1-2-patchSuspense" class="headerlink" title="1.2 patchSuspense"></a>1.2 <code>patchSuspense</code></h4><p><code>patchSuspense</code> 进行新旧节点的对比与更新。<code>Suspense</code>有多个分支如活跃、等待、降级等。</p><ul><li>当前（旧节点）有等待分支<code>pendingBranch</code>，根据新旧等待分支节点类型是否相同分别做处理；</li><li>当前（旧节点）没有等待分支<code>pendingBranch</code>，根据新的等待分支与当前(旧的)活跃分支节点类型是否相同分别进行处理。</li></ul><p>同时也会考虑异步依赖和是否已经处于降级状态。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">patchSuspense</span>(<span class="params"></span></span><br><span class="line"><span class="params">  n1: VNode,</span></span><br><span class="line"><span class="params">  n2: VNode,</span></span><br><span class="line"><span class="params">  container: RendererElement,</span></span><br><span class="line"><span class="params">  anchor: RendererNode | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  parentComponent: ComponentInternalInstance | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  isSVG: <span class="built_in">boolean</span>,</span></span><br><span class="line"><span class="params">  slotScopeIds: <span class="built_in">string</span>[] | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  optimized: <span class="built_in">boolean</span>,</span></span><br><span class="line"><span class="params">  &#123; p: patch, um: unmount, o: &#123; createElement &#125; &#125;: RendererInternals</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// suspense复用</span></span><br><span class="line">  <span class="keyword">const</span> suspense = (n2.<span class="property">suspense</span> = n1.<span class="property">suspense</span>)!;</span><br><span class="line">  <span class="comment">// 虚拟DOM更新</span></span><br><span class="line">  suspense.<span class="property">vnode</span> = n2;</span><br><span class="line">  <span class="comment">// DOM复用</span></span><br><span class="line">  n2.<span class="property">el</span> = n1.<span class="property">el</span>;</span><br><span class="line">  <span class="keyword">const</span> newBranch = n2.<span class="property">ssContent</span>!;</span><br><span class="line">  <span class="keyword">const</span> newFallback = n2.<span class="property">ssFallback</span>!;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解构一份备用</span></span><br><span class="line">  <span class="keyword">const</span> &#123; activeBranch, pendingBranch, isInFallback, isHydrating &#125; = suspense;</span><br><span class="line">  <span class="comment">// 如果当前有等待分支</span></span><br><span class="line">  <span class="keyword">if</span> (pendingBranch) &#123;</span><br><span class="line">    <span class="comment">// 刷新等待分支的内容</span></span><br><span class="line">    suspense.<span class="property">pendingBranch</span> = newBranch;</span><br><span class="line">    <span class="comment">// 新旧等待分支属于同样的节点类型</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isSameVNodeType</span>(newBranch, pendingBranch)) &#123;</span><br><span class="line">      <span class="comment">// patch 做更详细的比较</span></span><br><span class="line">      <span class="comment">// same root type but content may have changed.</span></span><br><span class="line">      <span class="title function_">patch</span>(</span><br><span class="line">        pendingBranch,</span><br><span class="line">        newBranch,</span><br><span class="line">        suspense.<span class="property">hiddenContainer</span>,</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        parentComponent,</span><br><span class="line">        suspense,</span><br><span class="line">        isSVG,</span><br><span class="line">        slotScopeIds,</span><br><span class="line">        optimized</span><br><span class="line">      );</span><br><span class="line">      <span class="comment">// 没有异步依赖，则直接resolve</span></span><br><span class="line">      <span class="keyword">if</span> (suspense.<span class="property">deps</span> &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        suspense.<span class="title function_">resolve</span>();</span><br><span class="line">        <span class="comment">// 有异步依赖且处于 降级 状态</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isInFallback) &#123;</span><br><span class="line">        <span class="title function_">patch</span>(</span><br><span class="line">          activeBranch,</span><br><span class="line">          newFallback,</span><br><span class="line">          container,</span><br><span class="line">          anchor,</span><br><span class="line">          parentComponent,</span><br><span class="line">          <span class="literal">null</span>, <span class="comment">// fallback tree will not have suspense context</span></span><br><span class="line">          isSVG,</span><br><span class="line">          slotScopeIds,</span><br><span class="line">          optimized</span><br><span class="line">        );</span><br><span class="line">        <span class="title function_">setActiveBranch</span>(suspense, newFallback);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 新旧等待分支不属于同一类型的节点</span></span><br><span class="line">      <span class="comment">// toggled before pending tree is resolved</span></span><br><span class="line">      suspense.<span class="property">pendingId</span>++;</span><br><span class="line">      <span class="comment">// 处理旧节点</span></span><br><span class="line">      <span class="keyword">if</span> (isHydrating) &#123;</span><br><span class="line">        <span class="comment">// if toggled before hydration is finished, the current DOM tree is</span></span><br><span class="line">        <span class="comment">// no longer valid. set it as the active branch so it will be unmounted</span></span><br><span class="line">        <span class="comment">// when resolved</span></span><br><span class="line">        suspense.<span class="property">isHydrating</span> = <span class="literal">false</span>;</span><br><span class="line">        suspense.<span class="property">activeBranch</span> = pendingBranch;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">unmount</span>(pendingBranch, parentComponent, suspense);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 状态重置</span></span><br><span class="line">      <span class="comment">// increment pending ID. this is used to invalidate async callbacks</span></span><br><span class="line">      <span class="comment">// reset suspense state</span></span><br><span class="line">      suspense.<span class="property">deps</span> = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// discard effects from pending branch</span></span><br><span class="line">      suspense.<span class="property">effects</span>.<span class="property">length</span> = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// discard previous container</span></span><br><span class="line">      suspense.<span class="property">hiddenContainer</span> = <span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 处理降级状态</span></span><br><span class="line">      <span class="keyword">if</span> (isInFallback) &#123;</span><br><span class="line">        <span class="comment">// 挂载等待分支</span></span><br><span class="line">        <span class="comment">// already in fallback state</span></span><br><span class="line">        <span class="title function_">patch</span>(</span><br><span class="line">          <span class="literal">null</span>,</span><br><span class="line">          newBranch,</span><br><span class="line">          suspense.<span class="property">hiddenContainer</span>,</span><br><span class="line">          <span class="literal">null</span>,</span><br><span class="line">          parentComponent,</span><br><span class="line">          suspense,</span><br><span class="line">          isSVG,</span><br><span class="line">          slotScopeIds,</span><br><span class="line">          optimized</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// 没有异步依赖，则resolve</span></span><br><span class="line">        <span class="keyword">if</span> (suspense.<span class="property">deps</span> &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">          suspense.<span class="title function_">resolve</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 对比旧的活跃分支与新的降级分支</span></span><br><span class="line">          <span class="title function_">patch</span>(</span><br><span class="line">            activeBranch,</span><br><span class="line">            newFallback,</span><br><span class="line">            container,</span><br><span class="line">            anchor,</span><br><span class="line">            parentComponent,</span><br><span class="line">            <span class="literal">null</span>, <span class="comment">// fallback tree will not have suspense context</span></span><br><span class="line">            isSVG,</span><br><span class="line">            slotScopeIds,</span><br><span class="line">            optimized</span><br><span class="line">          );</span><br><span class="line">          <span class="comment">// 重设活跃分支</span></span><br><span class="line">          <span class="title function_">setActiveBranch</span>(suspense, newFallback);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不处于 降级状态，且活跃分支与新的等待分支节点类型一致</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (activeBranch &amp;&amp; <span class="title function_">isSameVNodeType</span>(newBranch, activeBranch)) &#123;</span><br><span class="line">        <span class="comment">// 对比当前活跃分支与新的等待分支</span></span><br><span class="line">        <span class="comment">// toggled &quot;back&quot; to current active branch</span></span><br><span class="line">        <span class="title function_">patch</span>(</span><br><span class="line">          activeBranch,</span><br><span class="line">          newBranch,</span><br><span class="line">          container,</span><br><span class="line">          anchor,</span><br><span class="line">          parentComponent,</span><br><span class="line">          suspense,</span><br><span class="line">          isSVG,</span><br><span class="line">          slotScopeIds,</span><br><span class="line">          optimized</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// 强制resolve</span></span><br><span class="line">        <span class="comment">// force resolve</span></span><br><span class="line">        suspense.<span class="title function_">resolve</span>(<span class="literal">true</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不处于 降级状态，且新的等待分支与当前活跃分支节点类型不一致</span></span><br><span class="line">        <span class="comment">// 挂载新的等待分支</span></span><br><span class="line">        <span class="comment">// switched to a 3rd branch</span></span><br><span class="line">        <span class="title function_">patch</span>(</span><br><span class="line">          <span class="literal">null</span>,</span><br><span class="line">          newBranch,</span><br><span class="line">          suspense.<span class="property">hiddenContainer</span>,</span><br><span class="line">          <span class="literal">null</span>,</span><br><span class="line">          parentComponent,</span><br><span class="line">          suspense,</span><br><span class="line">          isSVG,</span><br><span class="line">          slotScopeIds,</span><br><span class="line">          optimized</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// 没有异步依赖则 resolve</span></span><br><span class="line">        <span class="keyword">if</span> (suspense.<span class="property">deps</span> &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">          suspense.<span class="title function_">resolve</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前没有等待的分支</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 新的等待分支与当前活跃分支节点类型一致，则通过patch来对比更新</span></span><br><span class="line">    <span class="keyword">if</span> (activeBranch &amp;&amp; <span class="title function_">isSameVNodeType</span>(newBranch, activeBranch)) &#123;</span><br><span class="line">      <span class="comment">// root did not change, just normal patch</span></span><br><span class="line">      <span class="title function_">patch</span>(</span><br><span class="line">        activeBranch,</span><br><span class="line">        newBranch,</span><br><span class="line">        container,</span><br><span class="line">        anchor,</span><br><span class="line">        parentComponent,</span><br><span class="line">        suspense,</span><br><span class="line">        isSVG,</span><br><span class="line">        slotScopeIds,</span><br><span class="line">        optimized</span><br><span class="line">      );</span><br><span class="line">      <span class="comment">// 重设活跃分支</span></span><br><span class="line">      <span class="title function_">setActiveBranch</span>(suspense, newBranch);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 新的等待分支与当前活跃分支节点类型不同，挂载新的等待分支</span></span><br><span class="line">      <span class="comment">// root node toggled</span></span><br><span class="line">      <span class="comment">// invoke @pending event</span></span><br><span class="line">      <span class="title function_">triggerEvent</span>(n2, <span class="string">&quot;onPending&quot;</span>);</span><br><span class="line">      <span class="comment">// mount pending branch in off-dom container</span></span><br><span class="line">      suspense.<span class="property">pendingBranch</span> = newBranch;</span><br><span class="line">      suspense.<span class="property">pendingId</span>++;</span><br><span class="line">      <span class="title function_">patch</span>(</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        newBranch,</span><br><span class="line">        suspense.<span class="property">hiddenContainer</span>,</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        parentComponent,</span><br><span class="line">        suspense,</span><br><span class="line">        isSVG,</span><br><span class="line">        slotScopeIds,</span><br><span class="line">        optimized</span><br><span class="line">      );</span><br><span class="line">      <span class="comment">// 没有异步依赖则 resolve</span></span><br><span class="line">      <span class="keyword">if</span> (suspense.<span class="property">deps</span> &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// incoming branch has no async deps, resolve now.</span></span><br><span class="line">        suspense.<span class="title function_">resolve</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 有异步依赖</span></span><br><span class="line">        <span class="keyword">const</span> &#123; timeout, pendingId &#125; = suspense;</span><br><span class="line">        <span class="comment">// 有设置超时时间，定时器 超时降级</span></span><br><span class="line">        <span class="keyword">if</span> (timeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (suspense.<span class="property">pendingId</span> === pendingId) &#123;</span><br><span class="line">              suspense.<span class="title function_">fallback</span>(newFallback);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, timeout);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout === <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">//超时时间设置为0，即时降级</span></span><br><span class="line">          suspense.<span class="title function_">fallback</span>(newFallback);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-setActiveBranch"><a href="#1-3-setActiveBranch" class="headerlink" title="1.3 setActiveBranch"></a>1.3 <code>setActiveBranch</code></h4><p><code>setActiveBranch</code>用来设置活跃分支。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setActiveBranch</span>(<span class="params">suspense: SuspenseBoundary, branch: VNode</span>) &#123;</span><br><span class="line">  suspense.<span class="property">activeBranch</span> = branch;</span><br><span class="line">  <span class="keyword">const</span> &#123; vnode, parentComponent &#125; = suspense;</span><br><span class="line">  <span class="keyword">const</span> el = (vnode.<span class="property">el</span> = branch.<span class="property">el</span>);</span><br><span class="line">  <span class="comment">// in case suspense is the root node of a component,</span></span><br><span class="line">  <span class="comment">// recursively update the HOC el</span></span><br><span class="line">  <span class="keyword">if</span> (parentComponent &amp;&amp; parentComponent.<span class="property">subTree</span> === vnode) &#123;</span><br><span class="line">    parentComponent.<span class="property">vnode</span>.<span class="property">el</span> = el;</span><br><span class="line">    <span class="title function_">updateHOCHostEl</span>(parentComponent, el);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-SuspenseBoundary"><a href="#2-SuspenseBoundary" class="headerlink" title="2. SuspenseBoundary"></a>2. <code>SuspenseBoundary</code></h3><h4 id="2-1-ts-类型"><a href="#2-1-ts-类型" class="headerlink" title="2.1 ts 类型"></a>2.1 <code>ts</code> 类型</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">SuspenseBoundary</span> &#123;</span><br><span class="line">  <span class="attr">vnode</span>: <span class="title class_">VNode</span>&lt;<span class="title class_">RendererNode</span>, <span class="title class_">RendererElement</span>, <span class="title class_">SuspenseProps</span>&gt;;</span><br><span class="line">  <span class="attr">parent</span>: <span class="title class_">SuspenseBoundary</span> | <span class="literal">null</span>;</span><br><span class="line">  <span class="attr">parentComponent</span>: <span class="title class_">ComponentInternalInstance</span> | <span class="literal">null</span>;</span><br><span class="line">  <span class="attr">isSVG</span>: <span class="built_in">boolean</span>;</span><br><span class="line">  <span class="attr">container</span>: <span class="title class_">RendererElement</span>;</span><br><span class="line">  <span class="attr">hiddenContainer</span>: <span class="title class_">RendererElement</span>;</span><br><span class="line">  <span class="attr">anchor</span>: <span class="title class_">RendererNode</span> | <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 活跃分支</span></span><br><span class="line">  <span class="attr">activeBranch</span>: <span class="title class_">VNode</span> | <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 等待分支</span></span><br><span class="line">  <span class="attr">pendingBranch</span>: <span class="title class_">VNode</span> | <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 异步依赖数量</span></span><br><span class="line">  <span class="attr">deps</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">pendingId</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">timeout</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">isInFallback</span>: <span class="built_in">boolean</span>;</span><br><span class="line">  <span class="attr">isHydrating</span>: <span class="built_in">boolean</span>;</span><br><span class="line">  <span class="attr">isUnmounted</span>: <span class="built_in">boolean</span>;</span><br><span class="line">  <span class="comment">// 副作用</span></span><br><span class="line">  <span class="attr">effects</span>: <span class="title class_">Function</span>[];</span><br><span class="line">  <span class="title function_">resolve</span>(force?: <span class="built_in">boolean</span>): <span class="built_in">void</span>;</span><br><span class="line">  <span class="comment">// 降级</span></span><br><span class="line">  <span class="title function_">fallback</span>(<span class="attr">fallbackVNode</span>: <span class="title class_">VNode</span>): <span class="built_in">void</span>;</span><br><span class="line">  <span class="title function_">move</span>(</span><br><span class="line">    <span class="attr">container</span>: <span class="title class_">RendererElement</span>,</span><br><span class="line">    <span class="attr">anchor</span>: <span class="title class_">RendererNode</span> | <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">MoveType</span></span><br><span class="line">  ): <span class="built_in">void</span>;</span><br><span class="line">  <span class="title function_">next</span>(): <span class="title class_">RendererNode</span> | <span class="literal">null</span>;</span><br><span class="line">  <span class="title function_">registerDep</span>(</span><br><span class="line">    <span class="attr">instance</span>: <span class="title class_">ComponentInternalInstance</span>,</span><br><span class="line">    <span class="attr">setupRenderEffect</span>: <span class="title class_">SetupRenderEffectFn</span></span><br><span class="line">  ): <span class="built_in">void</span>;</span><br><span class="line">  <span class="comment">// 卸载</span></span><br><span class="line">  <span class="title function_">unmount</span>(<span class="attr">parentSuspense</span>: <span class="title class_">SuspenseBoundary</span> | <span class="literal">null</span>, doRemove?: <span class="built_in">boolean</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-createSuspenseBoundary"><a href="#2-2-createSuspenseBoundary" class="headerlink" title="2.2 createSuspenseBoundary"></a>2.2 <code>createSuspenseBoundary</code></h4><p>使用<code>createSuspenseBoundary</code>来生成一个<code>SuspenseBoundary</code>类型的<code>suspense</code>。由上面的<code>ts</code>类型我们知道，这个<code>suspense</code>具有<code>resolve</code>, <code>fallback</code>, <code>move</code>, <code>next</code>, <code>registerDep</code>, <code>unmount</code>等方法。下面就一个个分析每个方法的主要功能。</p><h5 id="2-2-1-suspense-resolve"><a href="#2-2-1-suspense-resolve" class="headerlink" title="2.2.1 suspense.resolve"></a>2.2.1 <code>suspense.resolve</code></h5><p>在拿到期望的异步结果时，调用<strong><code>resolve</code></strong>来用等待分支替换掉当前的活跃分支，从而渲染期望的内容。</p><ul><li>因此，首先就是要保证异步组件具有等待分支，且组件尚未被卸载（开发环境）；</li><li>之后调用从<code>suspenseInternals</code>中拿到的<code>move</code>函数将等待分支从离线容器移动到实际容器中，并将其设置为活跃分支；</li><li>沿着<code>suspense.parent</code>链向上查找，将所有副作用合并到最外层的未解决的<code>Suspense</code>中；</li><li>如果向上查找时没有发现未解决的先代<code>Suspense</code>，则处理当前<code>Suspense</code>的所有副作用，并将副作用列表清空；</li><li>触发<code>Suspense</code>的<code>onResolve</code>事件。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">suspense</span>: <span class="title class_">SuspenseBoundary</span> = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">resolve</span>(<span class="params">resume = <span class="literal">false</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 确保有等待分支且Suspense未被卸载</span></span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!resume &amp;&amp; !suspense.<span class="property">pendingBranch</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(</span><br><span class="line">          <span class="string">`suspense.resolve() is called without a pending branch.`</span></span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (suspense.<span class="property">isUnmounted</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(</span><br><span class="line">          <span class="string">`suspense.resolve() is called on an already unmounted suspense boundary.`</span></span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解构变量</span></span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">      vnode,</span><br><span class="line">      activeBranch,</span><br><span class="line">      pendingBranch,</span><br><span class="line">      pendingId,</span><br><span class="line">      effects,</span><br><span class="line">      parentComponent,</span><br><span class="line">      container,</span><br><span class="line">    &#125; = suspense;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (suspense.<span class="property">isHydrating</span>) &#123;</span><br><span class="line">      suspense.<span class="property">isHydrating</span> = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!resume) &#123;</span><br><span class="line">      <span class="comment">// 有transition的延迟切入，则在其transition.afterLeave中进行move</span></span><br><span class="line">      <span class="comment">// move的作用是将等待分支的内容从离线容器移动到实际容器中</span></span><br><span class="line">      <span class="keyword">const</span> delayEnter =</span><br><span class="line">        activeBranch &amp;&amp;</span><br><span class="line">        pendingBranch!.<span class="property">transition</span> &amp;&amp;</span><br><span class="line">        pendingBranch!.<span class="property">transition</span>.<span class="property">mode</span> === <span class="string">&quot;out-in&quot;</span>;</span><br><span class="line">      <span class="keyword">if</span> (delayEnter) &#123;</span><br><span class="line">        activeBranch!.<span class="property">transition</span>!.<span class="property">afterLeave</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (pendingId === suspense.<span class="property">pendingId</span>) &#123;</span><br><span class="line">            <span class="title function_">move</span>(pendingBranch!, container, anchor, <span class="title class_">MoveType</span>.<span class="property">ENTER</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// this is initial anchor on mount</span></span><br><span class="line">      <span class="keyword">let</span> &#123; anchor &#125; = suspense;</span><br><span class="line">      <span class="comment">// 卸载当前的活跃分支</span></span><br><span class="line">      <span class="comment">// unmount current active tree</span></span><br><span class="line">      <span class="keyword">if</span> (activeBranch) &#123;</span><br><span class="line">        <span class="comment">// if the fallback tree was mounted, it may have been moved</span></span><br><span class="line">        <span class="comment">// as part of a parent suspense. get the latest anchor for insertion</span></span><br><span class="line">        anchor = <span class="title function_">next</span>(activeBranch);</span><br><span class="line">        <span class="title function_">unmount</span>(activeBranch, parentComponent, suspense, <span class="literal">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 没有transition的延迟切入，则在此move</span></span><br><span class="line">      <span class="keyword">if</span> (!delayEnter) &#123;</span><br><span class="line">        <span class="comment">// move content from off-dom container to actual container</span></span><br><span class="line">        <span class="title function_">move</span>(pendingBranch!, container, anchor, <span class="title class_">MoveType</span>.<span class="property">ENTER</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将等待分支设置为活跃分支</span></span><br><span class="line">    <span class="title function_">setActiveBranch</span>(suspense, pendingBranch!);</span><br><span class="line">    <span class="comment">// 由于等待分支已经成为了活跃分支，因此置空等待分支，不必渲染降级内容</span></span><br><span class="line">    suspense.<span class="property">pendingBranch</span> = <span class="literal">null</span>;</span><br><span class="line">    suspense.<span class="property">isInFallback</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// flush buffered effects</span></span><br><span class="line">    <span class="comment">// check if there is a pending parent suspense</span></span><br><span class="line">    <span class="keyword">let</span> parent = suspense.<span class="property">parent</span>;</span><br><span class="line">    <span class="keyword">let</span> hasUnresolvedAncestor = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 向上查找Suspense，将所有未执行的副作用合并到最外层的处于等待期的Suspense中</span></span><br><span class="line">    <span class="comment">// 这样就能等所有的Suspense都解决之后，再一并执行副作用</span></span><br><span class="line">    <span class="keyword">while</span> (parent) &#123;</span><br><span class="line">      <span class="keyword">if</span> (parent.<span class="property">pendingBranch</span>) &#123;</span><br><span class="line">        <span class="comment">// found a pending parent suspense, merge buffered post jobs</span></span><br><span class="line">        <span class="comment">// into that parent</span></span><br><span class="line">        parent.<span class="property">effects</span>.<span class="title function_">push</span>(...effects);</span><br><span class="line">        <span class="comment">// 标记尚有未解决的先代异步组件</span></span><br><span class="line">        hasUnresolvedAncestor = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      parent = parent.<span class="property">parent</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向上查找的Suspense链没有未解决的，则处理副作用并清空副作用列表</span></span><br><span class="line">    <span class="comment">// no pending parent suspense, flush all jobs</span></span><br><span class="line">    <span class="keyword">if</span> (!hasUnresolvedAncestor) &#123;</span><br><span class="line">      <span class="title function_">queuePostFlushCb</span>(effects);</span><br><span class="line">    &#125;</span><br><span class="line">    suspense.<span class="property">effects</span> = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发异步组件的onResolve事件</span></span><br><span class="line">    <span class="comment">// invoke @resolve event</span></span><br><span class="line">    <span class="title function_">triggerEvent</span>(vnode, <span class="string">&quot;onResolve&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="2-2-2-suspense-fallback"><a href="#2-2-2-suspense-fallback" class="headerlink" title="2.2.2 suspense.fallback"></a>2.2.2 <code>suspense.fallback</code></h5><p><strong><code>fallback</code></strong>用于挂载降级内容<code>Fallback</code>。</p><ul><li>触发<code>onFallback</code>事件；</li><li>有延迟动画<code>transition</code>则在其<code>afterLeave</code>动画钩子中挂载<code>Fallback</code>内容；</li><li>卸载当前活跃分支；</li><li>若没有延迟动画则直接挂载<code>Fallback</code>内容。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">suspense</span>: <span class="title class_">SuspenseBoundary</span> = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">fallback</span>(<span class="params">fallbackVNode</span>) &#123;</span><br><span class="line">    <span class="comment">// 没有等待分支则返回</span></span><br><span class="line">    <span class="keyword">if</span> (!suspense.<span class="property">pendingBranch</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解构变量</span></span><br><span class="line">    <span class="keyword">const</span> &#123; vnode, activeBranch, parentComponent, container, isSVG &#125; = suspense;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发onFallback</span></span><br><span class="line">    <span class="comment">// invoke @fallback event</span></span><br><span class="line">    <span class="title function_">triggerEvent</span>(vnode, <span class="string">&quot;onFallback&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切换了锚点</span></span><br><span class="line">    <span class="keyword">const</span> anchor = <span class="title function_">next</span>(activeBranch!);</span><br><span class="line">    <span class="comment">// 函数：挂载降级内容</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">mountFallback</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (!suspense.<span class="property">isInFallback</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// mount the fallback tree</span></span><br><span class="line">      <span class="title function_">patch</span>(</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        fallbackVNode,</span><br><span class="line">        container,</span><br><span class="line">        anchor,</span><br><span class="line">        parentComponent,</span><br><span class="line">        <span class="literal">null</span>, <span class="comment">// fallback tree will not have suspense context</span></span><br><span class="line">        isSVG,</span><br><span class="line">        slotScopeIds,</span><br><span class="line">        optimized</span><br><span class="line">      );</span><br><span class="line">      <span class="title function_">setActiveBranch</span>(suspense, fallbackVNode);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// transition延迟动画</span></span><br><span class="line">    <span class="keyword">const</span> delayEnter =</span><br><span class="line">      fallbackVNode.<span class="property">transition</span> &amp;&amp; fallbackVNode.<span class="property">transition</span>.<span class="property">mode</span> === <span class="string">&quot;out-in&quot;</span>;</span><br><span class="line">    <span class="comment">// 有延迟动画则在afterLeave动画钩子中挂载降级内容</span></span><br><span class="line">    <span class="keyword">if</span> (delayEnter) &#123;</span><br><span class="line">      activeBranch!.<span class="property">transition</span>!.<span class="property">afterLeave</span> = mountFallback;</span><br><span class="line">    &#125;</span><br><span class="line">    suspense.<span class="property">isInFallback</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 卸载活跃分支</span></span><br><span class="line">    <span class="comment">// unmount current active branch</span></span><br><span class="line">    <span class="title function_">unmount</span>(</span><br><span class="line">      activeBranch!,</span><br><span class="line">      parentComponent,</span><br><span class="line">      <span class="literal">null</span>, <span class="comment">// no suspense so unmount hooks fire now</span></span><br><span class="line">      <span class="literal">true</span> <span class="comment">// shouldRemove</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有延迟动画则直接挂载降级内容</span></span><br><span class="line">    <span class="keyword">if</span> (!delayEnter) &#123;</span><br><span class="line">      <span class="title function_">mountFallback</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="2-2-3-suspense-move"><a href="#2-2-3-suspense-move" class="headerlink" title="2.2.3 suspense.move"></a>2.2.3 <code>suspense.move</code></h5><p>处理活跃分支和容器。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// function createSuspenseBoundary</span></span><br><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="attr">p</span>: patch,</span><br><span class="line">  <span class="comment">// 这个move想下面的suspense.move里用到的</span></span><br><span class="line">  <span class="attr">m</span>: move,</span><br><span class="line">  <span class="attr">um</span>: unmount,</span><br><span class="line">  <span class="attr">n</span>: next,</span><br><span class="line">  <span class="attr">o</span>: &#123; parentNode, remove &#125;,</span><br><span class="line">&#125; = rendererInternals;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">suspense</span>: <span class="title class_">SuspenseBoundary</span> = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">move</span>(<span class="params">container, anchor, <span class="keyword">type</span></span>) &#123;</span><br><span class="line">    suspense.<span class="property">activeBranch</span> &amp;&amp;</span><br><span class="line">      <span class="comment">// 这个move不是suspense.move，而是在 createSuspenseBoundary 函数中解构 rendererInternals 得到的</span></span><br><span class="line">      <span class="title function_">move</span>(suspense.<span class="property">activeBranch</span>, container, anchor, <span class="keyword">type</span>);</span><br><span class="line">    suspense.<span class="property">container</span> = container;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="2-2-4-suspense-next"><a href="#2-2-4-suspense-next" class="headerlink" title="2.2.4 suspense.next"></a>2.2.4 <code>suspense.next</code></h5><p><code>next()</code>递归取到<code>supense</code>的活跃分支链的末端。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">suspense</span>: <span class="title class_">SuspenseBoundary</span> = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> suspense.<span class="property">activeBranch</span> &amp;&amp; <span class="title function_">next</span>(suspense.<span class="property">activeBranch</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="2-2-5-suspense-registerDep"><a href="#2-2-5-suspense-registerDep" class="headerlink" title="2.2.5 suspense.registerDep"></a>2.2.5 <code>suspense.registerDep</code></h5><p><code>registerDep</code>用于注册依赖，接收一个实例<code>instance</code>和渲染副作用函数<code>setupRenderEffect</code>。若注册时，<code>suspense</code>处于等待期，则其异步依赖数量<code>+1</code>；随后注册实例<code>instance</code>上的异步依赖<code>asyncDep</code>，得到一个<code>Promise</code>。在<code>then</code>中使用<code>handleSetupResult</code>来处理异步依赖的解决结果，并执行渲染副作用<code>setupRenderEffect</code>；如果<code>suspense</code>处于等待期，则将其<code>deps</code>数量<code>-1</code>，因为一开始<code>+1</code>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">suspense</span>: <span class="title class_">SuspenseBoundary</span> = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title function_">registerDep</span>(<span class="params">instance, setupRenderEffect</span>) &#123;</span><br><span class="line">    <span class="comment">// 等待期 异步依赖数量+1</span></span><br><span class="line">    <span class="keyword">const</span> isInPendingSuspense = !!suspense.<span class="property">pendingBranch</span>;</span><br><span class="line">    <span class="keyword">if</span> (isInPendingSuspense) &#123;</span><br><span class="line">      suspense.<span class="property">deps</span>++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> hydratedEl = instance.<span class="property">vnode</span>.<span class="property">el</span>;</span><br><span class="line">    <span class="comment">// 注册异步依赖</span></span><br><span class="line">    instance</span><br><span class="line">      .<span class="property">asyncDep</span>!.<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">handleError</span>(err, instance, <span class="title class_">ErrorCodes</span>.<span class="property">SETUP_FUNCTION</span>);</span><br><span class="line">      &#125;)</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function">(<span class="params">asyncSetupResult</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// retry when the setup() promise resolves.</span></span><br><span class="line">        <span class="comment">// component may have been unmounted before resolve.</span></span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">          instance.<span class="property">isUnmounted</span> ||</span><br><span class="line">          suspense.<span class="property">isUnmounted</span> ||</span><br><span class="line">          suspense.<span class="property">pendingId</span> !== instance.<span class="property">suspenseId</span></span><br><span class="line">        ) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// retry from this component</span></span><br><span class="line">        instance.<span class="property">asyncResolved</span> = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">const</span> &#123; vnode &#125; = instance;</span><br><span class="line">        <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">          <span class="title function_">pushWarningContext</span>(vnode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理异步依赖运行的结果</span></span><br><span class="line">        <span class="title function_">handleSetupResult</span>(instance, asyncSetupResult, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (hydratedEl) &#123;</span><br><span class="line">          <span class="comment">// vnode may have been replaced if an update happened before the</span></span><br><span class="line">          <span class="comment">// async dep is resolved.</span></span><br><span class="line">          vnode.<span class="property">el</span> = hydratedEl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> placeholder = !hydratedEl &amp;&amp; instance.<span class="property">subTree</span>.<span class="property">el</span>;</span><br><span class="line">        <span class="comment">// 调用传入的setupRenderEffect处理渲染副作用</span></span><br><span class="line">        <span class="title function_">setupRenderEffect</span>(</span><br><span class="line">          instance,</span><br><span class="line">          vnode,</span><br><span class="line">          <span class="comment">// component may have been moved before resolve.</span></span><br><span class="line">          <span class="comment">// if this is not a hydration, instance.subTree will be the comment</span></span><br><span class="line">          <span class="comment">// placeholder.</span></span><br><span class="line">          <span class="title function_">parentNode</span>(hydratedEl || instance.<span class="property">subTree</span>.<span class="property">el</span>!)!,</span><br><span class="line">          <span class="comment">// anchor will not be used if this is hydration, so only need to</span></span><br><span class="line">          <span class="comment">// consider the comment placeholder case.</span></span><br><span class="line">          hydratedEl ? <span class="literal">null</span> : <span class="title function_">next</span>(instance.<span class="property">subTree</span>),</span><br><span class="line">          suspense,</span><br><span class="line">          isSVG,</span><br><span class="line">          optimized</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">if</span> (placeholder) &#123;</span><br><span class="line">          <span class="title function_">remove</span>(placeholder);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">updateHOCHostEl</span>(instance, vnode.<span class="property">el</span>);</span><br><span class="line">        <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">          <span class="title function_">popWarningContext</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 异步依赖已解决，若suspense还在等待期，则异步依赖数量-1，当归零时调用resolve</span></span><br><span class="line">        <span class="comment">// only decrease deps count if suspense is not already resolved</span></span><br><span class="line">        <span class="keyword">if</span> (isInPendingSuspense &amp;&amp; --suspense.<span class="property">deps</span> === <span class="number">0</span>) &#123;</span><br><span class="line">          suspense.<span class="title function_">resolve</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="2-2-6-unmount"><a href="#2-2-6-unmount" class="headerlink" title="2.2.6 unmount"></a>2.2.6 <code>unmount</code></h5><p>卸载<code>suspense</code>：将<code>suspense.isUnmounted</code>置为<code>true</code>，卸载活跃分支和等待分支。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">suspense</span>: <span class="title class_">SuspenseBoundary</span> = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title function_">unmount</span>(<span class="params">parentSuspense, doRemove</span>) &#123;</span><br><span class="line">    suspense.<span class="property">isUnmounted</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (suspense.<span class="property">activeBranch</span>) &#123;</span><br><span class="line">      <span class="comment">// 从suspenseInternals中拿到的unmount</span></span><br><span class="line">      <span class="title function_">unmount</span>(suspense.<span class="property">activeBranch</span>, parentComponent, parentSuspense, doRemove);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (suspense.<span class="property">pendingBranch</span>) &#123;</span><br><span class="line">      <span class="comment">// 从suspenseInternals中拿到的unmount</span></span><br><span class="line">      <span class="title function_">unmount</span>(</span><br><span class="line">        suspense.<span class="property">pendingBranch</span>,</span><br><span class="line">        parentComponent,</span><br><span class="line">        parentSuspense,</span><br><span class="line">        doRemove</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3源码系列（八）：render与patch — 了解diff</title>
      <link href="/articals/876e332/"/>
      <url>/articals/876e332/</url>
      
        <content type="html"><![CDATA[<p>上一篇中，我们理清了<code>createApp</code>走的流程，最后通过<code>createAppAPI</code>创建了<code>app</code>。虽然<code>app</code>上的各种属性和方法也都已经有所了解，但其中的<code>mount</code>和<code>unmount</code>方法，都是通过调用<code>render</code>函数来完成的。尽管我们很好奇<code>render</code>函数的故事，可是<code>baseCreateRenderer</code>函数有<code>2000+</code>行，基本都和<code>render</code>相关，因此拆解到本文里叙述，以下方法都定义在<code>baseCreateRenderer</code>函数中。</p><h2 id="一、render"><a href="#一、render" class="headerlink" title="一、render"></a>一、<code>render</code></h2><p><code>render</code>也不神秘了，毕竟在上一篇文章中露过面，当然这里也顺带提一下 <code>baseCreateRenderer</code>从参数<code>options</code>中解构的一些方法，基本都是些增删改查、复制节点的功能，见名知义了。主要看看<code>render</code>，接收<code>vnode</code>、<code>container</code>、<code>isSvg</code>三个参数。调用<code>unmount</code>卸载或者调用<code>patch</code>进行节点比较从而继续下一步。</p><ul><li>判断<code>vnode</code>是否为<code>null</code>。如果对上一篇文章还有印象，那么就会知道，相当于是判断调用的是<code>app.mount</code>还是<code>app.unmount</code>方法，因为<code>app.unmount</code>方法传入的<code>vnode</code>就是<code>null</code>。那么这里对应的就是在<code>app.unmount</code>里使用<code>unmount</code>函数来卸载；而在<code>app.mount</code>里进行<code>patch</code>比较。</li><li>调用<code>flushPostFlushCbs()</code>，其中的单词<code>Post</code>的含义，看过第一篇讲解<code>watch</code>的同学也许能猜出来，表示执行时机是在组件更新后。这个函数便是执行组件更新后的一些回调。</li><li>把<code>vnode</code>挂到<code>container</code>上，即旧的虚拟<code>DOM</code>。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="attr">insert</span>: hostInsert,</span><br><span class="line">  <span class="attr">remove</span>: hostRemove,</span><br><span class="line">  <span class="attr">patchProp</span>: hostPatchProp,</span><br><span class="line">  <span class="attr">createElement</span>: hostCreateElement,</span><br><span class="line">  <span class="attr">createText</span>: hostCreateText,</span><br><span class="line">  <span class="attr">createComment</span>: hostCreateComment,</span><br><span class="line">  <span class="attr">setText</span>: hostSetText,</span><br><span class="line">  <span class="attr">setElementText</span>: hostSetElementText,</span><br><span class="line">  <span class="attr">parentNode</span>: hostParentNode,</span><br><span class="line">  <span class="attr">nextSibling</span>: hostNextSibling,</span><br><span class="line">  <span class="attr">setScopeId</span>: hostSetScopeId = <span class="variable constant_">NOOP</span>,</span><br><span class="line">  <span class="attr">cloneNode</span>: hostCloneNode,</span><br><span class="line">  <span class="attr">insertStaticContent</span>: hostInsertStaticContent,</span><br><span class="line">&#125; = options;</span><br><span class="line"></span><br><span class="line"><span class="comment">// render</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">render</span>: <span class="title class_">RootRenderFunction</span> = <span class="function">(<span class="params">vnode, container, isSVG</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (vnode == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (container.<span class="property">_vnode</span>) &#123;</span><br><span class="line">      <span class="title function_">unmount</span>(container.<span class="property">_vnode</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 新旧节点的对比</span></span><br><span class="line">    <span class="title function_">patch</span>(container.<span class="property">_vnode</span> || <span class="literal">null</span>, vnode, container, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, isSVG);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">flushPostFlushCbs</span>();</span><br><span class="line">  <span class="comment">// 记录旧节点</span></span><br><span class="line">  container.<span class="property">_vnode</span> = vnode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="二、patch"><a href="#二、patch" class="headerlink" title="二、patch"></a>二、<code>patch</code></h2><h3 id="1-patch"><a href="#1-patch" class="headerlink" title="1. patch"></a>1. <code>patch</code></h3><p><code>patch</code>函数里主要对新旧节点也就是<strong>虚拟<code>DOM</code>的对比</strong>，常说的<code>vue</code>里的<code>diff</code>算法，便是从<code>patch</code>开始。结合<code>render</code>函数来看，我们知道，旧的虚拟<code>DOM</code>存储在<code>container._vnode</code>上。那么<code>diff</code>的方式就在<code>patch</code>中了：</p><ul><li><p>新旧节点相同，直接返回；</p></li><li><p>旧节点存在，且新旧节点类型不同，则旧节点不可复用，将其卸载(<code>unmount</code>)，锚点<code>anchor</code>移向下一个节点；</p></li><li><p>新节点是否静态节点标记；</p></li><li><p>根据新节点的类型，相应地调用不同类型的处理方法：</p><ul><li>文本：<code>processText</code>；</li><li>注释：<code>processCommentNode</code>；</li><li>静态节点：<code>mountStaticNode</code>或<code>patchStaticNode</code>；</li><li>文档片段：<code>processFragment</code>；</li><li>其它。</li></ul></li></ul><p>在 其它 这一项中，又根据形状标记 <code>shapeFlag</code>等，判断是 元素节点、组件节点，或是<code>Teleport</code>、<code>Suspense</code>等，然后调用相应的<code>process</code>去处理。最后处理<code>template</code>中的<code>ref</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Note: functions inside this closure should use `const xxx = () =&gt; &#123;&#125;`</span></span><br><span class="line"><span class="comment">// style in order to prevent being inlined by minifiers.</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">patch</span>: <span class="title class_">PatchFn</span> = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  n1,</span></span></span><br><span class="line"><span class="params"><span class="function">  n2,</span></span></span><br><span class="line"><span class="params"><span class="function">  container,</span></span></span><br><span class="line"><span class="params"><span class="function">  anchor = <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentComponent = <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentSuspense = <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  isSVG = <span class="literal">false</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  slotScopeIds = <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  optimized = __DEV__ &amp;&amp; isHmrUpdating ? <span class="literal">false</span> : !!n2.dynamicChildren</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 新旧节点相同，直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (n1 === n2) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 旧节点存在，且新旧节点类型不同，卸载旧节点，锚点anchor后移</span></span><br><span class="line">  <span class="comment">// patching &amp; not same type, unmount old tree</span></span><br><span class="line">  <span class="keyword">if</span> (n1 &amp;&amp; !<span class="title function_">isSameVNodeType</span>(n1, n2)) &#123;</span><br><span class="line">    anchor = <span class="title function_">getNextHostNode</span>(n1);</span><br><span class="line">    <span class="title function_">unmount</span>(n1, parentComponent, parentSuspense, <span class="literal">true</span>);</span><br><span class="line">    n1 = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是否静态节点优化</span></span><br><span class="line">  <span class="keyword">if</span> (n2.<span class="property">patchFlag</span> === <span class="title class_">PatchFlags</span>.<span class="property">BAIL</span>) &#123;</span><br><span class="line">    optimized = <span class="literal">false</span>;</span><br><span class="line">    n2.<span class="property">dynamicChildren</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="keyword">type</span>, ref, shapeFlag &#125; = n2;</span><br><span class="line">  <span class="keyword">switch</span> (<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Text</span>:</span><br><span class="line">      <span class="title function_">processText</span>(n1, n2, container, anchor);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Comment</span>:</span><br><span class="line">      <span class="title function_">processCommentNode</span>(n1, n2, container, anchor);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Static</span>:</span><br><span class="line">      <span class="keyword">if</span> (n1 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="title function_">mountStaticNode</span>(n2, container, anchor, isSVG);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        <span class="title function_">patchStaticNode</span>(n1, n2, container, isSVG);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Fragment</span>:</span><br><span class="line">      <span class="title function_">processFragment</span>(</span><br><span class="line">        n1,</span><br><span class="line">        n2,</span><br><span class="line">        container,</span><br><span class="line">        anchor,</span><br><span class="line">        parentComponent,</span><br><span class="line">        parentSuspense,</span><br><span class="line">        isSVG,</span><br><span class="line">        slotScopeIds,</span><br><span class="line">        optimized</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">if</span> (shapeFlag &amp; <span class="title class_">ShapeFlags</span>.<span class="property">ELEMENT</span>) &#123;</span><br><span class="line">        <span class="title function_">processElement</span>(</span><br><span class="line">          n1,</span><br><span class="line">          n2,</span><br><span class="line">          container,</span><br><span class="line">          anchor,</span><br><span class="line">          parentComponent,</span><br><span class="line">          parentSuspense,</span><br><span class="line">          isSVG,</span><br><span class="line">          slotScopeIds,</span><br><span class="line">          optimized</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; <span class="title class_">ShapeFlags</span>.<span class="property">COMPONENT</span>) &#123;</span><br><span class="line">        <span class="title function_">processComponent</span>(</span><br><span class="line">          n1,</span><br><span class="line">          n2,</span><br><span class="line">          container,</span><br><span class="line">          anchor,</span><br><span class="line">          parentComponent,</span><br><span class="line">          parentSuspense,</span><br><span class="line">          isSVG,</span><br><span class="line">          slotScopeIds,</span><br><span class="line">          optimized</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; <span class="title class_">ShapeFlags</span>.<span class="property">TELEPORT</span>) &#123;</span><br><span class="line">        (<span class="keyword">type</span> <span class="keyword">as</span> <span class="keyword">typeof</span> <span class="title class_">TeleportImpl</span>).<span class="title function_">process</span>(</span><br><span class="line">          n1 <span class="keyword">as</span> <span class="title class_">TeleportVNode</span>,</span><br><span class="line">          n2 <span class="keyword">as</span> <span class="title class_">TeleportVNode</span>,</span><br><span class="line">          container,</span><br><span class="line">          anchor,</span><br><span class="line">          parentComponent,</span><br><span class="line">          parentSuspense,</span><br><span class="line">          isSVG,</span><br><span class="line">          slotScopeIds,</span><br><span class="line">          optimized,</span><br><span class="line">          internals</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__FEATURE_SUSPENSE__ &amp;&amp; shapeFlag &amp; <span class="title class_">ShapeFlags</span>.<span class="property">SUSPENSE</span>) &#123;</span><br><span class="line">        (<span class="keyword">type</span> <span class="keyword">as</span> <span class="keyword">typeof</span> <span class="title class_">SuspenseImpl</span>).<span class="title function_">process</span>(</span><br><span class="line">          n1,</span><br><span class="line">          n2,</span><br><span class="line">          container,</span><br><span class="line">          anchor,</span><br><span class="line">          parentComponent,</span><br><span class="line">          parentSuspense,</span><br><span class="line">          isSVG,</span><br><span class="line">          slotScopeIds,</span><br><span class="line">          optimized,</span><br><span class="line">          internals</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        <span class="title function_">warn</span>(<span class="string">&quot;Invalid VNode type:&quot;</span>, <span class="keyword">type</span>, <span class="string">`(<span class="subst">$&#123;<span class="keyword">typeof</span> <span class="keyword">type</span>&#125;</span>)`</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理 template 中的 ref</span></span><br><span class="line">  <span class="comment">// set ref</span></span><br><span class="line">  <span class="keyword">if</span> (ref != <span class="literal">null</span> &amp;&amp; parentComponent) &#123;</span><br><span class="line">    <span class="title function_">setRef</span>(ref, n1 &amp;&amp; n1.<span class="property">ref</span>, parentSuspense, n2 || n1, !n2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-processText"><a href="#2-processText" class="headerlink" title="2. processText"></a>2. <code>processText</code></h3><p>文本节点的处理十分简单，没有旧节点则新建并插入新节点；有旧节点，且节点内容不一致，则设置为新节点的内容。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">processText</span>: <span class="title class_">ProcessTextOrCommentFn</span> = <span class="function">(<span class="params">n1, n2, container, anchor</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (n1 == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="title function_">hostInsert</span>(</span><br><span class="line">      (n2.<span class="property">el</span> = <span class="title function_">hostCreateText</span>(n2.<span class="property">children</span> <span class="keyword">as</span> <span class="built_in">string</span>)),</span><br><span class="line">      container,</span><br><span class="line">      anchor</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> el = (n2.<span class="property">el</span> = n1.<span class="property">el</span>!);</span><br><span class="line">    <span class="keyword">if</span> (n2.<span class="property">children</span> !== n1.<span class="property">children</span>) &#123;</span><br><span class="line">      <span class="title function_">hostSetText</span>(el, n2.<span class="property">children</span> <span class="keyword">as</span> <span class="built_in">string</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-processCommontNode"><a href="#3-processCommontNode" class="headerlink" title="3. processCommontNode"></a>3. <code>processCommontNode</code></h3><p>不支持动态的注视节点，因此只要旧节点存在，就使用旧节点的内容。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">processCommentNode</span>: <span class="title class_">ProcessTextOrCommentFn</span> = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  n1,</span></span></span><br><span class="line"><span class="params"><span class="function">  n2,</span></span></span><br><span class="line"><span class="params"><span class="function">  container,</span></span></span><br><span class="line"><span class="params"><span class="function">  anchor</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (n1 == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="title function_">hostInsert</span>(</span><br><span class="line">      (n2.<span class="property">el</span> = <span class="title function_">hostCreateComment</span>((n2.<span class="property">children</span> <span class="keyword">as</span> <span class="built_in">string</span>) || <span class="string">&quot;&quot;</span>)),</span><br><span class="line">      container,</span><br><span class="line">      anchor</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// there&#x27;s no support for dynamic comments</span></span><br><span class="line">    n2.<span class="property">el</span> = n1.<span class="property">el</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-mountStaticNode-和-patchStaticNode"><a href="#4-mountStaticNode-和-patchStaticNode" class="headerlink" title="4. mountStaticNode 和 patchStaticNode"></a>4. <code>mountStaticNode</code> 和 <code>patchStaticNode</code></h3><p>事实上静态节点没啥好比较的，毕竟是静态的。当没有旧节点时，则通过<code>mountStaticNode</code>创建并插入新节点；即使有旧节点，也仅在<code>_DEV_</code>条件下在<code>hmr</code>，才会使用<code>patchStaticVnode</code>做一下比较并通过<code>removeStaticNode</code>移除某些旧节点。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">mountStaticNode</span> = (<span class="params"></span></span><br><span class="line"><span class="params">  n2: VNode,</span></span><br><span class="line"><span class="params">  container: RendererElement,</span></span><br><span class="line"><span class="params">  anchor: RendererNode | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  isSVG: <span class="built_in">boolean</span></span></span><br><span class="line"><span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// static nodes are only present when used with compiler-dom/runtime-dom</span></span><br><span class="line">  <span class="comment">// which guarantees presence of hostInsertStaticContent.</span></span><br><span class="line">  [n2.<span class="property">el</span>, n2.<span class="property">anchor</span>] = hostInsertStaticContent!(</span><br><span class="line">    n2.<span class="property">children</span> <span class="keyword">as</span> <span class="built_in">string</span>,</span><br><span class="line">    container,</span><br><span class="line">    anchor,</span><br><span class="line">    isSVG,</span><br><span class="line">    n2.<span class="property">el</span>,</span><br><span class="line">    n2.<span class="property">anchor</span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Dev / HMR only</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">patchStaticNode</span> = (<span class="params"></span></span><br><span class="line"><span class="params">  n1: VNode,</span></span><br><span class="line"><span class="params">  n2: VNode,</span></span><br><span class="line"><span class="params">  container: RendererElement,</span></span><br><span class="line"><span class="params">  isSVG: <span class="built_in">boolean</span></span></span><br><span class="line"><span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// static nodes are only patched during dev for HMR</span></span><br><span class="line">  <span class="keyword">if</span> (n2.<span class="property">children</span> !== n1.<span class="property">children</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> anchor = <span class="title function_">hostNextSibling</span>(n1.<span class="property">anchor</span>!);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除已有的静态节点，并插入新的节点</span></span><br><span class="line">    <span class="comment">// remove existing</span></span><br><span class="line">    <span class="title function_">removeStaticNode</span>(n1);</span><br><span class="line">    <span class="comment">// insert new</span></span><br><span class="line">    [n2.<span class="property">el</span>, n2.<span class="property">anchor</span>] = hostInsertStaticContent!(</span><br><span class="line">      n2.<span class="property">children</span> <span class="keyword">as</span> <span class="built_in">string</span>,</span><br><span class="line">      container,</span><br><span class="line">      anchor,</span><br><span class="line">      isSVG</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    n2.<span class="property">el</span> = n1.<span class="property">el</span>;</span><br><span class="line">    n2.<span class="property">anchor</span> = n1.<span class="property">anchor</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// removeStaticNode：从 n1.el 至 n1.anchor 的内容被遍历移除</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">removeStaticNode</span> = (<span class="params">&#123; el, anchor &#125;: VNode</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> next;</span><br><span class="line">  <span class="keyword">while</span> (el &amp;&amp; el !== anchor) &#123;</span><br><span class="line">    next = <span class="title function_">hostNextSibling</span>(el);</span><br><span class="line">    <span class="title function_">hostRemove</span>(el);</span><br><span class="line">    el = next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">hostRemove</span>(anchor!);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="5-processFragment"><a href="#5-processFragment" class="headerlink" title="5. processFragment"></a>5. <code>processFragment</code></h3><h4 id="5-1-processFragment"><a href="#5-1-processFragment" class="headerlink" title="5.1 processFragment"></a>5.1 <code>processFragment</code></h4><p><code>vue3</code>的单文件组件里，不再需要加一个根节点，因为使用了文档片段<code>fragment</code>来承载子节点，最后再一并添加到文档中。</p><ul><li><p>若旧的片段节点为空，则插入起始锚点，挂载新的子节点；</p></li><li><p>旧的片段不为空：</p><ul><li>存在优化条件时：使用<code>patchBlockChildren</code>优化<code>diff</code>；</li><li>不存在优化条件时：使用<code>patchChildren</code>进行全量<code>diff</code>。</li></ul></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">processFragment</span> = (<span class="params"></span></span><br><span class="line"><span class="params">  n1: VNode | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  n2: VNode,</span></span><br><span class="line"><span class="params">  container: RendererElement,</span></span><br><span class="line"><span class="params">  anchor: RendererNode | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  parentComponent: ComponentInternalInstance | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  parentSuspense: SuspenseBoundary | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  isSVG: <span class="built_in">boolean</span>,</span></span><br><span class="line"><span class="params">  slotScopeIds: <span class="built_in">string</span>[] | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  optimized: <span class="built_in">boolean</span></span></span><br><span class="line"><span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 锚点</span></span><br><span class="line">  <span class="keyword">const</span> fragmentStartAnchor = (n2.<span class="property">el</span> = n1 ? n1.<span class="property">el</span> : <span class="title function_">hostCreateText</span>(<span class="string">&quot;&quot;</span>))!;</span><br><span class="line">  <span class="keyword">const</span> fragmentEndAnchor = (n2.<span class="property">anchor</span> = n1 ? n1.<span class="property">anchor</span> : <span class="title function_">hostCreateText</span>(<span class="string">&quot;&quot;</span>))!;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> &#123; patchFlag, dynamicChildren, <span class="attr">slotScopeIds</span>: fragmentSlotScopeIds &#125; = n2;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开发环境热更新时，强制全量diff</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    __DEV__ &amp;&amp;</span><br><span class="line">    <span class="comment">// #5523 dev root fragment may inherit directives</span></span><br><span class="line">    (isHmrUpdating || patchFlag &amp; <span class="title class_">PatchFlags</span>.<span class="property">DEV_ROOT_FRAGMENT</span>)</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// HMR updated / Dev root fragment (w/ comments), force full diff</span></span><br><span class="line">    patchFlag = <span class="number">0</span>;</span><br><span class="line">    optimized = <span class="literal">false</span>;</span><br><span class="line">    dynamicChildren = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查是否是插槽</span></span><br><span class="line">  <span class="comment">// check if this is a slot fragment with :slotted scope ids</span></span><br><span class="line">  <span class="keyword">if</span> (fragmentSlotScopeIds) &#123;</span><br><span class="line">    slotScopeIds = slotScopeIds</span><br><span class="line">      ? slotScopeIds.<span class="title function_">concat</span>(fragmentSlotScopeIds)</span><br><span class="line">      : fragmentSlotScopeIds;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当旧的片段为空时，挂载新的片段的子节点</span></span><br><span class="line">  <span class="keyword">if</span> (n1 == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="title function_">hostInsert</span>(fragmentStartAnchor, container, anchor);</span><br><span class="line">    <span class="title function_">hostInsert</span>(fragmentEndAnchor, container, anchor);</span><br><span class="line">    <span class="comment">// a fragment can only have array children</span></span><br><span class="line">    <span class="comment">// since they are either generated by the compiler, or implicitly created</span></span><br><span class="line">    <span class="comment">// from arrays.</span></span><br><span class="line">    <span class="title function_">mountChildren</span>(</span><br><span class="line">      n2.<span class="property">children</span> <span class="keyword">as</span> <span class="title class_">VNodeArrayChildren</span>,</span><br><span class="line">      container,</span><br><span class="line">      fragmentEndAnchor,</span><br><span class="line">      parentComponent,</span><br><span class="line">      parentSuspense,</span><br><span class="line">      isSVG,</span><br><span class="line">      slotScopeIds,</span><br><span class="line">      optimized</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 当旧片段不为空时，启用优化则使用patchBlockChildren</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      patchFlag &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">      patchFlag &amp; <span class="title class_">PatchFlags</span>.<span class="property">STABLE_FRAGMENT</span> &amp;&amp;</span><br><span class="line">      dynamicChildren &amp;&amp;</span><br><span class="line">      <span class="comment">// #2715 the previous fragment could&#x27;ve been a BAILed one as a result</span></span><br><span class="line">      <span class="comment">// of renderSlot() with no valid children</span></span><br><span class="line">      n1.<span class="property">dynamicChildren</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// a stable fragment (template root or &lt;template v-for&gt;) doesn&#x27;t need to</span></span><br><span class="line">      <span class="comment">// patch children order, but it may contain dynamicChildren.</span></span><br><span class="line">      <span class="title function_">patchBlockChildren</span>(</span><br><span class="line">        n1.<span class="property">dynamicChildren</span>,</span><br><span class="line">        dynamicChildren,</span><br><span class="line">        container,</span><br><span class="line">        parentComponent,</span><br><span class="line">        parentSuspense,</span><br><span class="line">        isSVG,</span><br><span class="line">        slotScopeIds</span><br><span class="line">      );</span><br><span class="line">      <span class="comment">// 开发环境，热更新 处理静态子节点</span></span><br><span class="line">      <span class="keyword">if</span> (__DEV__ &amp;&amp; parentComponent &amp;&amp; parentComponent.<span class="property">type</span>.<span class="property">__hmrId</span>) &#123;</span><br><span class="line">        <span class="title function_">traverseStaticChildren</span>(n1, n2);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">        <span class="comment">// #2080 if the stable fragment has a key, it&#x27;s a &lt;template v-for&gt; that may</span></span><br><span class="line">        <span class="comment">//  get moved around. Make sure all root level vnodes inherit el.</span></span><br><span class="line">        <span class="comment">// #2134 or if it&#x27;s a component root, it may also get moved around</span></span><br><span class="line">        <span class="comment">// as the component is being moved.</span></span><br><span class="line">        n2.<span class="property">key</span> != <span class="literal">null</span> ||</span><br><span class="line">        (parentComponent &amp;&amp; n2 === parentComponent.<span class="property">subTree</span>)</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="title function_">traverseStaticChildren</span>(n1, n2, <span class="literal">true</span> <span class="comment">/* shallow */</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 不可优化时，使用patchChildren处理</span></span><br><span class="line">      <span class="comment">// keyed / unkeyed, or manual fragments.</span></span><br><span class="line">      <span class="comment">// for keyed &amp; unkeyed, since they are compiler generated from v-for,</span></span><br><span class="line">      <span class="comment">// each child is guaranteed to be a block so the fragment will never</span></span><br><span class="line">      <span class="comment">// have dynamicChildren.</span></span><br><span class="line">      <span class="title function_">patchChildren</span>(</span><br><span class="line">        n1,</span><br><span class="line">        n2,</span><br><span class="line">        container,</span><br><span class="line">        fragmentEndAnchor,</span><br><span class="line">        parentComponent,</span><br><span class="line">        parentSuspense,</span><br><span class="line">        isSVG,</span><br><span class="line">        slotScopeIds,</span><br><span class="line">        optimized</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="5-2-patchBlockChildren"><a href="#5-2-patchBlockChildren" class="headerlink" title="5.2 patchBlockChildren"></a>5.2 <code>patchBlockChildren</code></h4><p>在文档片段中的<code>diff</code>中，当符合优化条件时，则调用<code>patchBlockChildren</code>来进行优化的<code>diff</code>。这里主要以新节点的子节点长度为准，遍历新旧节点的子节点，更新了每个子节点的<code>container</code>然后进行<code>patch</code>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The fast path for blocks.</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">patchBlockChildren</span>: <span class="title class_">PatchBlockChildrenFn</span> = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  oldChildren,</span></span></span><br><span class="line"><span class="params"><span class="function">  newChildren,</span></span></span><br><span class="line"><span class="params"><span class="function">  fallbackContainer,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentComponent,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentSuspense,</span></span></span><br><span class="line"><span class="params"><span class="function">  isSVG,</span></span></span><br><span class="line"><span class="params"><span class="function">  slotScopeIds</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; newChildren.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> oldVNode = oldChildren[i];</span><br><span class="line">    <span class="keyword">const</span> newVNode = newChildren[i];</span><br><span class="line">    <span class="comment">// Determine the container (parent element) for the patch.</span></span><br><span class="line">    <span class="keyword">const</span> container =</span><br><span class="line">      <span class="comment">// oldVNode may be an errored async setup() component inside Suspense</span></span><br><span class="line">      <span class="comment">// which will not have a mounted element</span></span><br><span class="line">      oldVNode.<span class="property">el</span> &amp;&amp;</span><br><span class="line">      <span class="comment">// - In the case of a Fragment, we need to provide the actual parent</span></span><br><span class="line">      <span class="comment">// of the Fragment itself so it can move its children.</span></span><br><span class="line">      (oldVNode.<span class="property">type</span> === <span class="title class_">Fragment</span> ||</span><br><span class="line">        <span class="comment">// - In the case of different nodes, there is going to be a replacement</span></span><br><span class="line">        <span class="comment">// which also requires the correct parent container</span></span><br><span class="line">        !<span class="title function_">isSameVNodeType</span>(oldVNode, newVNode) ||</span><br><span class="line">        <span class="comment">// - In the case of a component, it could contain anything.</span></span><br><span class="line">        oldVNode.<span class="property">shapeFlag</span> &amp; (<span class="title class_">ShapeFlags</span>.<span class="property">COMPONENT</span> | <span class="title class_">ShapeFlags</span>.<span class="property">TELEPORT</span>))</span><br><span class="line">        ? <span class="title function_">hostParentNode</span>(oldVNode.<span class="property">el</span>)!</span><br><span class="line">        : <span class="comment">// In other cases, the parent container is not actually used so we</span></span><br><span class="line">          <span class="comment">// just pass the block element here to avoid a DOM parentNode call.</span></span><br><span class="line">          fallbackContainer;</span><br><span class="line">    <span class="title function_">patch</span>(</span><br><span class="line">      oldVNode,</span><br><span class="line">      newVNode,</span><br><span class="line">      container,</span><br><span class="line">      <span class="literal">null</span>,</span><br><span class="line">      parentComponent,</span><br><span class="line">      parentSuspense,</span><br><span class="line">      isSVG,</span><br><span class="line">      slotScopeIds,</span><br><span class="line">      <span class="literal">true</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="5-3-patchChildren"><a href="#5-3-patchChildren" class="headerlink" title="5.3 patchChildren"></a>5.3 <code>patchChildren</code></h4><p>在没有优化条件时，使用<code>patchChildren</code>对子节点进行全量的<code>diff</code>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">patchChildren</span>: <span class="title class_">PatchChildrenFn</span> = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  n1,</span></span></span><br><span class="line"><span class="params"><span class="function">  n2,</span></span></span><br><span class="line"><span class="params"><span class="function">  container,</span></span></span><br><span class="line"><span class="params"><span class="function">  anchor,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentComponent,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentSuspense,</span></span></span><br><span class="line"><span class="params"><span class="function">  isSVG,</span></span></span><br><span class="line"><span class="params"><span class="function">  slotScopeIds,</span></span></span><br><span class="line"><span class="params"><span class="function">  optimized = <span class="literal">false</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> c1 = n1 &amp;&amp; n1.<span class="property">children</span>;</span><br><span class="line">  <span class="keyword">const</span> prevShapeFlag = n1 ? n1.<span class="property">shapeFlag</span> : <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> c2 = n2.<span class="property">children</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; patchFlag, shapeFlag &#125; = n2;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 走绿色通道：用patchFlag来保证children是数组</span></span><br><span class="line">  <span class="comment">// fast path</span></span><br><span class="line">  <span class="keyword">if</span> (patchFlag &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (patchFlag &amp; <span class="title class_">PatchFlags</span>.<span class="property">KEYED_FRAGMENT</span>) &#123;</span><br><span class="line">      <span class="comment">// 有key属性的时候，根据key来进行diff</span></span><br><span class="line">      <span class="comment">// this could be either fully-keyed or mixed (some keyed some not)</span></span><br><span class="line">      <span class="comment">// presence of patchFlag means children are guaranteed to be arrays</span></span><br><span class="line">      <span class="title function_">patchKeyedChildren</span>(</span><br><span class="line">        c1 <span class="keyword">as</span> <span class="title class_">VNode</span>[],</span><br><span class="line">        c2 <span class="keyword">as</span> <span class="title class_">VNodeArrayChildren</span>,</span><br><span class="line">        container,</span><br><span class="line">        anchor,</span><br><span class="line">        parentComponent,</span><br><span class="line">        parentSuspense,</span><br><span class="line">        isSVG,</span><br><span class="line">        slotScopeIds,</span><br><span class="line">        optimized</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (patchFlag &amp; <span class="title class_">PatchFlags</span>.<span class="property">UNKEYED_FRAGMENT</span>) &#123;</span><br><span class="line">      <span class="comment">// 没有key</span></span><br><span class="line">      <span class="comment">// unkeyed</span></span><br><span class="line">      <span class="title function_">patchUnkeyedChildren</span>(</span><br><span class="line">        c1 <span class="keyword">as</span> <span class="title class_">VNode</span>[],</span><br><span class="line">        c2 <span class="keyword">as</span> <span class="title class_">VNodeArrayChildren</span>,</span><br><span class="line">        container,</span><br><span class="line">        anchor,</span><br><span class="line">        parentComponent,</span><br><span class="line">        parentSuspense,</span><br><span class="line">        isSVG,</span><br><span class="line">        slotScopeIds,</span><br><span class="line">        optimized</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 没有patchFlag的保证，则children可能为文本、数组或空</span></span><br><span class="line">  <span class="comment">// 根据形状标识来判断</span></span><br><span class="line">  <span class="comment">// children has 3 possibilities: text, array or no children.</span></span><br><span class="line">  <span class="keyword">if</span> (shapeFlag &amp; <span class="title class_">ShapeFlags</span>.<span class="property">TEXT_CHILDREN</span>) &#123;</span><br><span class="line">    <span class="comment">// 文本子节点的绿色通道</span></span><br><span class="line">    <span class="comment">// text children fast path</span></span><br><span class="line">    <span class="keyword">if</span> (prevShapeFlag &amp; <span class="title class_">ShapeFlags</span>.<span class="property">ARRAY_CHILDREN</span>) &#123;</span><br><span class="line">      <span class="title function_">unmountChildren</span>(c1 <span class="keyword">as</span> <span class="title class_">VNode</span>[], parentComponent, parentSuspense);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c2 !== c1) &#123;</span><br><span class="line">      <span class="title function_">hostSetElementText</span>(container, c2 <span class="keyword">as</span> <span class="built_in">string</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 旧的子节点是数组</span></span><br><span class="line">    <span class="keyword">if</span> (prevShapeFlag &amp; <span class="title class_">ShapeFlags</span>.<span class="property">ARRAY_CHILDREN</span>) &#123;</span><br><span class="line">      <span class="comment">// prev children was array</span></span><br><span class="line">      <span class="keyword">if</span> (shapeFlag &amp; <span class="title class_">ShapeFlags</span>.<span class="property">ARRAY_CHILDREN</span>) &#123;</span><br><span class="line">        <span class="comment">// 新旧子节点都是数组，需要进行全量diff</span></span><br><span class="line">        <span class="comment">// two arrays, cannot assume anything, do full diff</span></span><br><span class="line">        <span class="title function_">patchKeyedChildren</span>(</span><br><span class="line">          c1 <span class="keyword">as</span> <span class="title class_">VNode</span>[],</span><br><span class="line">          c2 <span class="keyword">as</span> <span class="title class_">VNodeArrayChildren</span>,</span><br><span class="line">          container,</span><br><span class="line">          anchor,</span><br><span class="line">          parentComponent,</span><br><span class="line">          parentSuspense,</span><br><span class="line">          isSVG,</span><br><span class="line">          slotScopeIds,</span><br><span class="line">          optimized</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 新的子节点为空，则只需要卸载旧的子节点</span></span><br><span class="line">        <span class="comment">// no new children, just unmount old</span></span><br><span class="line">        <span class="title function_">unmountChildren</span>(c1 <span class="keyword">as</span> <span class="title class_">VNode</span>[], parentComponent, parentSuspense, <span class="literal">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 旧的子节点为文本节点或者空，新的为数组或空</span></span><br><span class="line">      <span class="comment">// prev children was text OR null</span></span><br><span class="line">      <span class="comment">// new children is array OR null</span></span><br><span class="line">      <span class="keyword">if</span> (prevShapeFlag &amp; <span class="title class_">ShapeFlags</span>.<span class="property">TEXT_CHILDREN</span>) &#123;</span><br><span class="line">        <span class="comment">// 旧的为文本节点，先将其文本置空</span></span><br><span class="line">        <span class="title function_">hostSetElementText</span>(container, <span class="string">&quot;&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 新的为数组，则通过mountChildren挂载子节点</span></span><br><span class="line">      <span class="comment">// mount new if array</span></span><br><span class="line">      <span class="keyword">if</span> (shapeFlag &amp; <span class="title class_">ShapeFlags</span>.<span class="property">ARRAY_CHILDREN</span>) &#123;</span><br><span class="line">        <span class="title function_">mountChildren</span>(</span><br><span class="line">          c2 <span class="keyword">as</span> <span class="title class_">VNodeArrayChildren</span>,</span><br><span class="line">          container,</span><br><span class="line">          anchor,</span><br><span class="line">          parentComponent,</span><br><span class="line">          parentSuspense,</span><br><span class="line">          isSVG,</span><br><span class="line">          slotScopeIds,</span><br><span class="line">          optimized</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="5-4-patchKeyedChildren"><a href="#5-4-patchKeyedChildren" class="headerlink" title="5.4 patchKeyedChildren"></a>5.4 <code>patchKeyedChildren</code></h4><p>使用<code>patchKeyedChildren</code>来比较两组有<code>key</code>，或者有<code>key</code>和没有<code>key</code>混合的<code>children</code>，属于<code>diff</code>的核心内容了。</p><ul><li><p>从前往后依次对比相同索引位置的节点类型，当遇到节点类型不同则退出比较；</p></li><li><p>再从后往前对比相同倒序位置上的节点类型，遇到不同类型则退出比较；</p></li><li><p>如果旧节点组遍历完，而新节点组还有内容，则挂载新节点组里的剩余内容；</p></li><li><p>如果新节点组遍历完，而旧节点组还有内容，则卸载旧节点组里的剩余内容；</p></li><li><p>如果都没有遍历完：</p><ul><li>将新节点组的剩余内容以<code>key=&gt;index</code>的形式存入<code>Map</code>；</li><li>遍历剩余的旧子节点，在<code>Map</code>中找到相同的<code>key</code>对应的<code>index</code>；</li><li>如果旧子节点没有<code>key</code>，则找到新子节点组的剩余子节点中尚未被匹配到且类型相同的节点对应的<code>index</code>；</li><li>求出最大递增子序列；</li><li>卸载不匹配的旧子节点、挂载未被匹配的新子节点，移动需要移动的可复用子节点。</li></ul></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// can be all-keyed or mixed</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">patchKeyedChildren</span> = (<span class="params"></span></span><br><span class="line"><span class="params">  c1: VNode[],</span></span><br><span class="line"><span class="params">  c2: VNodeArrayChildren,</span></span><br><span class="line"><span class="params">  container: RendererElement,</span></span><br><span class="line"><span class="params">  parentAnchor: RendererNode | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  parentComponent: ComponentInternalInstance | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  parentSuspense: SuspenseBoundary | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  isSVG: <span class="built_in">boolean</span>,</span></span><br><span class="line"><span class="params">  slotScopeIds: <span class="built_in">string</span>[] | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  optimized: <span class="built_in">boolean</span></span></span><br><span class="line"><span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> l2 = c2.<span class="property">length</span>;</span><br><span class="line">  <span class="comment">// 两组各自的尾节点</span></span><br><span class="line">  <span class="keyword">let</span> e1 = c1.<span class="property">length</span> - <span class="number">1</span>; <span class="comment">// prev ending index</span></span><br><span class="line">  <span class="keyword">let</span> e2 = l2 - <span class="number">1</span>; <span class="comment">// next ending index</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// (从前往后)</span></span><br><span class="line">  <span class="comment">// 以两组中最短的一组为基准</span></span><br><span class="line">  <span class="comment">// 从头结点开始，依次比较同一位置的节点类型，若头节点类型相同，则对两个节点进行patch进行比较;</span></span><br><span class="line">  <span class="comment">// 若类型不同则退出循环</span></span><br><span class="line">  <span class="comment">// 1. sync from start</span></span><br><span class="line">  <span class="comment">// (a b) c</span></span><br><span class="line">  <span class="comment">// (a b) d e</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt;= e1 &amp;&amp; i &lt;= e2) &#123;</span><br><span class="line">    <span class="keyword">const</span> n1 = c1[i];</span><br><span class="line">    <span class="keyword">const</span> n2 = (c2[i] = optimized</span><br><span class="line">      ? <span class="title function_">cloneIfMounted</span>(c2[i] <span class="keyword">as</span> <span class="title class_">VNode</span>)</span><br><span class="line">      : <span class="title function_">normalizeVNode</span>(c2[i]));</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isSameVNodeType</span>(n1, n2)) &#123;</span><br><span class="line">      <span class="title function_">patch</span>(</span><br><span class="line">        n1,</span><br><span class="line">        n2,</span><br><span class="line">        container,</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        parentComponent,</span><br><span class="line">        parentSuspense,</span><br><span class="line">        isSVG,</span><br><span class="line">        slotScopeIds,</span><br><span class="line">        optimized</span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// (从后往前)</span></span><br><span class="line">  <span class="comment">// 从尾节点开始，尾节点类型相同，则通过patch比较尾节点；</span></span><br><span class="line">  <span class="comment">// 若类型不同则退出循环</span></span><br><span class="line">  <span class="comment">// 2. sync from end</span></span><br><span class="line">  <span class="comment">// a (b c)</span></span><br><span class="line">  <span class="comment">// d e (b c)</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt;= e1 &amp;&amp; i &lt;= e2) &#123;</span><br><span class="line">    <span class="keyword">const</span> n1 = c1[e1];</span><br><span class="line">    <span class="keyword">const</span> n2 = (c2[e2] = optimized</span><br><span class="line">      ? <span class="title function_">cloneIfMounted</span>(c2[e2] <span class="keyword">as</span> <span class="title class_">VNode</span>)</span><br><span class="line">      : <span class="title function_">normalizeVNode</span>(c2[e2]));</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isSameVNodeType</span>(n1, n2)) &#123;</span><br><span class="line">      <span class="title function_">patch</span>(</span><br><span class="line">        n1,</span><br><span class="line">        n2,</span><br><span class="line">        container,</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        parentComponent,</span><br><span class="line">        parentSuspense,</span><br><span class="line">        isSVG,</span><br><span class="line">        slotScopeIds,</span><br><span class="line">        optimized</span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e1--;</span><br><span class="line">    e2--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 经过前后两轮比较之后，剩下的就是中间那部分类型不同的子节点了</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 若旧的子节点组已经遍历完，而新的子节点组还有剩余内容</span></span><br><span class="line">  <span class="comment">// 通过patch处理剩下的新的子节点中的内容，由于旧的子节点为空，</span></span><br><span class="line">  <span class="comment">// 因此相当于在patch内部挂载剩余的新的子节点</span></span><br><span class="line">  <span class="comment">// 3. common sequence + mount</span></span><br><span class="line">  <span class="comment">// (a b)</span></span><br><span class="line">  <span class="comment">// (a b) c</span></span><br><span class="line">  <span class="comment">// i = 2, e1 = 1, e2 = 2</span></span><br><span class="line">  <span class="comment">// (a b)</span></span><br><span class="line">  <span class="comment">// c (a b)</span></span><br><span class="line">  <span class="comment">// i = 0, e1 = -1, e2 = 0</span></span><br><span class="line">  <span class="keyword">if</span> (i &gt; e1) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= e2) &#123;</span><br><span class="line">      <span class="keyword">const</span> nextPos = e2 + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">const</span> anchor = nextPos &lt; l2 ? (c2[nextPos] <span class="keyword">as</span> <span class="title class_">VNode</span>).<span class="property">el</span> : parentAnchor;</span><br><span class="line">      <span class="keyword">while</span> (i &lt;= e2) &#123;</span><br><span class="line">        <span class="title function_">patch</span>(</span><br><span class="line">          <span class="literal">null</span>,</span><br><span class="line">          (c2[i] = optimized</span><br><span class="line">            ? <span class="title function_">cloneIfMounted</span>(c2[i] <span class="keyword">as</span> <span class="title class_">VNode</span>)</span><br><span class="line">            : <span class="title function_">normalizeVNode</span>(c2[i])),</span><br><span class="line">          container,</span><br><span class="line">          anchor,</span><br><span class="line">          parentComponent,</span><br><span class="line">          parentSuspense,</span><br><span class="line">          isSVG,</span><br><span class="line">          slotScopeIds,</span><br><span class="line">          optimized</span><br><span class="line">        );</span><br><span class="line">        i++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 旧的子节点还有剩余内容而新的子节点组已经遍历完，则卸载旧子节点组剩余的那部分</span></span><br><span class="line">  <span class="comment">// 4. common sequence + unmount</span></span><br><span class="line">  <span class="comment">// (a b) c</span></span><br><span class="line">  <span class="comment">// (a b)</span></span><br><span class="line">  <span class="comment">// i = 2, e1 = 2, e2 = 1</span></span><br><span class="line">  <span class="comment">// a (b c)</span></span><br><span class="line">  <span class="comment">// (b c)</span></span><br><span class="line">  <span class="comment">// i = 0, e1 = 0, e2 = -1</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; e2) &#123;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= e1) &#123;</span><br><span class="line">      <span class="title function_">unmount</span>(c1[i], parentComponent, parentSuspense, <span class="literal">true</span>);</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 新旧子节点组都没有遍历完，如下注释中[]里的部分</span></span><br><span class="line">  <span class="comment">// 5. unknown sequence</span></span><br><span class="line">  <span class="comment">// [i ... e1 + 1]: a b [c d e] f g</span></span><br><span class="line">  <span class="comment">// [i ... e2 + 1]: a b [e d c h] f g</span></span><br><span class="line">  <span class="comment">// i = 2, e1 = 4, e2 = 5</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 拿到上次比较完的起点</span></span><br><span class="line">    <span class="keyword">const</span> s1 = i; <span class="comment">// prev starting index</span></span><br><span class="line">    <span class="keyword">const</span> s2 = i; <span class="comment">// next starting index</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.1 build key:index map for newChildren</span></span><br><span class="line">    <span class="keyword">const</span> <span class="attr">keyToNewIndexMap</span>: <span class="title class_">Map</span>&lt;<span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">symbol</span>, <span class="built_in">number</span>&gt; = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="comment">// 用Map存储新的子节点组的key和对应的index， key=&gt;index 并给出重复的key的警告</span></span><br><span class="line">    <span class="keyword">for</span> (i = s2; i &lt;= e2; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> nextChild = (c2[i] = optimized</span><br><span class="line">        ? <span class="title function_">cloneIfMounted</span>(c2[i] <span class="keyword">as</span> <span class="title class_">VNode</span>)</span><br><span class="line">        : <span class="title function_">normalizeVNode</span>(c2[i]));</span><br><span class="line">      <span class="keyword">if</span> (nextChild.<span class="property">key</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (__DEV__ &amp;&amp; keyToNewIndexMap.<span class="title function_">has</span>(nextChild.<span class="property">key</span>)) &#123;</span><br><span class="line">          <span class="title function_">warn</span>(</span><br><span class="line">            <span class="string">`Duplicate keys found during update:`</span>,</span><br><span class="line">            <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(nextChild.<span class="property">key</span>),</span><br><span class="line">            <span class="string">`Make sure keys are unique.`</span></span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">        keyToNewIndexMap.<span class="title function_">set</span>(nextChild.<span class="property">key</span>, i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.2 loop through old children left to be patched and try to patch</span></span><br><span class="line">    <span class="comment">// matching nodes &amp; remove nodes that are no longer present</span></span><br><span class="line">    <span class="keyword">let</span> j;</span><br><span class="line">    <span class="comment">// 已比较的数量</span></span><br><span class="line">    <span class="keyword">let</span> patched = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 未比较的数量</span></span><br><span class="line">    <span class="keyword">const</span> toBePatched = e2 - s2 + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> moved = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// used to track whether any node has moved</span></span><br><span class="line">    <span class="keyword">let</span> maxNewIndexSoFar = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// works as Map&lt;newIndex, oldIndex&gt;</span></span><br><span class="line">    <span class="comment">// Note that oldIndex is offset by +1</span></span><br><span class="line">    <span class="comment">// and oldIndex = 0 is a special value indicating the new node has</span></span><br><span class="line">    <span class="comment">// no corresponding old node.</span></span><br><span class="line">    <span class="comment">// used for determining longest stable subsequence</span></span><br><span class="line">    <span class="comment">// 以新的子节点组中未完成比较的节点为基准</span></span><br><span class="line">    <span class="keyword">const</span> newIndexToOldIndexMap = <span class="keyword">new</span> <span class="title class_">Array</span>(toBePatched);</span><br><span class="line">    <span class="comment">// 先用0来填充，标记为没有key的节点。 ps:直接fill(0)不就好了么</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; toBePatched; i++) newIndexToOldIndexMap[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理旧的子节点组</span></span><br><span class="line">    <span class="keyword">for</span> (i = s1; i &lt;= e1; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> prevChild = c1[i];</span><br><span class="line">      <span class="comment">// 当已经比较完了(patched &gt;= toBePatched)，卸载旧的子节点</span></span><br><span class="line">      <span class="keyword">if</span> (patched &gt;= toBePatched) &#123;</span><br><span class="line">        <span class="comment">// all new children have been patched so this can only be a removal</span></span><br><span class="line">        <span class="title function_">unmount</span>(prevChild, parentComponent, parentSuspense, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">let</span> newIndex;</span><br><span class="line">      <span class="comment">// 当旧的子节点的key存在，取出key在新的子节点组中对应的index</span></span><br><span class="line">      <span class="keyword">if</span> (prevChild.<span class="property">key</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">        newIndex = keyToNewIndexMap.<span class="title function_">get</span>(prevChild.<span class="property">key</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 若旧的子节点没有key，找出没有key且类型相同的节点对应在新子节点组中的index</span></span><br><span class="line">        <span class="comment">// key-less node, try to locate a key-less node of the same type</span></span><br><span class="line">        <span class="keyword">for</span> (j = s2; j &lt;= e2; j++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (</span><br><span class="line">            newIndexToOldIndexMap[j - s2] === <span class="number">0</span> &amp;&amp;</span><br><span class="line">            <span class="title function_">isSameVNodeType</span>(prevChild, c2[j] <span class="keyword">as</span> <span class="title class_">VNode</span>)</span><br><span class="line">          ) &#123;</span><br><span class="line">            newIndex = j;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// newIndex不存在，即根据key来找，发现旧的子节点不可复用，则卸载旧的子节点</span></span><br><span class="line">      <span class="keyword">if</span> (newIndex === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="title function_">unmount</span>(prevChild, parentComponent, parentSuspense, <span class="literal">true</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 找到了可复用的节点，在newIndexToOldIndexMap中标记 i+1，</span></span><br><span class="line">        <span class="comment">// 用于最大上升子序列算法</span></span><br><span class="line">        newIndexToOldIndexMap[newIndex - s2] = i + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 刷新目前找到的最大的新子节点的index，做节点移动标记</span></span><br><span class="line">        <span class="keyword">if</span> (newIndex &gt;= maxNewIndexSoFar) &#123;</span><br><span class="line">          maxNewIndexSoFar = newIndex;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          moved = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 再递归详细比较两个节点</span></span><br><span class="line">        <span class="title function_">patch</span>(</span><br><span class="line">          prevChild,</span><br><span class="line">          c2[newIndex] <span class="keyword">as</span> <span class="title class_">VNode</span>,</span><br><span class="line">          container,</span><br><span class="line">          <span class="literal">null</span>,</span><br><span class="line">          parentComponent,</span><br><span class="line">          parentSuspense,</span><br><span class="line">          isSVG,</span><br><span class="line">          slotScopeIds,</span><br><span class="line">          optimized</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// 已对比的数量+1</span></span><br><span class="line">        patched++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当需要移动时，采用最大递增子序列算法，从而最大限度减少节点移动次数</span></span><br><span class="line">    <span class="comment">// 5.3 move and mount</span></span><br><span class="line">    <span class="comment">// generate longest stable subsequence only when nodes have moved</span></span><br><span class="line">    <span class="keyword">const</span> increasingNewIndexSequence = moved</span><br><span class="line">      ? <span class="title function_">getSequence</span>(newIndexToOldIndexMap)</span><br><span class="line">      : <span class="variable constant_">EMPTY_ARR</span>;</span><br><span class="line">    j = increasingNewIndexSequence.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 倒序遍历，好处是可以使用上一次对比的节点作为锚点</span></span><br><span class="line">    <span class="comment">// looping backwards so that we can use last patched node as anchor</span></span><br><span class="line">    <span class="keyword">for</span> (i = toBePatched - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">const</span> nextIndex = s2 + i;</span><br><span class="line">      <span class="keyword">const</span> nextChild = c2[nextIndex] <span class="keyword">as</span> <span class="title class_">VNode</span>;</span><br><span class="line">      <span class="keyword">const</span> anchor =</span><br><span class="line">        nextIndex + <span class="number">1</span> &lt; l2 ? (c2[nextIndex + <span class="number">1</span>] <span class="keyword">as</span> <span class="title class_">VNode</span>).<span class="property">el</span> : parentAnchor;</span><br><span class="line">      <span class="keyword">if</span> (newIndexToOldIndexMap[i] === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 等于0说明未被旧的子节点匹配到，属于全新的不可复用的子节点，则通过patch进行挂载</span></span><br><span class="line">        <span class="comment">// mount new</span></span><br><span class="line">        <span class="title function_">patch</span>(</span><br><span class="line">          <span class="literal">null</span>,</span><br><span class="line">          nextChild,</span><br><span class="line">          container,</span><br><span class="line">          anchor,</span><br><span class="line">          parentComponent,</span><br><span class="line">          parentSuspense,</span><br><span class="line">          isSVG,</span><br><span class="line">          slotScopeIds,</span><br><span class="line">          optimized</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (moved) &#123;</span><br><span class="line">        <span class="comment">// 当计算出来的最大上升子序列为空数组，</span></span><br><span class="line">        <span class="comment">// 或者当前节点不处于最大上升子序列中</span></span><br><span class="line">        <span class="comment">// move if:</span></span><br><span class="line">        <span class="comment">// There is no stable subsequence (e.g. a reverse)</span></span><br><span class="line">        <span class="comment">// OR current node is not among the stable sequence</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt; <span class="number">0</span> || i !== increasingNewIndexSequence[j]) &#123;</span><br><span class="line">          <span class="title function_">move</span>(nextChild, container, anchor, <span class="title class_">MoveType</span>.<span class="property">REORDER</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          j--;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="5-5-patchUnkeyedChildren"><a href="#5-5-patchUnkeyedChildren" class="headerlink" title="5.5 patchUnkeyedChildren"></a>5.5 <code>patchUnkeyedChildren</code></h4><p>没有<code>key</code>的时候就很直接了，只依照最短的那组的长度，来按位置进行比较。而后该卸载就卸载，该挂载就挂载。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">patchUnkeyedChildren</span> = (<span class="params"></span></span><br><span class="line"><span class="params">  c1: VNode[],</span></span><br><span class="line"><span class="params">  c2: VNodeArrayChildren,</span></span><br><span class="line"><span class="params">  container: RendererElement,</span></span><br><span class="line"><span class="params">  anchor: RendererNode | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  parentComponent: ComponentInternalInstance | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  parentSuspense: SuspenseBoundary | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  isSVG: <span class="built_in">boolean</span>,</span></span><br><span class="line"><span class="params">  slotScopeIds: <span class="built_in">string</span>[] | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  optimized: <span class="built_in">boolean</span></span></span><br><span class="line"><span class="params"></span>) =&gt; &#123;</span><br><span class="line">  c1 = c1 || <span class="variable constant_">EMPTY_ARR</span>;</span><br><span class="line">  c2 = c2 || <span class="variable constant_">EMPTY_ARR</span>;</span><br><span class="line">  <span class="keyword">const</span> oldLength = c1.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">const</span> newLength = c2.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">const</span> commonLength = <span class="title class_">Math</span>.<span class="title function_">min</span>(oldLength, newLength);</span><br><span class="line">  <span class="keyword">let</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; commonLength; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> nextChild = (c2[i] = optimized</span><br><span class="line">      ? <span class="title function_">cloneIfMounted</span>(c2[i] <span class="keyword">as</span> <span class="title class_">VNode</span>)</span><br><span class="line">      : <span class="title function_">normalizeVNode</span>(c2[i]));</span><br><span class="line">    <span class="title function_">patch</span>(</span><br><span class="line">      c1[i],</span><br><span class="line">      nextChild,</span><br><span class="line">      container,</span><br><span class="line">      <span class="literal">null</span>,</span><br><span class="line">      parentComponent,</span><br><span class="line">      parentSuspense,</span><br><span class="line">      isSVG,</span><br><span class="line">      slotScopeIds,</span><br><span class="line">      optimized</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (oldLength &gt; newLength) &#123;</span><br><span class="line">    <span class="comment">// remove old</span></span><br><span class="line">    <span class="title function_">unmountChildren</span>(</span><br><span class="line">      c1,</span><br><span class="line">      parentComponent,</span><br><span class="line">      parentSuspense,</span><br><span class="line">      <span class="literal">true</span>,</span><br><span class="line">      <span class="literal">false</span>,</span><br><span class="line">      commonLength</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// mount new</span></span><br><span class="line">    <span class="title function_">mountChildren</span>(</span><br><span class="line">      c2,</span><br><span class="line">      container,</span><br><span class="line">      anchor,</span><br><span class="line">      parentComponent,</span><br><span class="line">      parentSuspense,</span><br><span class="line">      isSVG,</span><br><span class="line">      slotScopeIds,</span><br><span class="line">      optimized,</span><br><span class="line">      commonLength</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="5-6-mountChildren"><a href="#5-6-mountChildren" class="headerlink" title="5.6 mountChildren"></a>5.6 <code>mountChildren</code></h4><p><code>mountChildren</code>用于挂载子节点，主要是遍历子节点，处理每个子节点，得到复制的或者标准化的单个子节点，然后递归调用<code>patch</code>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">mountChildren</span>: <span class="title class_">MountChildrenFn</span> = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  children,</span></span></span><br><span class="line"><span class="params"><span class="function">  container,</span></span></span><br><span class="line"><span class="params"><span class="function">  anchor,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentComponent,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentSuspense,</span></span></span><br><span class="line"><span class="params"><span class="function">  isSVG,</span></span></span><br><span class="line"><span class="params"><span class="function">  slotScopeIds,</span></span></span><br><span class="line"><span class="params"><span class="function">  optimized,</span></span></span><br><span class="line"><span class="params"><span class="function">  start = <span class="number">0</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt; children.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> child = (children[i] = optimized</span><br><span class="line">      ? <span class="title function_">cloneIfMounted</span>(children[i] <span class="keyword">as</span> <span class="title class_">VNode</span>)</span><br><span class="line">      : <span class="title function_">normalizeVNode</span>(children[i]));</span><br><span class="line">    <span class="title function_">patch</span>(</span><br><span class="line">      <span class="literal">null</span>,</span><br><span class="line">      child,</span><br><span class="line">      container,</span><br><span class="line">      anchor,</span><br><span class="line">      parentComponent,</span><br><span class="line">      parentSuspense,</span><br><span class="line">      isSVG,</span><br><span class="line">      slotScopeIds,</span><br><span class="line">      optimized</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="5-7-unmountChildren"><a href="#5-7-unmountChildren" class="headerlink" title="5.7 unmountChildren"></a>5.7 <code>unmountChildren</code></h4><p>遍历子节点组，调用<code>unmount</code>方法卸载子节点。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">unmountChildren</span>: <span class="title class_">UnmountChildrenFn</span> = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  children,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentComponent,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentSuspense,</span></span></span><br><span class="line"><span class="params"><span class="function">  doRemove = <span class="literal">false</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  optimized = <span class="literal">false</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  start = <span class="number">0</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt; children.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="title function_">unmount</span>(children[i], parentComponent, parentSuspense, doRemove, optimized);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="5-8-move"><a href="#5-8-move" class="headerlink" title="5.8 move"></a>5.8 <code>move</code></h4><p>在有<code>key</code>的子节点比较中，出现了需要移动子节点的情况，而移动就是通过<code>move</code>来完成的。按照不同的节点类型，处理方式有所差异。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">move</span>: <span class="title class_">MoveFn</span> = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  vnode,</span></span></span><br><span class="line"><span class="params"><span class="function">  container,</span></span></span><br><span class="line"><span class="params"><span class="function">  anchor,</span></span></span><br><span class="line"><span class="params"><span class="function">  moveType,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentSuspense = <span class="literal">null</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; el, <span class="keyword">type</span>, transition, children, shapeFlag &#125; = vnode;</span><br><span class="line">  <span class="comment">// 对于组件节点，递归处理subTree</span></span><br><span class="line">  <span class="keyword">if</span> (shapeFlag &amp; <span class="title class_">ShapeFlags</span>.<span class="property">COMPONENT</span>) &#123;</span><br><span class="line">    <span class="title function_">move</span>(vnode.<span class="property">component</span>!.<span class="property">subTree</span>, container, anchor, moveType);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理异步组件&lt;Suspense&gt;</span></span><br><span class="line">  <span class="keyword">if</span> (__FEATURE_SUSPENSE__ &amp;&amp; shapeFlag &amp; <span class="title class_">ShapeFlags</span>.<span class="property">SUSPENSE</span>) &#123;</span><br><span class="line">    vnode.<span class="property">suspense</span>!.<span class="title function_">move</span>(container, anchor, moveType);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理&lt;Teleport&gt;</span></span><br><span class="line">  <span class="keyword">if</span> (shapeFlag &amp; <span class="title class_">ShapeFlags</span>.<span class="property">TELEPORT</span>) &#123;</span><br><span class="line">    (<span class="keyword">type</span> <span class="keyword">as</span> <span class="keyword">typeof</span> <span class="title class_">TeleportImpl</span>).<span class="title function_">move</span>(vnode, container, anchor, internals);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 文档片段，处理起始锚点和子节点</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">type</span> === <span class="title class_">Fragment</span>) &#123;</span><br><span class="line">    <span class="title function_">hostInsert</span>(el!, container, anchor);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; (children <span class="keyword">as</span> <span class="title class_">VNode</span>[]).<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="title function_">move</span>((children <span class="keyword">as</span> <span class="title class_">VNode</span>[])[i], container, anchor, moveType);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">hostInsert</span>(vnode.<span class="property">anchor</span>!, container, anchor);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 静态节点</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">type</span> === <span class="title class_">Static</span>) &#123;</span><br><span class="line">    <span class="title function_">moveStaticNode</span>(vnode, container, anchor);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理&lt;Transition&gt;的钩子</span></span><br><span class="line">  <span class="comment">// single nodes</span></span><br><span class="line">  <span class="keyword">const</span> needTransition =</span><br><span class="line">    moveType !== <span class="title class_">MoveType</span>.<span class="property">REORDER</span> &amp;&amp;</span><br><span class="line">    shapeFlag &amp; <span class="title class_">ShapeFlags</span>.<span class="property">ELEMENT</span> &amp;&amp;</span><br><span class="line">    transition;</span><br><span class="line">  <span class="keyword">if</span> (needTransition) &#123;</span><br><span class="line">    <span class="keyword">if</span> (moveType === <span class="title class_">MoveType</span>.<span class="property">ENTER</span>) &#123;</span><br><span class="line">      transition!.<span class="title function_">beforeEnter</span>(el!);</span><br><span class="line">      <span class="title function_">hostInsert</span>(el!, container, anchor);</span><br><span class="line">      <span class="title function_">queuePostRenderEffect</span>(<span class="function">() =&gt;</span> transition!.<span class="title function_">enter</span>(el!), parentSuspense);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; leave, delayLeave, afterLeave &#125; = transition!;</span><br><span class="line">      <span class="keyword">const</span> <span class="title function_">remove</span> = (<span class="params"></span>) =&gt; <span class="title function_">hostInsert</span>(el!, container, anchor);</span><br><span class="line">      <span class="keyword">const</span> <span class="title function_">performLeave</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="title function_">leave</span>(el!, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">remove</span>();</span><br><span class="line">          afterLeave &amp;&amp; <span class="title function_">afterLeave</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">if</span> (delayLeave) &#123;</span><br><span class="line">        <span class="title function_">delayLeave</span>(el!, remove, performLeave);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">performLeave</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">hostInsert</span>(el!, container, anchor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="6-processElement"><a href="#6-processElement" class="headerlink" title="6. processElement"></a>6. <code>processElement</code></h3><h4 id="6-1-processElement"><a href="#6-1-processElement" class="headerlink" title="6.1 processElement"></a>6.1 <code>processElement</code></h4><p><code>processElement</code>内容很简单，判断一下是否要当作<code>svg</code>处理；之后，如果旧节点为空，则直接通过<code>mountElement</code>挂载新的元素节点，否则通过<code>patchElement</code>对元素节点进行对比。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">processElement</span> = (<span class="params"></span></span><br><span class="line"><span class="params">  n1: VNode | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  n2: VNode,</span></span><br><span class="line"><span class="params">  container: RendererElement,</span></span><br><span class="line"><span class="params">  anchor: RendererNode | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  parentComponent: ComponentInternalInstance | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  parentSuspense: SuspenseBoundary | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  isSVG: <span class="built_in">boolean</span>,</span></span><br><span class="line"><span class="params">  slotScopeIds: <span class="built_in">string</span>[] | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  optimized: <span class="built_in">boolean</span></span></span><br><span class="line"><span class="params"></span>) =&gt; &#123;</span><br><span class="line">  isSVG = isSVG || (n2.<span class="property">type</span> <span class="keyword">as</span> <span class="built_in">string</span>) === <span class="string">&quot;svg&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> (n1 == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="title function_">mountElement</span>(</span><br><span class="line">      n2,</span><br><span class="line">      container,</span><br><span class="line">      anchor,</span><br><span class="line">      parentComponent,</span><br><span class="line">      parentSuspense,</span><br><span class="line">      isSVG,</span><br><span class="line">      slotScopeIds,</span><br><span class="line">      optimized</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">patchElement</span>(</span><br><span class="line">      n1,</span><br><span class="line">      n2,</span><br><span class="line">      parentComponent,</span><br><span class="line">      parentSuspense,</span><br><span class="line">      isSVG,</span><br><span class="line">      slotScopeIds,</span><br><span class="line">      optimized</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="6-2-mountElement"><a href="#6-2-mountElement" class="headerlink" title="6.2 mountElement"></a>6.2 <code>mountElement</code></h4><p>假如此时旧节点为空，那么就会调用<code>mountElement</code>，我们来看看它是怎么做的。</p><ul><li>若<code>vndoe</code>上的<code>el</code>属性存在，开发环境下则简单对<code>el</code>进行复制；不存在则新建；</li><li>先进行子节点的挂载，因为某些<code>props</code>依赖于子节点的渲染；</li><li>指令的<code>created</code>阶段；</li><li>处理<code>props</code>并设置<code>scopeId</code>；</li><li>开发环境下设置<code>el.__vnode</code>和<code>el.vueParentComponent</code>的取值，并设置为不可枚举；</li><li>指令的<code>beforeMounted</code>阶段；</li><li>动画组件<code>Transition</code>的<code>beforeEnter</code>钩子；</li><li>执行<code>vnode</code>上的钩子、<code>Transition</code>的<code>enter</code>钩子、指令的<code>mounted</code>钩子等</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">mountElement</span> = (<span class="params"></span></span><br><span class="line"><span class="params">  vnode: VNode,</span></span><br><span class="line"><span class="params">  container: RendererElement,</span></span><br><span class="line"><span class="params">  anchor: RendererNode | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  parentComponent: ComponentInternalInstance | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  parentSuspense: SuspenseBoundary | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  isSVG: <span class="built_in">boolean</span>,</span></span><br><span class="line"><span class="params">  slotScopeIds: <span class="built_in">string</span>[] | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  optimized: <span class="built_in">boolean</span></span></span><br><span class="line"><span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">el</span>: <span class="title class_">RendererElement</span>;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">vnodeHook</span>: <span class="title class_">VNodeHook</span> | <span class="literal">undefined</span> | <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="keyword">type</span>, props, shapeFlag, transition, patchFlag, dirs &#125; = vnode;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    !__DEV__ &amp;&amp;</span><br><span class="line">    vnode.<span class="property">el</span> &amp;&amp;</span><br><span class="line">    hostCloneNode !== <span class="literal">undefined</span> &amp;&amp;</span><br><span class="line">    patchFlag === <span class="title class_">PatchFlags</span>.<span class="property">HOISTED</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// vnode的el元素存在，仅在生产环境下对可复用的静态节点进行复制</span></span><br><span class="line">    <span class="comment">// If a vnode has non-null el, it means it&#x27;s being reused.</span></span><br><span class="line">    <span class="comment">// Only static vnodes can be reused, so its mounted DOM nodes should be</span></span><br><span class="line">    <span class="comment">// exactly the same, and we can simply do a clone here.</span></span><br><span class="line">    <span class="comment">// only do this in production since cloned trees cannot be HMR updated.</span></span><br><span class="line">    el = vnode.<span class="property">el</span> = <span class="title function_">hostCloneNode</span>(vnode.<span class="property">el</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// vnode上的元素不存在则新建</span></span><br><span class="line">    el = vnode.<span class="property">el</span> = <span class="title function_">hostCreateElement</span>(</span><br><span class="line">      vnode.<span class="property">type</span> <span class="keyword">as</span> <span class="built_in">string</span>,</span><br><span class="line">      isSVG,</span><br><span class="line">      props &amp;&amp; props.<span class="property">is</span>,</span><br><span class="line">      props</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注释：由于某些props依赖于子节点的渲染，先挂载子节点</span></span><br><span class="line">    <span class="comment">// mount children first, since some props may rely on child content</span></span><br><span class="line">    <span class="comment">// being already rendered, e.g. `&lt;select value&gt;`</span></span><br><span class="line">    <span class="keyword">if</span> (shapeFlag &amp; <span class="title class_">ShapeFlags</span>.<span class="property">TEXT_CHILDREN</span>) &#123;</span><br><span class="line">      <span class="comment">// 设置元素文本</span></span><br><span class="line">      <span class="title function_">hostSetElementText</span>(el, vnode.<span class="property">children</span> <span class="keyword">as</span> <span class="built_in">string</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; <span class="title class_">ShapeFlags</span>.<span class="property">ARRAY_CHILDREN</span>) &#123;</span><br><span class="line">      <span class="comment">// 挂载子节点</span></span><br><span class="line">      <span class="title function_">mountChildren</span>(</span><br><span class="line">        vnode.<span class="property">children</span> <span class="keyword">as</span> <span class="title class_">VNodeArrayChildren</span>,</span><br><span class="line">        el,</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        parentComponent,</span><br><span class="line">        parentSuspense,</span><br><span class="line">        isSVG &amp;&amp; <span class="keyword">type</span> !== <span class="string">&quot;foreignObject&quot;</span>,</span><br><span class="line">        slotScopeIds,</span><br><span class="line">        optimized</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指令的created阶段</span></span><br><span class="line">    <span class="keyword">if</span> (dirs) &#123;</span><br><span class="line">      <span class="title function_">invokeDirectiveHook</span>(vnode, <span class="literal">null</span>, parentComponent, <span class="string">&quot;created&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理元素的props</span></span><br><span class="line">    <span class="comment">// props</span></span><br><span class="line">    <span class="keyword">if</span> (props) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> props) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key !== <span class="string">&quot;value&quot;</span> &amp;&amp; !<span class="title function_">isReservedProp</span>(key)) &#123;</span><br><span class="line">          <span class="title function_">hostPatchProp</span>(</span><br><span class="line">            el,</span><br><span class="line">            key,</span><br><span class="line">            <span class="literal">null</span>,</span><br><span class="line">            props[key],</span><br><span class="line">            isSVG,</span><br><span class="line">            vnode.<span class="property">children</span> <span class="keyword">as</span> <span class="title class_">VNode</span>[],</span><br><span class="line">            parentComponent,</span><br><span class="line">            parentSuspense,</span><br><span class="line">            unmountChildren</span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * Special case for setting value on DOM elements:</span></span><br><span class="line"><span class="comment">       * - it can be order-sensitive (e.g. should be set *after* min/max, #2325, #4024)</span></span><br><span class="line"><span class="comment">       * - it needs to be forced (#1471)</span></span><br><span class="line"><span class="comment">       * #2353 proposes adding another renderer option to configure this, but</span></span><br><span class="line"><span class="comment">       * the properties affects are so finite it is worth special casing it</span></span><br><span class="line"><span class="comment">       * here to reduce the complexity. (Special casing it also should not</span></span><br><span class="line"><span class="comment">       * affect non-DOM renderers)</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="string">&quot;value&quot;</span> <span class="keyword">in</span> props) &#123;</span><br><span class="line">        <span class="title function_">hostPatchProp</span>(el, <span class="string">&quot;value&quot;</span>, <span class="literal">null</span>, props.<span class="property">value</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ((vnodeHook = props.<span class="property">onVnodeBeforeMount</span>)) &#123;</span><br><span class="line">        <span class="title function_">invokeVNodeHook</span>(vnodeHook, parentComponent, vnode);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// scopeId</span></span><br><span class="line">    <span class="title function_">setScopeId</span>(el, vnode, vnode.<span class="property">scopeId</span>, slotScopeIds, parentComponent);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// __DEV__环境下处理 __vnode属性和父组件为不可枚举</span></span><br><span class="line">  <span class="keyword">if</span> (__DEV__ || __FEATURE_PROD_DEVTOOLS__) &#123;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(el, <span class="string">&quot;__vnode&quot;</span>, &#123;</span><br><span class="line">      <span class="attr">value</span>: vnode,</span><br><span class="line">      <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(el, <span class="string">&quot;__vueParentComponent&quot;</span>, &#123;</span><br><span class="line">      <span class="attr">value</span>: parentComponent,</span><br><span class="line">      <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 执行指令中的 beforeMount 阶段</span></span><br><span class="line">  <span class="keyword">if</span> (dirs) &#123;</span><br><span class="line">    <span class="title function_">invokeDirectiveHook</span>(vnode, <span class="literal">null</span>, parentComponent, <span class="string">&quot;beforeMount&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// #1583 For inside suspense + suspense not resolved case, enter hook should call when suspense resolved</span></span><br><span class="line">  <span class="comment">// #1689 For inside suspense + suspense resolved case, just call it</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是否需要执行动画组件钩子</span></span><br><span class="line">  <span class="keyword">const</span> needCallTransitionHooks =</span><br><span class="line">    (!parentSuspense || (parentSuspense &amp;&amp; !parentSuspense.<span class="property">pendingBranch</span>)) &amp;&amp;</span><br><span class="line">    transition &amp;&amp;</span><br><span class="line">    !transition.<span class="property">persisted</span>;</span><br><span class="line">  <span class="keyword">if</span> (needCallTransitionHooks) &#123;</span><br><span class="line">    transition!.<span class="title function_">beforeEnter</span>(el);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">hostInsert</span>(el, container, anchor);</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    (vnodeHook = props &amp;&amp; props.<span class="property">onVnodeMounted</span>) ||</span><br><span class="line">    needCallTransitionHooks ||</span><br><span class="line">    dirs</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// 加入组件更新后的副作用执行队列，在合适的时机执行入队的函数</span></span><br><span class="line">    <span class="comment">// 这里是一些钩子函数、trasition的钩子、指令在mounted阶段的钩子</span></span><br><span class="line">    <span class="title function_">queuePostRenderEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      vnodeHook &amp;&amp; <span class="title function_">invokeVNodeHook</span>(vnodeHook, parentComponent, vnode);</span><br><span class="line">      needCallTransitionHooks &amp;&amp; transition!.<span class="title function_">enter</span>(el);</span><br><span class="line">      dirs &amp;&amp; <span class="title function_">invokeDirectiveHook</span>(vnode, <span class="literal">null</span>, parentComponent, <span class="string">&quot;mounted&quot;</span>);</span><br><span class="line">    &#125;, parentSuspense);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="6-3-patchElement"><a href="#6-3-patchElement" class="headerlink" title="6.3 patchElement"></a>6.3 <code>patchElement</code></h4><p><code>patchElemengt</code>相当重要，因为其它和你多内容的<code>patch</code>，最终经过递归，依然会走到<code>patchElement</code>。当新旧元素节点都存在时，就会调用<code>patchElement</code>进行对比。可以看到顺序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beforeUpdated -&gt; 子节点 -&gt; class/style -&gt; 其它props/attrs -&gt; updated</span><br></pre></td></tr></table></figure><ul><li><p>关闭<code>recurse</code>，处理<code>beforeUpdated</code>钩子；</p></li><li><p>处理指定的<code>beforeUpdated</code>阶段，再启用<code>recurse</code>；</p></li><li><p>在<code>__DEV__</code>环境下的热更新时，则会清理优化标记，从而强制对节点进行全量的比较(<code>full diff</code>)；</p></li><li><p>处理动态子节点：</p><ul><li>当新节点中有动态子节点，则通过<code>patchBlockChildren</code>来和旧节点的动态子节点进行对比；</li><li>否则，如果没有优化(<code>!optimized</code>)，则使用<code>patchChildren</code>对子节点进行全量<code>diff</code>；</li></ul></li><li><p>判断<code>patchFlag &gt; 0</code>，大于<code>0</code>时则元素的<code>render</code>代码由<code>compiler</code>生成，有优化<code>buff</code>：</p><ul><li>如果<code>props</code>中有动态的<code>key</code>，则优化无效，进行全量<code>diff</code>；</li><li>处理动态类名和动态<code>style</code>，优化<code>diff</code>；</li><li>处理其它的<code>prop/attr</code>，如果其中有动态的<code>key</code>，则优化无效；</li><li>处理文本：当元素只有文本子节点时，则将文本子节点设置为新的元素节点的内容；</li></ul></li><li><p><code>patchFlag &lt;= 0</code>，且没有设置优化时，对<code>props</code>进行全量<code>diff</code>；</p></li><li><p><code>updated</code>阶段。</p></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">patchElement</span> = (<span class="params"></span></span><br><span class="line"><span class="params">  n1: VNode,</span></span><br><span class="line"><span class="params">  n2: VNode,</span></span><br><span class="line"><span class="params">  parentComponent: ComponentInternalInstance | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  parentSuspense: SuspenseBoundary | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  isSVG: <span class="built_in">boolean</span>,</span></span><br><span class="line"><span class="params">  slotScopeIds: <span class="built_in">string</span>[] | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  optimized: <span class="built_in">boolean</span></span></span><br><span class="line"><span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> el = (n2.<span class="property">el</span> = n1.<span class="property">el</span>!);</span><br><span class="line">  <span class="keyword">let</span> &#123; patchFlag, dynamicChildren, dirs &#125; = n2;</span><br><span class="line">  <span class="comment">// #1426 take the old vnode&#x27;s patch flag into account since user may clone a</span></span><br><span class="line">  <span class="comment">// compiler-generated vnode, which de-opts to FULL_PROPS</span></span><br><span class="line">  patchFlag |= n1.<span class="property">patchFlag</span> &amp; <span class="title class_">PatchFlags</span>.<span class="property">FULL_PROPS</span>;</span><br><span class="line">  <span class="keyword">const</span> oldProps = n1.<span class="property">props</span> || <span class="variable constant_">EMPTY_OBJ</span>;</span><br><span class="line">  <span class="keyword">const</span> newProps = n2.<span class="property">props</span> || <span class="variable constant_">EMPTY_OBJ</span>;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">vnodeHook</span>: <span class="title class_">VNodeHook</span> | <span class="literal">undefined</span> | <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关闭recurse，在 beforeUpdated 阶段不允许自己调用</span></span><br><span class="line">  <span class="comment">// disable recurse in beforeUpdate hooks</span></span><br><span class="line">  parentComponent &amp;&amp; <span class="title function_">toggleRecurse</span>(parentComponent, <span class="literal">false</span>);</span><br><span class="line">  <span class="comment">// beforeUpdated钩子</span></span><br><span class="line">  <span class="keyword">if</span> ((vnodeHook = newProps.<span class="property">onVnodeBeforeUpdate</span>)) &#123;</span><br><span class="line">    <span class="title function_">invokeVNodeHook</span>(vnodeHook, parentComponent, n2, n1);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 指令的 beforeUpdated 钩子</span></span><br><span class="line">  <span class="keyword">if</span> (dirs) &#123;</span><br><span class="line">    <span class="title function_">invokeDirectiveHook</span>(n2, n1, parentComponent, <span class="string">&quot;beforeUpdate&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 允许自己调用</span></span><br><span class="line">  parentComponent &amp;&amp; <span class="title function_">toggleRecurse</span>(parentComponent, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开发环境呢下，关闭优化，全量diff</span></span><br><span class="line">  <span class="keyword">if</span> (__DEV__ &amp;&amp; isHmrUpdating) &#123;</span><br><span class="line">    <span class="comment">// HMR updated, force full diff</span></span><br><span class="line">    patchFlag = <span class="number">0</span>;</span><br><span class="line">    optimized = <span class="literal">false</span>;</span><br><span class="line">    dynamicChildren = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> areChildrenSVG = isSVG &amp;&amp; n2.<span class="property">type</span> !== <span class="string">&quot;foreignObject&quot;</span>;</span><br><span class="line">  <span class="comment">// 新节点的动态子节点不为空，则比较新旧节点的动态子节点</span></span><br><span class="line">  <span class="keyword">if</span> (dynamicChildren) &#123;</span><br><span class="line">    <span class="title function_">patchBlockChildren</span>(</span><br><span class="line">      n1.<span class="property">dynamicChildren</span>!,</span><br><span class="line">      dynamicChildren,</span><br><span class="line">      el,</span><br><span class="line">      parentComponent,</span><br><span class="line">      parentSuspense,</span><br><span class="line">      areChildrenSVG,</span><br><span class="line">      slotScopeIds</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 开发环境  递归遍历静态子节点</span></span><br><span class="line">    <span class="keyword">if</span> (__DEV__ &amp;&amp; parentComponent &amp;&amp; parentComponent.<span class="property">type</span>.<span class="property">__hmrId</span>) &#123;</span><br><span class="line">      <span class="title function_">traverseStaticChildren</span>(n1, n2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有优化，全量 diff</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!optimized) &#123;</span><br><span class="line">    <span class="comment">// full diff</span></span><br><span class="line">    <span class="title function_">patchChildren</span>(</span><br><span class="line">      n1,</span><br><span class="line">      n2,</span><br><span class="line">      el,</span><br><span class="line">      <span class="literal">null</span>,</span><br><span class="line">      parentComponent,</span><br><span class="line">      parentSuspense,</span><br><span class="line">      areChildrenSVG,</span><br><span class="line">      slotScopeIds,</span><br><span class="line">      <span class="literal">false</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注释：patchFlag 标识的存在意味着元素的 render 代码是由 compiler 生成的，</span></span><br><span class="line">  <span class="comment">// 且可以在 patch 时走快道，此时能保证新旧节点形状相同，即它们在源模板中正好处于相同的位置</span></span><br><span class="line">  <span class="comment">// 此时的对比是有着各种优化的</span></span><br><span class="line">  <span class="keyword">if</span> (patchFlag &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// the presence of a patchFlag means this element&#x27;s render code was</span></span><br><span class="line">    <span class="comment">// generated by the compiler and can take the fast path.</span></span><br><span class="line">    <span class="comment">// in this path old node and new node are guaranteed to have the same shape</span></span><br><span class="line">    <span class="comment">// (i.e. at the exact same position in the source template)</span></span><br><span class="line">    <span class="keyword">if</span> (patchFlag &amp; <span class="title class_">PatchFlags</span>.<span class="property">FULL_PROPS</span>) &#123;</span><br><span class="line">      <span class="comment">// 当props中含有动态的key，需要进行全量 diff</span></span><br><span class="line">      <span class="comment">// element props contain dynamic keys, full diff needed</span></span><br><span class="line">      <span class="title function_">patchProps</span>(</span><br><span class="line">        el,</span><br><span class="line">        n2,</span><br><span class="line">        oldProps,</span><br><span class="line">        newProps,</span><br><span class="line">        parentComponent,</span><br><span class="line">        parentSuspense,</span><br><span class="line">        isSVG</span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 处理动态类名绑定</span></span><br><span class="line">      <span class="comment">// class</span></span><br><span class="line">      <span class="comment">// this flag is matched when the element has dynamic class bindings.</span></span><br><span class="line">      <span class="keyword">if</span> (patchFlag &amp; <span class="title class_">PatchFlags</span>.<span class="property">CLASS</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldProps.<span class="property">class</span> !== newProps.<span class="property">class</span>) &#123;</span><br><span class="line">          <span class="title function_">hostPatchProp</span>(el, <span class="string">&quot;class&quot;</span>, <span class="literal">null</span>, newProps.<span class="property">class</span>, isSVG);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 处理动态的 style 绑定</span></span><br><span class="line">      <span class="comment">// style</span></span><br><span class="line">      <span class="comment">// this flag is matched when the element has dynamic style bindings</span></span><br><span class="line">      <span class="keyword">if</span> (patchFlag &amp; <span class="title class_">PatchFlags</span>.<span class="property">STYLE</span>) &#123;</span><br><span class="line">        <span class="title function_">hostPatchProp</span>(el, <span class="string">&quot;style&quot;</span>, oldProps.<span class="property">style</span>, newProps.<span class="property">style</span>, isSVG);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 处理动态的 prop/attr 绑定，有迭代缓存，优化比较速度</span></span><br><span class="line">      <span class="comment">// 如果 `prop/attr`的 key 是动态的，那么这种优化则会失效</span></span><br><span class="line">      <span class="comment">// props</span></span><br><span class="line">      <span class="comment">// This flag is matched when the element has dynamic prop/attr bindings</span></span><br><span class="line">      <span class="comment">// other than class and style. The keys of dynamic prop/attrs are saved for</span></span><br><span class="line">      <span class="comment">// faster iteration.</span></span><br><span class="line">      <span class="comment">// Note dynamic keys like :[foo]=&quot;bar&quot; will cause this optimization to</span></span><br><span class="line">      <span class="comment">// bail out and go through a full diff because we need to unset the old key</span></span><br><span class="line">      <span class="keyword">if</span> (patchFlag &amp; <span class="title class_">PatchFlags</span>.<span class="property">PROPS</span>) &#123;</span><br><span class="line">        <span class="comment">// if the flag is present then dynamicProps must be non-null</span></span><br><span class="line">        <span class="keyword">const</span> propsToUpdate = n2.<span class="property">dynamicProps</span>!;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; propsToUpdate.<span class="property">length</span>; i++) &#123;</span><br><span class="line">          <span class="keyword">const</span> key = propsToUpdate[i];</span><br><span class="line">          <span class="keyword">const</span> prev = oldProps[key];</span><br><span class="line">          <span class="keyword">const</span> next = newProps[key];</span><br><span class="line">          <span class="comment">// value属性会被强行对比</span></span><br><span class="line">          <span class="comment">// #1471 force patch value</span></span><br><span class="line">          <span class="keyword">if</span> (next !== prev || key === <span class="string">&quot;value&quot;</span>) &#123;</span><br><span class="line">            <span class="title function_">hostPatchProp</span>(</span><br><span class="line">              el,</span><br><span class="line">              key,</span><br><span class="line">              prev,</span><br><span class="line">              next,</span><br><span class="line">              isSVG,</span><br><span class="line">              n1.<span class="property">children</span> <span class="keyword">as</span> <span class="title class_">VNode</span>[],</span><br><span class="line">              parentComponent,</span><br><span class="line">              parentSuspense,</span><br><span class="line">              unmountChildren</span><br><span class="line">            );</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理文本：仅在元素只有文本子节点时触发</span></span><br><span class="line">    <span class="comment">// text</span></span><br><span class="line">    <span class="comment">// This flag is matched when the element has only dynamic text children.</span></span><br><span class="line">    <span class="keyword">if</span> (patchFlag &amp; <span class="title class_">PatchFlags</span>.<span class="property">TEXT</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (n1.<span class="property">children</span> !== n2.<span class="property">children</span>) &#123;</span><br><span class="line">        <span class="title function_">hostSetElementText</span>(el, n2.<span class="property">children</span> <span class="keyword">as</span> <span class="built_in">string</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!optimized &amp;&amp; dynamicChildren == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 没有优化，全量 diff</span></span><br><span class="line">    <span class="comment">// unoptimized, full diff</span></span><br><span class="line">    <span class="title function_">patchProps</span>(</span><br><span class="line">      el,</span><br><span class="line">      n2,</span><br><span class="line">      oldProps,</span><br><span class="line">      newProps,</span><br><span class="line">      parentComponent,</span><br><span class="line">      parentSuspense,</span><br><span class="line">      isSVG</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// updated 钩子 入队</span></span><br><span class="line">  <span class="keyword">if</span> ((vnodeHook = newProps.<span class="property">onVnodeUpdated</span>) || dirs) &#123;</span><br><span class="line">    <span class="title function_">queuePostRenderEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      vnodeHook &amp;&amp; <span class="title function_">invokeVNodeHook</span>(vnodeHook, parentComponent, n2, n1);</span><br><span class="line">      dirs &amp;&amp; <span class="title function_">invokeDirectiveHook</span>(n2, n1, parentComponent, <span class="string">&quot;updated&quot;</span>);</span><br><span class="line">    &#125;, parentSuspense);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在<code>patchElement</code>中，注意到当新节点具有动态子节点时，调用了<code>patchBlockChildren</code>来进行子节点的比较，而在没有动态子节点且不符合优化条件时，则使用<code>patchChildren</code>来比较。这与<code>processFragment</code>类似。</p><p>而当<code>patchFlag &lt;= 0</code>且没有设置优化时，对<code>props</code>进行全量<code>diff</code>。分别遍历新的<code>props</code>和旧的<code>props</code>，最后刷新<code>value</code>的值。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">patchProps</span> = (<span class="params"></span></span><br><span class="line"><span class="params">  el: RendererElement,</span></span><br><span class="line"><span class="params">  vnode: VNode,</span></span><br><span class="line"><span class="params">  oldProps: Data,</span></span><br><span class="line"><span class="params">  newProps: Data,</span></span><br><span class="line"><span class="params">  parentComponent: ComponentInternalInstance | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  parentSuspense: SuspenseBoundary | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  isSVG: <span class="built_in">boolean</span></span></span><br><span class="line"><span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (oldProps !== newProps) &#123;</span><br><span class="line">    <span class="comment">// 遍历新的props</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> newProps) &#123;</span><br><span class="line">      <span class="comment">// empty string is not valid prop</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isReservedProp</span>(key)) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">const</span> next = newProps[key];</span><br><span class="line">      <span class="keyword">const</span> prev = oldProps[key];</span><br><span class="line">      <span class="comment">// 先不比较 value</span></span><br><span class="line">      <span class="comment">// defer patching value</span></span><br><span class="line">      <span class="keyword">if</span> (next !== prev &amp;&amp; key !== <span class="string">&quot;value&quot;</span>) &#123;</span><br><span class="line">        <span class="title function_">hostPatchProp</span>(</span><br><span class="line">          el,</span><br><span class="line">          key,</span><br><span class="line">          prev,</span><br><span class="line">          next,</span><br><span class="line">          isSVG,</span><br><span class="line">          vnode.<span class="property">children</span> <span class="keyword">as</span> <span class="title class_">VNode</span>[],</span><br><span class="line">          parentComponent,</span><br><span class="line">          parentSuspense,</span><br><span class="line">          unmountChildren</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历旧的props</span></span><br><span class="line">    <span class="keyword">if</span> (oldProps !== <span class="variable constant_">EMPTY_OBJ</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> oldProps) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="title function_">isReservedProp</span>(key) &amp;&amp; !(key <span class="keyword">in</span> newProps)) &#123;</span><br><span class="line">          <span class="title function_">hostPatchProp</span>(</span><br><span class="line">            el,</span><br><span class="line">            key,</span><br><span class="line">            oldProps[key],</span><br><span class="line">            <span class="literal">null</span>,</span><br><span class="line">            isSVG,</span><br><span class="line">            vnode.<span class="property">children</span> <span class="keyword">as</span> <span class="title class_">VNode</span>[],</span><br><span class="line">            parentComponent,</span><br><span class="line">            parentSuspense,</span><br><span class="line">            unmountChildren</span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后处理 value</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;value&quot;</span> <span class="keyword">in</span> newProps) &#123;</span><br><span class="line">      <span class="title function_">hostPatchProp</span>(el, <span class="string">&quot;value&quot;</span>, oldProps.<span class="property">value</span>, newProps.<span class="property">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="7-processComponent"><a href="#7-processComponent" class="headerlink" title="7. processComponent"></a>7. <code>processComponent</code></h3><h4 id="7-1-processComponent"><a href="#7-1-processComponent" class="headerlink" title="7.1 processComponent"></a>7.1 <code>processComponent</code></h4><p>当被<code>patch</code>的节点类型是组件时，通过<code>processComponent</code>来处理。</p><ul><li><p>当旧组件节点存在时，则调用<code>updateComponent</code>进行更新；</p></li><li><p>否则：</p><ul><li>当新组件节点为<code>KeepAlive</code>时，调用其上下文对象上的<code>activate</code>方法；</li><li>否则，使用<code>mountComponent</code>挂载新的组件节点；</li></ul></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">processComponent</span> = (<span class="params"></span></span><br><span class="line"><span class="params">  n1: VNode | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  n2: VNode,</span></span><br><span class="line"><span class="params">  container: RendererElement,</span></span><br><span class="line"><span class="params">  anchor: RendererNode | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  parentComponent: ComponentInternalInstance | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  parentSuspense: SuspenseBoundary | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  isSVG: <span class="built_in">boolean</span>,</span></span><br><span class="line"><span class="params">  slotScopeIds: <span class="built_in">string</span>[] | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  optimized: <span class="built_in">boolean</span></span></span><br><span class="line"><span class="params"></span>) =&gt; &#123;</span><br><span class="line">  n2.<span class="property">slotScopeIds</span> = slotScopeIds;</span><br><span class="line">  <span class="keyword">if</span> (n1 == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n2.<span class="property">shapeFlag</span> &amp; <span class="title class_">ShapeFlags</span>.<span class="property">COMPONENT_KEPT_ALIVE</span>) &#123;</span><br><span class="line">      (parentComponent!.<span class="property">ctx</span> <span class="keyword">as</span> <span class="title class_">KeepAliveContext</span>).<span class="title function_">activate</span>(</span><br><span class="line">        n2,</span><br><span class="line">        container,</span><br><span class="line">        anchor,</span><br><span class="line">        isSVG,</span><br><span class="line">        optimized</span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">mountComponent</span>(</span><br><span class="line">        n2,</span><br><span class="line">        container,</span><br><span class="line">        anchor,</span><br><span class="line">        parentComponent,</span><br><span class="line">        parentSuspense,</span><br><span class="line">        isSVG,</span><br><span class="line">        optimized</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">updateComponent</span>(n1, n2, optimized);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="7-2-mountComponent"><a href="#7-2-mountComponent" class="headerlink" title="7.2 mountComponent"></a>7.2 <code>mountComponent</code></h4><p><code>mountComponent</code>在旧的组件节点不存在时被调用。所有的<code>mountXXX</code>最常见的调用时机都是首次渲染时，旧节点都是空的。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">mountComponent</span>: <span class="title class_">MountComponentFn</span> = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  initialVNode,</span></span></span><br><span class="line"><span class="params"><span class="function">  container,</span></span></span><br><span class="line"><span class="params"><span class="function">  anchor,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentComponent,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentSuspense,</span></span></span><br><span class="line"><span class="params"><span class="function">  isSVG,</span></span></span><br><span class="line"><span class="params"><span class="function">  optimized</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 2.x compat may pre-create the component instance before actually</span></span><br><span class="line">  <span class="comment">// mounting</span></span><br><span class="line">  <span class="keyword">const</span> compatMountInstance =</span><br><span class="line">    __COMPAT__ &amp;&amp; initialVNode.<span class="property">isCompatRoot</span> &amp;&amp; initialVNode.<span class="property">component</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">instance</span>: <span class="title class_">ComponentInternalInstance</span> =</span><br><span class="line">    compatMountInstance ||</span><br><span class="line">    (initialVNode.<span class="property">component</span> = <span class="title function_">createComponentInstance</span>(</span><br><span class="line">      initialVNode,</span><br><span class="line">      parentComponent,</span><br><span class="line">      parentSuspense</span><br><span class="line">    ));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注册热更新</span></span><br><span class="line">  <span class="keyword">if</span> (__DEV__ &amp;&amp; instance.<span class="property">type</span>.<span class="property">__hmrId</span>) &#123;</span><br><span class="line">    <span class="title function_">registerHMR</span>(instance);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 挂载性能检测</span></span><br><span class="line">  <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">    <span class="title function_">pushWarningContext</span>(initialVNode);</span><br><span class="line">    <span class="title function_">startMeasure</span>(instance, <span class="string">`mount`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注入renderer的内部内容</span></span><br><span class="line">  <span class="comment">// inject renderer internals for keepAlive</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isKeepAlive</span>(initialVNode)) &#123;</span><br><span class="line">    (instance.<span class="property">ctx</span> <span class="keyword">as</span> <span class="title class_">KeepAliveContext</span>).<span class="property">renderer</span> = internals;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/** 这里备注一下 internals 的内容</span></span><br><span class="line"><span class="comment">   * const internals: RendererInternals = &#123;</span></span><br><span class="line"><span class="comment">   *   p: patch,</span></span><br><span class="line"><span class="comment">   *   um: unmount,</span></span><br><span class="line"><span class="comment">   *   m: move,</span></span><br><span class="line"><span class="comment">   *   r: remove,</span></span><br><span class="line"><span class="comment">   *   mt: mountComponent,</span></span><br><span class="line"><span class="comment">   *   mc: mountChildren,</span></span><br><span class="line"><span class="comment">   *   pc: patchChildren,</span></span><br><span class="line"><span class="comment">   *   pbc: patchBlockChildren,</span></span><br><span class="line"><span class="comment">   *   n: getNextHostNode,</span></span><br><span class="line"><span class="comment">   *   o: options</span></span><br><span class="line"><span class="comment">   * &#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理props和插槽</span></span><br><span class="line">  <span class="comment">// resolve props and slots for setup context</span></span><br><span class="line">  <span class="keyword">if</span> (!(__COMPAT__ &amp;&amp; compatMountInstance)) &#123;</span><br><span class="line">    <span class="comment">// 检测初始化性能</span></span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      <span class="title function_">startMeasure</span>(instance, <span class="string">`init`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理setup：这个函数里使用其它方法，初始化了props和插槽，且调用了setup</span></span><br><span class="line">    <span class="title function_">setupComponent</span>(instance);</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      <span class="title function_">endMeasure</span>(instance, <span class="string">`init`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理异步的setup</span></span><br><span class="line">  <span class="comment">// setup() is async. This component relies on async logic to be resolved</span></span><br><span class="line">  <span class="comment">// before proceeding</span></span><br><span class="line">  <span class="keyword">if</span> (__FEATURE_SUSPENSE__ &amp;&amp; instance.<span class="property">asyncDep</span>) &#123;</span><br><span class="line">    parentSuspense &amp;&amp; parentSuspense.<span class="title function_">registerDep</span>(instance, setupRenderEffect);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Give it a placeholder if this is not hydration</span></span><br><span class="line">    <span class="comment">// TODO handle self-defined fallback</span></span><br><span class="line">    <span class="keyword">if</span> (!initialVNode.<span class="property">el</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> placeholder = (instance.<span class="property">subTree</span> = <span class="title function_">createVNode</span>(<span class="title class_">Comment</span>));</span><br><span class="line">      <span class="title function_">processCommentNode</span>(<span class="literal">null</span>, placeholder, container!, anchor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 接下来根据setup返回内容进行渲染</span></span><br><span class="line">  <span class="comment">// todo 阅读该函数的内容</span></span><br><span class="line">  <span class="title function_">setupRenderEffect</span>(</span><br><span class="line">    instance,</span><br><span class="line">    initialVNode,</span><br><span class="line">    container,</span><br><span class="line">    anchor,</span><br><span class="line">    parentSuspense,</span><br><span class="line">    isSVG,</span><br><span class="line">    optimized</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// mount性能检测结束点</span></span><br><span class="line">  <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">    <span class="title function_">popWarningContext</span>();</span><br><span class="line">    <span class="title function_">endMeasure</span>(instance, <span class="string">`mount`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="7-3-updateComponent"><a href="#7-3-updateComponent" class="headerlink" title="7.3 updateComponent"></a>7.3 <code>updateComponent</code></h4><p>当旧的组件节点存在时，对组件节点的处理会进入到更新阶段，也就是<code>updateComponent</code>。以旧组件为基准拿到实例<code>instance</code>，通过<code>shouldUpdateComponent</code>判断是否要更新组件。如果不需要更新，则只复制一下属性；否则，当实例是异步组件时，则只更新<code>props</code>和插槽；当实例是同步组件时，则设置<code>next</code>为新的组件节点，并调用组件的<code>update</code>方法进行更新。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">updateComponent</span> = (<span class="params">n1: VNode, n2: VNode, optimized: <span class="built_in">boolean</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> instance = (n2.<span class="property">component</span> = n1.<span class="property">component</span>)!;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">shouldUpdateComponent</span>(n1, n2, optimized)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__FEATURE_SUSPENSE__ &amp;&amp; instance.<span class="property">asyncDep</span> &amp;&amp; !instance.<span class="property">asyncResolved</span>) &#123;</span><br><span class="line">      <span class="comment">// async &amp; still pending - just update props and slots</span></span><br><span class="line">      <span class="comment">// since the component&#x27;s reactive effect for render isn&#x27;t set-up yet</span></span><br><span class="line">      <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        <span class="title function_">pushWarningContext</span>(n2);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 更新组件的预渲染：即处理props和插槽</span></span><br><span class="line">      <span class="title function_">updateComponentPreRender</span>(instance, n2, optimized);</span><br><span class="line">      <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        <span class="title function_">popWarningContext</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// normal update</span></span><br><span class="line">      instance.<span class="property">next</span> = n2;</span><br><span class="line">      <span class="comment">// in case the child component is also queued, remove it to avoid</span></span><br><span class="line">      <span class="comment">// double updating the same child component in the same flush.</span></span><br><span class="line">      <span class="title function_">invalidateJob</span>(instance.<span class="property">update</span>);</span><br><span class="line">      <span class="comment">// instance.update is the reactive effect.</span></span><br><span class="line">      instance.<span class="title function_">update</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// no update needed. just copy over properties</span></span><br><span class="line">    n2.<span class="property">el</span> = n1.<span class="property">el</span>;</span><br><span class="line">    instance.<span class="property">vnode</span> = n2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="7-4-updateComponentPreRender"><a href="#7-4-updateComponentPreRender" class="headerlink" title="7.4 updateComponentPreRender"></a>7.4 <code>updateComponentPreRender</code></h4><p>组件的预渲染，即在这里处理<code>props</code>和插槽。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">updateComponentPreRender</span> = (<span class="params"></span></span><br><span class="line"><span class="params">  instance: ComponentInternalInstance,</span></span><br><span class="line"><span class="params">  nextVNode: VNode,</span></span><br><span class="line"><span class="params">  optimized: <span class="built_in">boolean</span></span></span><br><span class="line"><span class="params"></span>) =&gt; &#123;</span><br><span class="line">  nextVNode.<span class="property">component</span> = instance;</span><br><span class="line">  <span class="keyword">const</span> prevProps = instance.<span class="property">vnode</span>.<span class="property">props</span>;</span><br><span class="line">  instance.<span class="property">vnode</span> = nextVNode;</span><br><span class="line">  instance.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="title function_">updateProps</span>(instance, nextVNode.<span class="property">props</span>, prevProps, optimized);</span><br><span class="line">  <span class="title function_">updateSlots</span>(instance, nextVNode.<span class="property">children</span>, optimized);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">pauseTracking</span>();</span><br><span class="line">  <span class="comment">// props update may have triggered pre-flush watchers.</span></span><br><span class="line">  <span class="comment">// flush them before the render update.</span></span><br><span class="line">  <span class="title function_">flushPreFlushCbs</span>(<span class="literal">undefined</span>, instance.<span class="property">update</span>);</span><br><span class="line">  <span class="title function_">resetTracking</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="7-4-setupRenderEffect"><a href="#7-4-setupRenderEffect" class="headerlink" title="7.4 setupRenderEffect"></a>7.4 <code>setupRenderEffect</code></h4><p>相当重要的一个函数。用<code>componentUpdateFn</code>来创建一个<code>effect</code>。最后执行的<code>update</code>函数以及实例的<code>update</code>方法，都是执行<code>effect.run</code>。而<code>effect.run</code>内部会进行与依赖收集相关的操作，还会调用新建<code>effect</code>时传入的函数<code>componentUpdateFn</code>。这里可以看到<strong><code>componentUpdateFn</code>分为挂载和更新两部分</strong>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">setupRenderEffect</span>: <span class="title class_">SetupRenderEffectFn</span> = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  instance,</span></span></span><br><span class="line"><span class="params"><span class="function">  initialVNode,</span></span></span><br><span class="line"><span class="params"><span class="function">  container,</span></span></span><br><span class="line"><span class="params"><span class="function">  anchor,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentSuspense,</span></span></span><br><span class="line"><span class="params"><span class="function">  isSVG,</span></span></span><br><span class="line"><span class="params"><span class="function">  optimized</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">componentUpdateFn</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!instance.<span class="property">isMounted</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> <span class="attr">vnodeHook</span>: <span class="title class_">VNodeHook</span> | <span class="literal">null</span> | <span class="literal">undefined</span>;</span><br><span class="line">      <span class="keyword">const</span> &#123; el, props &#125; = initialVNode;</span><br><span class="line">      <span class="keyword">const</span> &#123; bm, m, parent &#125; = instance;</span><br><span class="line">      <span class="keyword">const</span> isAsyncWrapperVNode = <span class="title function_">isAsyncWrapper</span>(initialVNode);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 在beforeMounted期间 不允许effect自己调用</span></span><br><span class="line">      <span class="title function_">toggleRecurse</span>(instance, <span class="literal">false</span>);</span><br><span class="line">      <span class="comment">// beforeMount hook</span></span><br><span class="line">      <span class="keyword">if</span> (bm) &#123;</span><br><span class="line">        <span class="title function_">invokeArrayFns</span>(bm);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// onVnodeBeforeMount</span></span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        !isAsyncWrapperVNode &amp;&amp;</span><br><span class="line">        (vnodeHook = props &amp;&amp; props.<span class="property">onVnodeBeforeMount</span>)</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="title function_">invokeVNodeHook</span>(vnodeHook, parent, initialVNode);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        __COMPAT__ &amp;&amp;</span><br><span class="line">        <span class="title function_">isCompatEnabled</span>(<span class="title class_">DeprecationTypes</span>.<span class="property">INSTANCE_EVENT_HOOKS</span>, instance)</span><br><span class="line">      ) &#123;</span><br><span class="line">        instance.<span class="title function_">emit</span>(<span class="string">&quot;hook:beforeMount&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">toggleRecurse</span>(instance, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (el &amp;&amp; hydrateNode) &#123;</span><br><span class="line">        <span class="comment">// vnode has adopted host node - perform hydration instead of mount.</span></span><br><span class="line">        <span class="keyword">const</span> <span class="title function_">hydrateSubTree</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">            <span class="title function_">startMeasure</span>(instance, <span class="string">`render`</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          instance.<span class="property">subTree</span> = <span class="title function_">renderComponentRoot</span>(instance);</span><br><span class="line">          <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">            <span class="title function_">endMeasure</span>(instance, <span class="string">`render`</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">            <span class="title function_">startMeasure</span>(instance, <span class="string">`hydrate`</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          hydrateNode!(</span><br><span class="line">            el <span class="keyword">as</span> <span class="title class_">Node</span>,</span><br><span class="line">            instance.<span class="property">subTree</span>,</span><br><span class="line">            instance,</span><br><span class="line">            parentSuspense,</span><br><span class="line">            <span class="literal">null</span></span><br><span class="line">          );</span><br><span class="line">          <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">            <span class="title function_">endMeasure</span>(instance, <span class="string">`hydrate`</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isAsyncWrapperVNode) &#123;</span><br><span class="line">          (initialVNode.<span class="property">type</span> <span class="keyword">as</span> <span class="title class_">ComponentOptions</span>).<span class="property">__asyncLoader</span>!().<span class="title function_">then</span>(</span><br><span class="line">            <span class="comment">// note: we are moving the render call into an async callback,</span></span><br><span class="line">            <span class="comment">// which means it won&#x27;t track dependencies - but it&#x27;s ok because</span></span><br><span class="line">            <span class="comment">// a server-rendered async wrapper is already in resolved state</span></span><br><span class="line">            <span class="comment">// and it will never need to change.</span></span><br><span class="line">            <span class="function">() =&gt;</span> !instance.<span class="property">isUnmounted</span> &amp;&amp; <span class="title function_">hydrateSubTree</span>()</span><br><span class="line">          );</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="title function_">hydrateSubTree</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">          <span class="title function_">startMeasure</span>(instance, <span class="string">`render`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> subTree = (instance.<span class="property">subTree</span> = <span class="title function_">renderComponentRoot</span>(instance));</span><br><span class="line">        <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">          <span class="title function_">endMeasure</span>(instance, <span class="string">`render`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">          <span class="title function_">startMeasure</span>(instance, <span class="string">`patch`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">patch</span>(</span><br><span class="line">          <span class="literal">null</span>,</span><br><span class="line">          subTree,</span><br><span class="line">          container,</span><br><span class="line">          anchor,</span><br><span class="line">          instance,</span><br><span class="line">          parentSuspense,</span><br><span class="line">          isSVG</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">          <span class="title function_">endMeasure</span>(instance, <span class="string">`patch`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        initialVNode.<span class="property">el</span> = subTree.<span class="property">el</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// mounted钩子入队</span></span><br><span class="line">      <span class="comment">// mounted hook</span></span><br><span class="line">      <span class="keyword">if</span> (m) &#123;</span><br><span class="line">        <span class="title function_">queuePostRenderEffect</span>(m, parentSuspense);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// onVnodeMounted</span></span><br><span class="line">      <span class="keyword">if</span> (!isAsyncWrapperVNode &amp;&amp; (vnodeHook = props &amp;&amp; props.<span class="property">onVnodeMounted</span>)) &#123;</span><br><span class="line">        <span class="keyword">const</span> scopedInitialVNode = initialVNode;</span><br><span class="line">        <span class="title function_">queuePostRenderEffect</span>(</span><br><span class="line">          <span class="function">() =&gt;</span> <span class="title function_">invokeVNodeHook</span>(vnodeHook!, parent, scopedInitialVNode),</span><br><span class="line">          parentSuspense</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        __COMPAT__ &amp;&amp;</span><br><span class="line">        <span class="title function_">isCompatEnabled</span>(<span class="title class_">DeprecationTypes</span>.<span class="property">INSTANCE_EVENT_HOOKS</span>, instance)</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="title function_">queuePostRenderEffect</span>(</span><br><span class="line">          <span class="function">() =&gt;</span> instance.<span class="title function_">emit</span>(<span class="string">&quot;hook:mounted&quot;</span>),</span><br><span class="line">          parentSuspense</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// &lt;KeepAlive&gt;组件的activated钩子，可能包含从子组件注入的钩子</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// activated hook for keep-alive roots.</span></span><br><span class="line">      <span class="comment">// #1742 activated hook must be accessed after first render</span></span><br><span class="line">      <span class="comment">// since the hook may be injected by a child keep-alive</span></span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        initialVNode.<span class="property">shapeFlag</span> &amp; <span class="title class_">ShapeFlags</span>.<span class="property">COMPONENT_SHOULD_KEEP_ALIVE</span> ||</span><br><span class="line">        (parent &amp;&amp;</span><br><span class="line">          <span class="title function_">isAsyncWrapper</span>(parent.<span class="property">vnode</span>) &amp;&amp;</span><br><span class="line">          parent.<span class="property">vnode</span>.<span class="property">shapeFlag</span> &amp; <span class="title class_">ShapeFlags</span>.<span class="property">COMPONENT_SHOULD_KEEP_ALIVE</span>)</span><br><span class="line">      ) &#123;</span><br><span class="line">        instance.<span class="property">a</span> &amp;&amp; <span class="title function_">queuePostRenderEffect</span>(instance.<span class="property">a</span>, parentSuspense);</span><br><span class="line">        <span class="comment">// 兼容</span></span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">          __COMPAT__ &amp;&amp;</span><br><span class="line">          <span class="title function_">isCompatEnabled</span>(<span class="title class_">DeprecationTypes</span>.<span class="property">INSTANCE_EVENT_HOOKS</span>, instance)</span><br><span class="line">        ) &#123;</span><br><span class="line">          <span class="title function_">queuePostRenderEffect</span>(</span><br><span class="line">            <span class="function">() =&gt;</span> instance.<span class="title function_">emit</span>(<span class="string">&quot;hook:activated&quot;</span>),</span><br><span class="line">            parentSuspense</span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 变更组件挂载状态</span></span><br><span class="line">      instance.<span class="property">isMounted</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (__DEV__ || __FEATURE_PROD_DEVTOOLS__) &#123;</span><br><span class="line">        <span class="title function_">devtoolsComponentAdded</span>(instance);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// #2458: deference mount-only object parameters to prevent memleaks</span></span><br><span class="line">      initialVNode = container = anchor = <span class="literal">null</span> <span class="keyword">as</span> <span class="built_in">any</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// updateComponent</span></span><br><span class="line">      <span class="comment">// This is triggered by mutation of component&#x27;s own state (next: null)</span></span><br><span class="line">      <span class="comment">// OR parent calling processComponent (next: VNode)</span></span><br><span class="line">      <span class="keyword">let</span> &#123; next, bu, u, parent, vnode &#125; = instance;</span><br><span class="line">      <span class="keyword">let</span> originNext = next;</span><br><span class="line">      <span class="keyword">let</span> <span class="attr">vnodeHook</span>: <span class="title class_">VNodeHook</span> | <span class="literal">null</span> | <span class="literal">undefined</span>;</span><br><span class="line">      <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        <span class="title function_">pushWarningContext</span>(next || instance.<span class="property">vnode</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// beforeUpdated 期间也不允许effect自调用</span></span><br><span class="line">      <span class="comment">// Disallow component effect recursion during pre-lifecycle hooks.</span></span><br><span class="line">      <span class="title function_">toggleRecurse</span>(instance, <span class="literal">false</span>);</span><br><span class="line">      <span class="keyword">if</span> (next) &#123;</span><br><span class="line">        next.<span class="property">el</span> = vnode.<span class="property">el</span>;</span><br><span class="line">        <span class="title function_">updateComponentPreRender</span>(instance, next, optimized);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next = vnode;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// beforeUpdate hook</span></span><br><span class="line">      <span class="keyword">if</span> (bu) &#123;</span><br><span class="line">        <span class="title function_">invokeArrayFns</span>(bu);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// onVnodeBeforeUpdate</span></span><br><span class="line">      <span class="keyword">if</span> ((vnodeHook = next.<span class="property">props</span> &amp;&amp; next.<span class="property">props</span>.<span class="property">onVnodeBeforeUpdate</span>)) &#123;</span><br><span class="line">        <span class="title function_">invokeVNodeHook</span>(vnodeHook, parent, next, vnode);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 考虑兼容</span></span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        __COMPAT__ &amp;&amp;</span><br><span class="line">        <span class="title function_">isCompatEnabled</span>(<span class="title class_">DeprecationTypes</span>.<span class="property">INSTANCE_EVENT_HOOKS</span>, instance)</span><br><span class="line">      ) &#123;</span><br><span class="line">        instance.<span class="title function_">emit</span>(<span class="string">&quot;hook:beforeUpdate&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">toggleRecurse</span>(instance, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// render</span></span><br><span class="line">      <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        <span class="title function_">startMeasure</span>(instance, <span class="string">`render`</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> nextTree = <span class="title function_">renderComponentRoot</span>(instance);</span><br><span class="line">      <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        <span class="title function_">endMeasure</span>(instance, <span class="string">`render`</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> prevTree = instance.<span class="property">subTree</span>;</span><br><span class="line">      instance.<span class="property">subTree</span> = nextTree;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        <span class="title function_">startMeasure</span>(instance, <span class="string">`patch`</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 更新则比较新旧subTree</span></span><br><span class="line">      <span class="title function_">patch</span>(</span><br><span class="line">        prevTree,</span><br><span class="line">        nextTree,</span><br><span class="line">        <span class="comment">// parent may have changed if it&#x27;s in a teleport</span></span><br><span class="line">        <span class="title function_">hostParentNode</span>(prevTree.<span class="property">el</span>!)!,</span><br><span class="line">        <span class="comment">// anchor may have changed if it&#x27;s in a fragment</span></span><br><span class="line">        <span class="title function_">getNextHostNode</span>(prevTree),</span><br><span class="line">        instance,</span><br><span class="line">        parentSuspense,</span><br><span class="line">        isSVG</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        <span class="title function_">endMeasure</span>(instance, <span class="string">`patch`</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      next.<span class="property">el</span> = nextTree.<span class="property">el</span>;</span><br><span class="line">      <span class="keyword">if</span> (originNext === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// self-triggered update. In case of HOC, update parent component</span></span><br><span class="line">        <span class="comment">// vnode el. HOC is indicated by parent instance&#x27;s subTree pointing</span></span><br><span class="line">        <span class="comment">// to child component&#x27;s vnode</span></span><br><span class="line">        <span class="title function_">updateHOCHostEl</span>(instance, nextTree.<span class="property">el</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 处理updated钩子</span></span><br><span class="line">      <span class="comment">// updated hook</span></span><br><span class="line">      <span class="keyword">if</span> (u) &#123;</span><br><span class="line">        <span class="title function_">queuePostRenderEffect</span>(u, parentSuspense);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// onVnodeUpdated</span></span><br><span class="line">      <span class="keyword">if</span> ((vnodeHook = next.<span class="property">props</span> &amp;&amp; next.<span class="property">props</span>.<span class="property">onVnodeUpdated</span>)) &#123;</span><br><span class="line">        <span class="title function_">queuePostRenderEffect</span>(</span><br><span class="line">          <span class="function">() =&gt;</span> <span class="title function_">invokeVNodeHook</span>(vnodeHook!, parent, next!, vnode),</span><br><span class="line">          parentSuspense</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        __COMPAT__ &amp;&amp;</span><br><span class="line">        <span class="title function_">isCompatEnabled</span>(<span class="title class_">DeprecationTypes</span>.<span class="property">INSTANCE_EVENT_HOOKS</span>, instance)</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="title function_">queuePostRenderEffect</span>(</span><br><span class="line">          <span class="function">() =&gt;</span> instance.<span class="title function_">emit</span>(<span class="string">&quot;hook:updated&quot;</span>),</span><br><span class="line">          parentSuspense</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (__DEV__ || __FEATURE_PROD_DEVTOOLS__) &#123;</span><br><span class="line">        <span class="title function_">devtoolsComponentUpdated</span>(instance);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        <span class="title function_">popWarningContext</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用componentUpdateFn创建effect</span></span><br><span class="line">  <span class="comment">// create reactive effect for rendering</span></span><br><span class="line">  <span class="keyword">const</span> effect = (instance.<span class="property">effect</span> = <span class="keyword">new</span> <span class="title class_">ReactiveEffect</span>(</span><br><span class="line">    componentUpdateFn,</span><br><span class="line">    <span class="function">() =&gt;</span> <span class="title function_">queueJob</span>(update),</span><br><span class="line">    instance.<span class="property">scope</span> <span class="comment">// track it in component&#x27;s effect scope</span></span><br><span class="line">  ));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">update</span>: <span class="title class_">SchedulerJob</span> = (instance.<span class="property">update</span> = <span class="function">() =&gt;</span> effect.<span class="title function_">run</span>());</span><br><span class="line">  update.<span class="property">id</span> = instance.<span class="property">uid</span>;</span><br><span class="line">  <span class="comment">// allowRecurse</span></span><br><span class="line">  <span class="comment">// #1801, #2043 component render effects should allow recursive updates</span></span><br><span class="line">  <span class="title function_">toggleRecurse</span>(instance, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于开发调试</span></span><br><span class="line">  <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">    effect.<span class="property">onTrack</span> = instance.<span class="property">rtc</span></span><br><span class="line">      ? <span class="function">(<span class="params">e</span>) =&gt;</span> <span class="title function_">invokeArrayFns</span>(instance.<span class="property">rtc</span>!, e)</span><br><span class="line">      : <span class="built_in">void</span> <span class="number">0</span>;</span><br><span class="line">    effect.<span class="property">onTrigger</span> = instance.<span class="property">rtg</span></span><br><span class="line">      ? <span class="function">(<span class="params">e</span>) =&gt;</span> <span class="title function_">invokeArrayFns</span>(instance.<span class="property">rtg</span>!, e)</span><br><span class="line">      : <span class="built_in">void</span> <span class="number">0</span>;</span><br><span class="line">    update.<span class="property">ownerInstance</span> = instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用一次更新</span></span><br><span class="line">  <span class="title function_">update</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="8-unmount"><a href="#8-unmount" class="headerlink" title="8. unmount"></a>8. <code>unmount</code></h3><p>旧节点的卸载通过<code>unmount</code>来处理，其中根据节点类型不同，又有着不同的函数来实施卸载。</p><h4 id="8-1-unmount"><a href="#8-1-unmount" class="headerlink" title="8.1 unmount"></a>8.1 <code>unmount</code></h4><p>经过置空<code>ref</code>、判断与处理<code>KeepAlive</code>、<code>beforeUnmounted</code>的钩子函数和指令、判断组件的类型并相应卸载、处理<code>unmounted</code>钩子和指令等过程。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">unmount</span>: <span class="title class_">UnmountFn</span> = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  vnode,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentComponent,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentSuspense,</span></span></span><br><span class="line"><span class="params"><span class="function">  doRemove = <span class="literal">false</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  optimized = <span class="literal">false</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">type</span>,</span><br><span class="line">    props,</span><br><span class="line">    ref,</span><br><span class="line">    children,</span><br><span class="line">    dynamicChildren,</span><br><span class="line">    shapeFlag,</span><br><span class="line">    patchFlag,</span><br><span class="line">    dirs,</span><br><span class="line">  &#125; = vnode;</span><br><span class="line">  <span class="comment">// 置空ref</span></span><br><span class="line">  <span class="comment">// unset ref</span></span><br><span class="line">  <span class="keyword">if</span> (ref != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="title function_">setRef</span>(ref, <span class="literal">null</span>, parentSuspense, vnode, <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 组件被缓存，则调用&lt;KeepAlive&gt;的失活方法 deactivate</span></span><br><span class="line">  <span class="keyword">if</span> (shapeFlag &amp; <span class="title class_">ShapeFlags</span>.<span class="property">COMPONENT_SHOULD_KEEP_ALIVE</span>) &#123;</span><br><span class="line">    (parentComponent!.<span class="property">ctx</span> <span class="keyword">as</span> <span class="title class_">KeepAliveContext</span>).<span class="title function_">deactivate</span>(vnode);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是否调用指令和钩子</span></span><br><span class="line">  <span class="keyword">const</span> shouldInvokeDirs = shapeFlag &amp; <span class="title class_">ShapeFlags</span>.<span class="property">ELEMENT</span> &amp;&amp; dirs;</span><br><span class="line">  <span class="keyword">const</span> shouldInvokeVnodeHook = !<span class="title function_">isAsyncWrapper</span>(vnode);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// beforeUnmounted 钩子</span></span><br><span class="line">  <span class="keyword">let</span> <span class="attr">vnodeHook</span>: <span class="title class_">VNodeHook</span> | <span class="literal">undefined</span> | <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    shouldInvokeVnodeHook &amp;&amp;</span><br><span class="line">    (vnodeHook = props &amp;&amp; props.<span class="property">onVnodeBeforeUnmount</span>)</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="title function_">invokeVNodeHook</span>(vnodeHook, parentComponent, vnode);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (shapeFlag &amp; <span class="title class_">ShapeFlags</span>.<span class="property">COMPONENT</span>) &#123;</span><br><span class="line">    <span class="comment">// 卸载组件</span></span><br><span class="line">    <span class="title function_">unmountComponent</span>(vnode.<span class="property">component</span>!, parentSuspense, doRemove);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 卸载异步组件</span></span><br><span class="line">    <span class="keyword">if</span> (__FEATURE_SUSPENSE__ &amp;&amp; shapeFlag &amp; <span class="title class_">ShapeFlags</span>.<span class="property">SUSPENSE</span>) &#123;</span><br><span class="line">      vnode.<span class="property">suspense</span>!.<span class="title function_">unmount</span>(parentSuspense, doRemove);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理指令的 beforeUnmounted 阶段</span></span><br><span class="line">    <span class="keyword">if</span> (shouldInvokeDirs) &#123;</span><br><span class="line">      <span class="title function_">invokeDirectiveHook</span>(vnode, <span class="literal">null</span>, parentComponent, <span class="string">&quot;beforeUnmount&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 卸载 Teleport</span></span><br><span class="line">    <span class="keyword">if</span> (shapeFlag &amp; <span class="title class_">ShapeFlags</span>.<span class="property">TELEPORT</span>) &#123;</span><br><span class="line">      (vnode.<span class="property">type</span> <span class="keyword">as</span> <span class="keyword">typeof</span> <span class="title class_">TeleportImpl</span>).<span class="title function_">remove</span>(</span><br><span class="line">        vnode,</span><br><span class="line">        parentComponent,</span><br><span class="line">        parentSuspense,</span><br><span class="line">        optimized,</span><br><span class="line">        internals,</span><br><span class="line">        doRemove</span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">      dynamicChildren &amp;&amp;</span><br><span class="line">      <span class="comment">// #1153: fast path should not be taken for non-stable (v-for) fragments</span></span><br><span class="line">      (<span class="keyword">type</span> !== <span class="title class_">Fragment</span> ||</span><br><span class="line">        (patchFlag &gt; <span class="number">0</span> &amp;&amp; patchFlag &amp; <span class="title class_">PatchFlags</span>.<span class="property">STABLE_FRAGMENT</span>))</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// 对于优化过的块状节点，仅需移除动态子节点</span></span><br><span class="line">      <span class="comment">// fast path for block nodes: only need to unmount dynamic children.</span></span><br><span class="line">      <span class="title function_">unmountChildren</span>(</span><br><span class="line">        dynamicChildren,</span><br><span class="line">        parentComponent,</span><br><span class="line">        parentSuspense,</span><br><span class="line">        <span class="literal">false</span>,</span><br><span class="line">        <span class="literal">true</span></span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">      <span class="comment">// 文档片段  移除其子节点</span></span><br><span class="line">      (<span class="keyword">type</span> === <span class="title class_">Fragment</span> &amp;&amp;</span><br><span class="line">        patchFlag &amp;</span><br><span class="line">          (<span class="title class_">PatchFlags</span>.<span class="property">KEYED_FRAGMENT</span> | <span class="title class_">PatchFlags</span>.<span class="property">UNKEYED_FRAGMENT</span>)) ||</span><br><span class="line">      (!optimized &amp;&amp; shapeFlag &amp; <span class="title class_">ShapeFlags</span>.<span class="property">ARRAY_CHILDREN</span>)</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="title function_">unmountChildren</span>(children <span class="keyword">as</span> <span class="title class_">VNode</span>[], parentComponent, parentSuspense);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理节点自身</span></span><br><span class="line">    <span class="keyword">if</span> (doRemove) &#123;</span><br><span class="line">      <span class="title function_">remove</span>(vnode);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理 unmounted 钩子以及指令中的 unmounted 阶段</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    (shouldInvokeVnodeHook &amp;&amp; (vnodeHook = props &amp;&amp; props.<span class="property">onVnodeUnmounted</span>)) ||</span><br><span class="line">    shouldInvokeDirs</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="title function_">queuePostRenderEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      vnodeHook &amp;&amp; <span class="title function_">invokeVNodeHook</span>(vnodeHook, parentComponent, vnode);</span><br><span class="line">      shouldInvokeDirs &amp;&amp;</span><br><span class="line">        <span class="title function_">invokeDirectiveHook</span>(vnode, <span class="literal">null</span>, parentComponent, <span class="string">&quot;unmounted&quot;</span>);</span><br><span class="line">    &#125;, parentSuspense);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="8-2-remove"><a href="#8-2-remove" class="headerlink" title="8.2 remove"></a>8.2 <code>remove</code></h4><p>使用<code>remove</code>来移除一个节点。根据节点类型与环境，执行的逻辑也稍有差别。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">remove</span>: <span class="title class_">RemoveFn</span> = <span class="function">(<span class="params">vnode</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="keyword">type</span>, el, anchor, transition &#125; = vnode;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">type</span> === <span class="title class_">Fragment</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      __DEV__ &amp;&amp;</span><br><span class="line">      vnode.<span class="property">patchFlag</span> &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">      vnode.<span class="property">patchFlag</span> &amp; <span class="title class_">PatchFlags</span>.<span class="property">DEV_ROOT_FRAGMENT</span> &amp;&amp;</span><br><span class="line">      transition &amp;&amp;</span><br><span class="line">      !transition.<span class="property">persisted</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// __DEV__环境</span></span><br><span class="line">      <span class="comment">// 遍历移除子节点</span></span><br><span class="line">      (vnode.<span class="property">children</span> <span class="keyword">as</span> <span class="title class_">VNode</span>[]).<span class="title function_">forEach</span>(<span class="function">(<span class="params">child</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (child.<span class="property">type</span> === <span class="title class_">Comment</span>) &#123;</span><br><span class="line">          <span class="title function_">hostRemove</span>(child.<span class="property">el</span>!);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="title function_">remove</span>(child);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 移除片段</span></span><br><span class="line">      <span class="title function_">removeFragment</span>(el!, anchor!);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 移除静态节点</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">type</span> === <span class="title class_">Static</span>) &#123;</span><br><span class="line">    <span class="title function_">removeStaticNode</span>(vnode);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 遍历移除静态节点</span></span><br><span class="line"><span class="comment">   *  const removeStaticNode = (&#123; el, anchor &#125;: VNode) =&gt; &#123;</span></span><br><span class="line"><span class="comment">   *    let next</span></span><br><span class="line"><span class="comment">   *    while (el &amp;&amp; el !== anchor) &#123;</span></span><br><span class="line"><span class="comment">   *      next = hostNextSibling(el)</span></span><br><span class="line"><span class="comment">   *      hostRemove(el)</span></span><br><span class="line"><span class="comment">   *      el = next</span></span><br><span class="line"><span class="comment">   *    &#125;</span></span><br><span class="line"><span class="comment">   *    hostRemove(anchor!)</span></span><br><span class="line"><span class="comment">   *  &#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">performRemove</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 移除el</span></span><br><span class="line">    <span class="title function_">hostRemove</span>(el!);</span><br><span class="line">    <span class="keyword">if</span> (transition &amp;&amp; !transition.<span class="property">persisted</span> &amp;&amp; transition.<span class="property">afterLeave</span>) &#123;</span><br><span class="line">      <span class="comment">// 动画的 afterLeave 钩子</span></span><br><span class="line">      transition.<span class="title function_">afterLeave</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    vnode.<span class="property">shapeFlag</span> &amp; <span class="title class_">ShapeFlags</span>.<span class="property">ELEMENT</span> &amp;&amp;</span><br><span class="line">    transition &amp;&amp;</span><br><span class="line">    !transition.<span class="property">persisted</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; leave, delayLeave &#125; = transition;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">performLeave</span> = (<span class="params"></span>) =&gt; <span class="title function_">leave</span>(el!, performRemove);</span><br><span class="line">    <span class="comment">// 推迟 leave 动画</span></span><br><span class="line">    <span class="keyword">if</span> (delayLeave) &#123;</span><br><span class="line">      <span class="title function_">delayLeave</span>(vnode.<span class="property">el</span>!, performRemove, performLeave);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">performLeave</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 执行</span></span><br><span class="line">    <span class="title function_">performRemove</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="8-3-removeFragment"><a href="#8-3-removeFragment" class="headerlink" title="8.3 removeFragment"></a>8.3 <code>removeFragment</code></h4><p>直接遍历移除所有包含的节点，这一点与移除静态节点十分相似。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">removeFragment</span> = (<span class="params">cur: RendererNode, end: RendererNode</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// For fragments, directly remove all contained DOM nodes.</span></span><br><span class="line">  <span class="comment">// (fragment child nodes cannot have transition)</span></span><br><span class="line">  <span class="keyword">let</span> next;</span><br><span class="line">  <span class="keyword">while</span> (cur !== end) &#123;</span><br><span class="line">    next = <span class="title function_">hostNextSibling</span>(cur)!;</span><br><span class="line">    <span class="title function_">hostRemove</span>(cur);</span><br><span class="line">    cur = next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">hostRemove</span>(end);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="8-4-unmountComponent"><a href="#8-4-unmountComponent" class="headerlink" title="8.4 unmountComponent"></a>8.4 <code>unmountComponent</code></h4><p>对于组件的卸载，步骤稍微多一点。毕竟除了要遍历卸载子组件树，要处理组件的钩子函数，甚至考虑异步组件。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">unmountComponent</span> = (<span class="params"></span></span><br><span class="line"><span class="params">  instance: ComponentInternalInstance,</span></span><br><span class="line"><span class="params">  parentSuspense: SuspenseBoundary | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  doRemove?: <span class="built_in">boolean</span></span></span><br><span class="line"><span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (__DEV__ &amp;&amp; instance.<span class="property">type</span>.<span class="property">__hmrId</span>) &#123;</span><br><span class="line">    <span class="title function_">unregisterHMR</span>(instance);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; bum, scope, update, subTree, um &#125; = instance;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用 beforeUnmounted 钩子</span></span><br><span class="line">  <span class="comment">// beforeUnmount hook</span></span><br><span class="line">  <span class="keyword">if</span> (bum) &#123;</span><br><span class="line">    <span class="title function_">invokeArrayFns</span>(bum);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    __COMPAT__ &amp;&amp;</span><br><span class="line">    <span class="title function_">isCompatEnabled</span>(<span class="title class_">DeprecationTypes</span>.<span class="property">INSTANCE_EVENT_HOOKS</span>, instance)</span><br><span class="line">  ) &#123;</span><br><span class="line">    instance.<span class="title function_">emit</span>(<span class="string">&quot;hook:beforeDestroy&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 停止副作用</span></span><br><span class="line">  <span class="comment">// stop effects in component scope</span></span><br><span class="line">  scope.<span class="title function_">stop</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关闭 update，卸载子组件树</span></span><br><span class="line">  <span class="comment">// update may be null if a component is unmounted before its async</span></span><br><span class="line">  <span class="comment">// setup has resolved.</span></span><br><span class="line">  <span class="keyword">if</span> (update) &#123;</span><br><span class="line">    <span class="comment">// so that scheduler will no longer invoke it</span></span><br><span class="line">    update.<span class="property">active</span> = <span class="literal">false</span>;</span><br><span class="line">    <span class="title function_">unmount</span>(subTree, instance, parentSuspense, doRemove);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 调用unmounted钩子</span></span><br><span class="line">  <span class="comment">// unmounted hook</span></span><br><span class="line">  <span class="keyword">if</span> (um) &#123;</span><br><span class="line">    <span class="title function_">queuePostRenderEffect</span>(um, parentSuspense);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 向后兼容：destroyed 钩子</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    __COMPAT__ &amp;&amp;</span><br><span class="line">    <span class="title function_">isCompatEnabled</span>(<span class="title class_">DeprecationTypes</span>.<span class="property">INSTANCE_EVENT_HOOKS</span>, instance)</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="title function_">queuePostRenderEffect</span>(</span><br><span class="line">      <span class="function">() =&gt;</span> instance.<span class="title function_">emit</span>(<span class="string">&quot;hook:destroyed&quot;</span>),</span><br><span class="line">      parentSuspense</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 更改状态为已卸载</span></span><br><span class="line">  <span class="title function_">queuePostRenderEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    instance.<span class="property">isUnmounted</span> = <span class="literal">true</span>;</span><br><span class="line">  &#125;, parentSuspense);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理&lt;Suspense&gt;</span></span><br><span class="line">  <span class="comment">// A component with async dep inside a pending suspense is unmounted before</span></span><br><span class="line">  <span class="comment">// its async dep resolves. This should remove the dep from the suspense, and</span></span><br><span class="line">  <span class="comment">// cause the suspense to resolve immediately if that was the last dep.</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    __FEATURE_SUSPENSE__ &amp;&amp;</span><br><span class="line">    parentSuspense &amp;&amp;</span><br><span class="line">    parentSuspense.<span class="property">pendingBranch</span> &amp;&amp;</span><br><span class="line">    !parentSuspense.<span class="property">isUnmounted</span> &amp;&amp;</span><br><span class="line">    instance.<span class="property">asyncDep</span> &amp;&amp;</span><br><span class="line">    !instance.<span class="property">asyncResolved</span> &amp;&amp;</span><br><span class="line">    instance.<span class="property">suspenseId</span> === parentSuspense.<span class="property">pendingId</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    parentSuspense.<span class="property">deps</span>--;</span><br><span class="line">    <span class="keyword">if</span> (parentSuspense.<span class="property">deps</span> === <span class="number">0</span>) &#123;</span><br><span class="line">      parentSuspense.<span class="title function_">resolve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__DEV__ || __FEATURE_PROD_DEVTOOLS__) &#123;</span><br><span class="line">    <span class="title function_">devtoolsComponentRemoved</span>(instance);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="8-5-unmountChildren"><a href="#8-5-unmountChildren" class="headerlink" title="8.5 unmountChildren"></a>8.5 <code>unmountChildren</code></h4><p>卸载子节点，遍历递归<code>unmount</code>方法进行卸载。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">unmountChildren</span>: <span class="title class_">UnmountChildrenFn</span> = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  children,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentComponent,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentSuspense,</span></span></span><br><span class="line"><span class="params"><span class="function">  doRemove = <span class="literal">false</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  optimized = <span class="literal">false</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  start = <span class="number">0</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt; children.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="title function_">unmount</span>(children[i], parentComponent, parentSuspense, doRemove, optimized);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="9-小结"><a href="#9-小结" class="headerlink" title="9. 小结"></a>9. 小结</h3><p><code>render</code>只是个引子，绝大部分功能如节点挂载、节点更新都被<code>patch</code>涵盖了。<code>diff</code>算法在同层级进行遍历比较，核心内容都在<code>patchKeyedChildren</code>中，首尾节点各自循环一轮，对于中间的节点，则利用<code>Map</code>来映射<code>key</code>和节点在新子节点组中的<code>index</code>，再遍历剩余的旧子节点组，在<code>Map</code>中找相同的<code>key</code>里确定这个旧节点是否可复用。没有<code>key</code>的情况则使用<code>patchUnkeyedChildren</code>进行<code>diff</code>，简单粗暴。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前 端 </tag>
            
            <tag> Vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3源码系列（七）：createApp — 一切的起源</title>
      <link href="/articals/aec8236e/"/>
      <url>/articals/aec8236e/</url>
      
        <content type="html"><![CDATA[<p>前面几篇介绍的大都是<code>reactivity</code>相关的<code>API</code>。我们在使用<code>Vue3</code>作为前端框架时，往往在我们的<code>main.js/main.ts</code>里来创建<code>vue3</code>的<code>app</code>实例，就会用到<code>createApp</code>这个<code>API</code>。本篇就来简要了解一下<code>createApp</code>里发生的故事。</p><h2 id="一、相关-ts-类型"><a href="#一、相关-ts-类型" class="headerlink" title="一、相关 ts 类型"></a>一、相关 <code>ts</code> 类型</h2><p>可以先瞄一眼与<code>createAppApi</code>相关的<code>ts</code>类型，这样就更能理解它的使用，这里挑几个简要介绍一下。</p><h3 id="1-App"><a href="#1-App" class="headerlink" title="1. App"></a>1. <code>App</code></h3><p><code>App</code>是<code>createApp</code>返回值的类型，可以看到项目里常用的一些方法都在这里，某些方法返回了<code>this</code>，则可以链式调用。此外，还兼容了<code>vue2</code>的<code>filter</code>，还有一些内部的属性。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">App</span>&lt;<span class="title class_">HostElement</span> = <span class="built_in">any</span>&gt; &#123;</span><br><span class="line">  <span class="attr">version</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="comment">// config 上有常用到的 globalProperties</span></span><br><span class="line">  <span class="attr">config</span>: <span class="title class_">AppConfig</span>;</span><br><span class="line">  <span class="title function_">use</span>(<span class="attr">plugin</span>: <span class="title class_">Plugin</span>, ...<span class="attr">options</span>: <span class="built_in">any</span>[]): <span class="variable language_">this</span>;</span><br><span class="line">  <span class="title function_">mixin</span>(<span class="attr">mixin</span>: <span class="title class_">ComponentOptions</span>): <span class="variable language_">this</span>;</span><br><span class="line">  <span class="title function_">component</span>(<span class="attr">name</span>: <span class="built_in">string</span>): <span class="title class_">Component</span> | <span class="literal">undefined</span>;</span><br><span class="line">  <span class="title function_">component</span>(<span class="attr">name</span>: <span class="built_in">string</span>, <span class="attr">component</span>: <span class="title class_">Component</span>): <span class="variable language_">this</span>;</span><br><span class="line">  <span class="title function_">directive</span>(<span class="attr">name</span>: <span class="built_in">string</span>): <span class="title class_">Directive</span> | <span class="literal">undefined</span>;</span><br><span class="line">  <span class="title function_">directive</span>(<span class="attr">name</span>: <span class="built_in">string</span>, <span class="attr">directive</span>: <span class="title class_">Directive</span>): <span class="variable language_">this</span>;</span><br><span class="line">  <span class="title function_">mount</span>(</span><br><span class="line">    <span class="attr">rootContainer</span>: <span class="title class_">HostElement</span> | <span class="built_in">string</span>,</span><br><span class="line">    isHydrate?: <span class="built_in">boolean</span>,</span><br><span class="line">    isSVG?: <span class="built_in">boolean</span></span><br><span class="line">  ): <span class="title class_">ComponentPublicInstance</span>;</span><br><span class="line">  <span class="title function_">unmount</span>(): <span class="built_in">void</span>;</span><br><span class="line">  provide&lt;T&gt;(<span class="attr">key</span>: <span class="title class_">InjectionKey</span>&lt;T&gt; | <span class="built_in">string</span>, <span class="attr">value</span>: T): <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// internal, but we need to expose these for the server-renderer and devtools</span></span><br><span class="line">  <span class="attr">_uid</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">_component</span>: <span class="title class_">ConcreteComponent</span>;</span><br><span class="line">  <span class="attr">_props</span>: <span class="title class_">Data</span> | <span class="literal">null</span>;</span><br><span class="line">  <span class="attr">_container</span>: <span class="title class_">HostElement</span> | <span class="literal">null</span>;</span><br><span class="line">  <span class="attr">_context</span>: <span class="title class_">AppContext</span>;</span><br><span class="line">  <span class="attr">_instance</span>: <span class="title class_">ComponentInternalInstance</span> | <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * v2 compat only</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  filter?(<span class="attr">name</span>: <span class="built_in">string</span>): <span class="title class_">Function</span> | <span class="literal">undefined</span>;</span><br><span class="line">  filter?(<span class="attr">name</span>: <span class="built_in">string</span>, <span class="attr">filter</span>: <span class="title class_">Function</span>): <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@internal</span> v3 compat only</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  _createRoot?(<span class="attr">options</span>: <span class="title class_">ComponentOptions</span>): <span class="title class_">ComponentPublicInstance</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-AppConfig"><a href="#2-AppConfig" class="headerlink" title="2. AppConfig"></a>2. <code>AppConfig</code></h3><p>创建的<code>App</code>的配置，包含的内容在<code>vue2</code>里基本都有，重要的例如组件合并策略<code>optionMergeStrategies</code>，<code>Vue</code>全局属性<code>globalProperties</code>(<code>Vue2</code>里直接挂到原型上)、编译器选项<code>compilerOptions</code>、错误与告警处理程序等。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">  <span class="comment">// @private</span></span><br><span class="line">  <span class="keyword">readonly</span> isNativeTag?: <span class="function">(<span class="params">tag: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">boolean</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attr">performance</span>: <span class="built_in">boolean</span>;</span><br><span class="line">  <span class="attr">optionMergeStrategies</span>: <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="title class_">OptionMergeFunction</span>&gt;;</span><br><span class="line">  <span class="attr">globalProperties</span>: <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="built_in">any</span>&gt;;</span><br><span class="line">  errorHandler?: <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    err: <span class="built_in">unknown</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    instance: ComponentPublicInstance | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    info: <span class="built_in">string</span></span></span></span><br><span class="line"><span class="params"><span class="function">  </span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  warnHandler?: <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    msg: <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    instance: ComponentPublicInstance | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    trace: <span class="built_in">string</span></span></span></span><br><span class="line"><span class="params"><span class="function">  </span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Options to pass to `<span class="doctag">@vue</span>/compiler-dom`.</span></span><br><span class="line"><span class="comment">   * Only supported in runtime compiler build.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="attr">compilerOptions</span>: <span class="title class_">RuntimeCompilerOptions</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@deprecated</span> use config.compilerOptions.isCustomElement</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  isCustomElement?: <span class="function">(<span class="params">tag: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">boolean</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Temporary config for opt-in to unwrap injected refs.</span></span><br><span class="line"><span class="comment">   * TODO deprecate in 3.3</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  unwrapInjectedRef?: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-AppContext"><a href="#3-AppContext" class="headerlink" title="3. AppContext"></a>3. <code>AppContext</code></h3><p><code>App</code>的上下文，包含了对于<code>components</code>、<code>directives</code>、<code>mixins</code>、<code>provides</code>、<code>config</code>记录、对于<code>props</code>、<code>emits</code>的缓存、用于热更新的<code>reload</code>方法、兼容<code>vue2</code>的<code>filters</code>记录等。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">AppContext</span> &#123;</span><br><span class="line">  <span class="attr">app</span>: <span class="title class_">App</span>; <span class="comment">// for devtools</span></span><br><span class="line">  <span class="attr">config</span>: <span class="title class_">AppConfig</span>;</span><br><span class="line">  <span class="attr">mixins</span>: <span class="title class_">ComponentOptions</span>[];</span><br><span class="line">  <span class="attr">components</span>: <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="title class_">Component</span>&gt;;</span><br><span class="line">  <span class="attr">directives</span>: <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="title class_">Directive</span>&gt;;</span><br><span class="line">  <span class="attr">provides</span>: <span class="title class_">Record</span>&lt;<span class="built_in">string</span> | <span class="built_in">symbol</span>, <span class="built_in">any</span>&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Cache for merged/normalized component options</span></span><br><span class="line"><span class="comment">   * Each app instance has its own cache because app-level global mixins and</span></span><br><span class="line"><span class="comment">   * optionMergeStrategies can affect merge behavior.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@internal</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="attr">optionsCache</span>: <span class="title class_">WeakMap</span>&lt;<span class="title class_">ComponentOptions</span>, <span class="title class_">MergedComponentOptions</span>&gt;;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Cache for normalized props options</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@internal</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="attr">propsCache</span>: <span class="title class_">WeakMap</span>&lt;<span class="title class_">ConcreteComponent</span>, <span class="title class_">NormalizedPropsOptions</span>&gt;;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Cache for normalized emits options</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@internal</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="attr">emitsCache</span>: <span class="title class_">WeakMap</span>&lt;<span class="title class_">ConcreteComponent</span>, <span class="title class_">ObjectEmitsOptions</span> | <span class="literal">null</span>&gt;;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * HMR only</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@internal</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  reload?: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * v2 compat only</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@internal</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  filters?: <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="title class_">Function</span>&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-Plugin"><a href="#4-Plugin" class="headerlink" title="4. Plugin"></a>4. <code>Plugin</code></h3><p><code>Plugin</code>和<code>Plugin</code>中的<code>install</code>方法，基本和<code>vue2</code>一致。清晰可见，<code>Plugin</code>可以本身就是一个<code>PluginInstallFunction</code>类型函数，也可以是一个包含该类型函数的对象。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">PluginInstallFunction</span> = <span class="function">(<span class="params">app: App, ...options: <span class="built_in">any</span>[]</span>) =&gt;</span> <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">Plugin</span> =</span><br><span class="line">  | (<span class="title class_">PluginInstallFunction</span> &amp; &#123; install?: <span class="title class_">PluginInstallFunction</span> &#125;)</span><br><span class="line">  | &#123;</span><br><span class="line">      <span class="attr">install</span>: <span class="title class_">PluginInstallFunction</span>;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><h3 id="5-CreateAppFunction"><a href="#5-CreateAppFunction" class="headerlink" title="5. CreateAppFunction"></a>5. <code>CreateAppFunction</code></h3><p><code>CreateAppFunction</code>就是我们的<code>createApp</code>函数的类型，接收一个根组件，以及一个可选参数<code>rootProps</code>对根组件进行传参。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">CreateAppFunction</span>&lt;<span class="title class_">HostElement</span>&gt; = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  rootComponent: Component,</span></span></span><br><span class="line"><span class="params"><span class="function">  rootProps?: Data | <span class="literal">null</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> <span class="title class_">App</span>&lt;<span class="title class_">HostElement</span>&gt;;</span><br></pre></td></tr></table></figure><h2 id="二、createApp"><a href="#二、createApp" class="headerlink" title="二、createApp"></a>二、<code>createApp</code></h2><p>从某种程度上可以说，<code>Vue3</code>的一切都是从<code>createApp</code>开始的。<code>createApp</code>这个<code>API</code>定义在<code>packages/runtime-dom/src/index.ts</code>文件里，接下来简要看一看它大致走了哪些流程。</p><h3 id="1-createApp"><a href="#1-createApp" class="headerlink" title="1. createApp"></a>1. <code>createApp</code></h3><ul><li>首先在<code>ensureRenderer</code>中调用<code>createRenderer</code>得到<code>renderer</code>，<code>renderer</code>上有<code>createApp</code>的方法，从而得到<code>app</code>；</li><li>重写<code>app.mount</code>方法，对<code>app._component</code>和<code>container</code>的内容作处理；并且在其中调用原本的<code>mount</code>之前，先对<code>container</code>的内容进行清空。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ensureRenderer</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    renderer ||</span><br><span class="line">    (renderer = createRenderer&lt;<span class="title class_">Node</span>, <span class="title class_">Element</span> | <span class="title class_">ShadowRoot</span>&gt;(rendererOptions))</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createApp = (<span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> app = <span class="title function_">ensureRenderer</span>().<span class="title function_">createApp</span>(...args);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">    <span class="title function_">injectNativeTagCheck</span>(app);</span><br><span class="line">    <span class="title function_">injectCompilerOptionsCheck</span>(app);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; mount &#125; = app;</span><br><span class="line">  app.<span class="property">mount</span> = (<span class="attr">containerOrSelector</span>: <span class="title class_">Element</span> | <span class="title class_">ShadowRoot</span> | <span class="built_in">string</span>): <span class="function"><span class="params">any</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> container = <span class="title function_">normalizeContainer</span>(containerOrSelector);</span><br><span class="line">    <span class="keyword">if</span> (!container) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> component = app.<span class="property">_component</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_">isFunction</span>(component) &amp;&amp; !component.<span class="property">render</span> &amp;&amp; !component.<span class="property">template</span>) &#123;</span><br><span class="line">      <span class="comment">// __UNSAFE__</span></span><br><span class="line">      <span class="comment">// Reason: potential execution of JS expressions in in-DOM template.</span></span><br><span class="line">      <span class="comment">// The user must make sure the in-DOM template is trusted. If it&#x27;s</span></span><br><span class="line">      <span class="comment">// rendered by the server, the template should not contain any user data.</span></span><br><span class="line">      component.<span class="property">template</span> = container.<span class="property">innerHTML</span>;</span><br><span class="line">      <span class="comment">// 2.x compat check</span></span><br><span class="line">      <span class="keyword">if</span> (__COMPAT__ &amp;&amp; __DEV__) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; container.<span class="property">attributes</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">          <span class="keyword">const</span> attr = container.<span class="property">attributes</span>[i];</span><br><span class="line">          <span class="keyword">if</span> (attr.<span class="property">name</span> !== <span class="string">&quot;v-cloak&quot;</span> &amp;&amp; <span class="regexp">/^(v-|:|@)/</span>.<span class="title function_">test</span>(attr.<span class="property">name</span>)) &#123;</span><br><span class="line">            compatUtils.<span class="title function_">warnDeprecation</span>(</span><br><span class="line">              <span class="title class_">DeprecationTypes</span>.<span class="property">GLOBAL_MOUNT_CONTAINER</span>,</span><br><span class="line">              <span class="literal">null</span></span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear content before mounting</span></span><br><span class="line">    container.<span class="property">innerHTML</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> proxy = <span class="title function_">mount</span>(container, <span class="literal">false</span>, container <span class="keyword">instanceof</span> <span class="title class_">SVGElement</span>);</span><br><span class="line">    <span class="keyword">if</span> (container <span class="keyword">instanceof</span> <span class="title class_">Element</span>) &#123;</span><br><span class="line">      container.<span class="title function_">removeAttribute</span>(<span class="string">&quot;v-cloak&quot;</span>);</span><br><span class="line">      container.<span class="title function_">setAttribute</span>(<span class="string">&quot;data-v-app&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> proxy;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> app;</span><br><span class="line">&#125;) <span class="keyword">as</span> <span class="title class_">CreateAppFunction</span>&lt;<span class="title class_">Element</span>&gt;;</span><br></pre></td></tr></table></figure><p>那么这里就会产生疑问，毕竟真正的<code>createApp</code>是在 renderer 上的。而<code>renderer</code>来自<code>createRenderer</code>，那么这个<code>createRenderer</code>又是如何创建<code>renderer</code>的呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">createApp() -&gt; ensureRenderer() -&gt; createRenderer() =&gt; renderer -&gt; renderer.createApp()</span><br></pre></td></tr></table></figure><h3 id="2-createRenderer"><a href="#2-createRenderer" class="headerlink" title="2. createRenderer"></a>2. <code>createRenderer</code></h3><p>我们可以在<code>packages/runtime-core/src/renderer.ts</code>里找到<code>createRenderer</code>的定义。发现是调用了<code>baseCreateRenderer</code>。这个方法就比较长了，加上重载的话有 2000+行，其中包含了<code>patch</code>、<code>move</code>、<code>unmount</code>等许多<code>diff</code>相关的方法，目前就不在这里展开了，只看一下它的返回值，追踪一下我们说的<code>createApp</code>的来源。可以看到，返回的<code>renderer</code>对象上有<code>render</code>，<code>hydrate</code>方法和<code>createApp</code>，<code>hydrate</code>是用于<code>baseCreateRenderer</code>的另一种重载，<code>render</code>方法就非常重要了，而<code>createApp</code>的来源是<code>createAppAPI</code>，这个<code>API</code>定义在<code>packages/runtime-core/src/createAppAPI.ts</code>里。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> createRenderer&lt;</span><br><span class="line">  <span class="title class_">HostNode</span> = <span class="title class_">RendererNode</span>,</span><br><span class="line">  <span class="title class_">HostElement</span> = <span class="title class_">RendererElement</span></span><br><span class="line">&gt;(<span class="attr">options</span>: <span class="title class_">RendererOptions</span>&lt;<span class="title class_">HostNode</span>, <span class="title class_">HostElement</span>&gt;) &#123;</span><br><span class="line">  <span class="keyword">return</span> baseCreateRenderer&lt;<span class="title class_">HostNode</span>, <span class="title class_">HostElement</span>&gt;(options);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// baseCreateRenderer</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">baseCreateRenderer</span>(<span class="params"></span></span><br><span class="line"><span class="params">  options: RendererOptions,</span></span><br><span class="line"><span class="params">  createHydrationFns?: <span class="keyword">typeof</span> createHydrationFunctions</span></span><br><span class="line"><span class="params"></span>): <span class="built_in">any</span> &#123;</span><br><span class="line">  <span class="comment">// 此处省略上万字</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// render方法，虽重要，但不是本文的主角，先露个脸吧</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">render</span>: <span class="title class_">RootRenderFunction</span> = <span class="function">(<span class="params">vnode, container, isSVG</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (vnode == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (container.<span class="property">_vnode</span>) &#123;</span><br><span class="line">        <span class="title function_">unmount</span>(container.<span class="property">_vnode</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">patch</span>(</span><br><span class="line">        container.<span class="property">_vnode</span> || <span class="literal">null</span>,</span><br><span class="line">        vnode,</span><br><span class="line">        container,</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        isSVG</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">flushPostFlushCbs</span>();</span><br><span class="line">    container.<span class="property">_vnode</span> = vnode;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    render,</span><br><span class="line">    hydrate,</span><br><span class="line">    <span class="attr">createApp</span>: <span class="title function_">createAppAPI</span>(render, hydrate),</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-createAppAPI"><a href="#3-createAppAPI" class="headerlink" title="3. createAppAPI"></a>3. <code>createAppAPI</code></h3><p>好家伙，走了这么长个流程，终于轮到主角登场了。在<code>baseCreateRenderer</code>的返回值中，我们可以看到，<code>createApp</code>方法就是以<code>render</code>和<code>hydrate</code>作为入参，提供给<code>createAppAPI</code>，从而诞生的。而这个近<code>200</code>行的函数，直接返回了我们用的<code>createApp</code>这个函数，这下子终于得到了真正的<code>createApp</code>。而逻辑也非常简单清晰：</p><ul><li>创建上下文<code>context</code>；</li><li>声明一个不可重复的插件容器；</li><li>初始化<code>isMounted</code>状态为<code>false</code>；</li><li>创建<code>app</code>并挂到<code>context</code>上，最后返回<code>app</code>。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> createAppAPI&lt;<span class="title class_">HostElement</span>&gt;(</span><br><span class="line">  <span class="attr">render</span>: <span class="title class_">RootRenderFunction</span>,</span><br><span class="line">  hydrate?: <span class="title class_">RootHydrateFunction</span></span><br><span class="line">): <span class="title class_">CreateAppFunction</span>&lt;<span class="title class_">HostElement</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">createApp</span>(<span class="params">rootComponent, rootProps = <span class="literal">null</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_">isFunction</span>(rootComponent)) &#123;</span><br><span class="line">      rootComponent = &#123; ...rootComponent &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rootProps != <span class="literal">null</span> &amp;&amp; !<span class="title function_">isObject</span>(rootProps)) &#123;</span><br><span class="line">      __DEV__ &amp;&amp; <span class="title function_">warn</span>(<span class="string">`root props passed to app.mount() must be an object.`</span>);</span><br><span class="line">      rootProps = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建上下文</span></span><br><span class="line">    <span class="keyword">const</span> context = <span class="title function_">createAppContext</span>();</span><br><span class="line">    <span class="comment">// 插件容器</span></span><br><span class="line">    <span class="keyword">const</span> installedPlugins = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还没进行 mount() 呢，isMounted 自然是 false</span></span><br><span class="line">    <span class="keyword">let</span> isMounted = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 终于创建了app了</span></span><br><span class="line">    <span class="keyword">const</span> <span class="attr">app</span>: <span class="title class_">App</span> = (context.<span class="property">app</span> = &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 考虑兼容的属性</span></span><br><span class="line">    <span class="keyword">if</span> (__COMPAT__) &#123;</span><br><span class="line">      <span class="title function_">installAppCompatProperties</span>(app, context, render);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么重点就是创建的<code>app</code>了，让我们掀开它神秘的面纱。</p><ul><li>配置了一些内部属性；</li><li>利用存取器配置了只读的<code>config</code>属性；</li><li>定义了一些方法，如<code>use</code>、<code>mount</code>、<code>component</code>、<code>directive</code>、<code>mixin</code>、<code>unmount</code>、<code>provide</code>等，这时候回顾一下最开始我们说到的相关<code>ts</code>类型中的<code>App</code>类型，就对应上了。</li><li>其中，<code>component</code>、<code>directive</code>、<code>mixin</code>、<code>provide</code>都是用于定义一些全局可用的东西。这几个方法的逻辑也都一致，把定义的全局的内容添加到上下文<code>context</code>对象的相应字段中。</li><li><code>use</code>：这个应该家喻户晓了，就是使用插件，调用其中的<code>install</code>方法或者插件本身(当插件本身就是一个函数且没有<code>install</code>方法时) 来安装插件，并且用<code>installedPlugins</code>来判断是否已安装；</li><li><code>mount</code>：根据闭包的变量<code>isMounted</code>来判断<code>app</code>是否已经挂载；用根组件<code>rootComponent</code>作为参数，调用<code>createVnode</code>来生成根节点，并将上下文<code>context</code>也保存在<code>vnode.appContext</code>中；执行<code>render</code>函数将<code>vnode</code>渲染到<code>rootContainer</code>中，这一步我们应该很熟，就是替换<code>innerHTML</code>；之后变更<code>isMounted</code>状态为<code>true</code>等；</li><li><code>unmount</code>：同样是执行<code>render</code>函数，只是这次是把<code>null</code>空值渲染到<code>rootContainer</code>中，用空的内容替换之前<code>mount</code>时渲染的内容，从而达到卸载应用的效果。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">app</span>: <span class="title class_">App</span> = (context.<span class="property">app</span> = &#123;</span><br><span class="line">  <span class="attr">_uid</span>: uid++,</span><br><span class="line">  <span class="attr">_component</span>: rootComponent <span class="keyword">as</span> <span class="title class_">ConcreteComponent</span>,</span><br><span class="line">  <span class="attr">_props</span>: rootProps,</span><br><span class="line">  <span class="attr">_container</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">_context</span>: context,</span><br><span class="line">  <span class="attr">_instance</span>: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">  version,</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">config</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> context.<span class="property">config</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">config</span>(<span class="params">v</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      <span class="title function_">warn</span>(</span><br><span class="line">        <span class="string">`app.config cannot be replaced. Modify individual options instead.`</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">use</span>(<span class="params">plugin: Plugin, ...options: <span class="built_in">any</span>[]</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (installedPlugins.<span class="title function_">has</span>(plugin)) &#123;</span><br><span class="line">      __DEV__ &amp;&amp; <span class="title function_">warn</span>(<span class="string">`Plugin has already been applied to target app.`</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (plugin &amp;&amp; <span class="title function_">isFunction</span>(plugin.<span class="property">install</span>)) &#123;</span><br><span class="line">      installedPlugins.<span class="title function_">add</span>(plugin)</span><br><span class="line">      plugin.<span class="title function_">install</span>(app, ...options)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isFunction</span>(plugin)) &#123;</span><br><span class="line">      installedPlugins.<span class="title function_">add</span>(plugin)</span><br><span class="line">      <span class="title function_">plugin</span>(app, ...options)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      <span class="title function_">warn</span>(</span><br><span class="line">        <span class="string">`A plugin must either be a function or an object with an &quot;install&quot; `</span> +</span><br><span class="line">          <span class="string">`function.`</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> app</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">mixin</span>(<span class="params">mixin: ComponentOptions</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__FEATURE_OPTIONS_API__) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!context.<span class="property">mixins</span>.<span class="title function_">includes</span>(mixin)) &#123;</span><br><span class="line">        context.<span class="property">mixins</span>.<span class="title function_">push</span>(mixin)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">&#x27;Mixin has already been applied to target app&#x27;</span> +</span><br><span class="line">            (mixin.<span class="property">name</span> ? <span class="string">`: <span class="subst">$&#123;mixin.name&#125;</span>`</span> : <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      <span class="title function_">warn</span>(<span class="string">&#x27;Mixins are only available in builds supporting Options API&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> app</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">component</span>(<span class="attr">name</span>: <span class="built_in">string</span>, component?: <span class="title class_">Component</span>): <span class="built_in">any</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      <span class="title function_">validateComponentName</span>(name, context.<span class="property">config</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!component) &#123;</span><br><span class="line">      <span class="keyword">return</span> context.<span class="property">components</span>[name]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__ &amp;&amp; context.<span class="property">components</span>[name]) &#123;</span><br><span class="line">      <span class="title function_">warn</span>(<span class="string">`Component &quot;<span class="subst">$&#123;name&#125;</span>&quot; has already been registered in target app.`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    context.<span class="property">components</span>[name] = component</span><br><span class="line">    <span class="keyword">return</span> app</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">directive</span>(<span class="params">name: <span class="built_in">string</span>, directive?: Directive</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      <span class="title function_">validateDirectiveName</span>(name)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!directive) &#123;</span><br><span class="line">      <span class="keyword">return</span> context.<span class="property">directives</span>[name] <span class="keyword">as</span> <span class="built_in">any</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__ &amp;&amp; context.<span class="property">directives</span>[name]) &#123;</span><br><span class="line">      <span class="title function_">warn</span>(<span class="string">`Directive &quot;<span class="subst">$&#123;name&#125;</span>&quot; has already been registered in target app.`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    context.<span class="property">directives</span>[name] = directive</span><br><span class="line">    <span class="keyword">return</span> app</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">mount</span>(</span><br><span class="line">    <span class="attr">rootContainer</span>: <span class="title class_">HostElement</span>,</span><br><span class="line">    isHydrate?: <span class="built_in">boolean</span>,</span><br><span class="line">    isSVG?: <span class="built_in">boolean</span></span><br><span class="line">  ): <span class="built_in">any</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isMounted) &#123;</span><br><span class="line">      <span class="comment">// #5571</span></span><br><span class="line">      <span class="keyword">if</span> (__DEV__ &amp;&amp; (rootContainer <span class="keyword">as</span> <span class="built_in">any</span>).<span class="property">__vue_app__</span>) &#123;</span><br><span class="line">        <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">`There is already an app instance mounted on the host container.\n`</span> +</span><br><span class="line">            <span class="string">` If you want to mount another app on the same host container,`</span> +</span><br><span class="line">            <span class="string">` you need to unmount the previous app by calling `</span>app.<span class="title function_">unmount</span>()<span class="string">` first.`</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> vnode = <span class="title function_">createVNode</span>(</span><br><span class="line">        rootComponent <span class="keyword">as</span> <span class="title class_">ConcreteComponent</span>,</span><br><span class="line">        rootProps</span><br><span class="line">      )</span><br><span class="line">      <span class="comment">// store app context on the root VNode.</span></span><br><span class="line">      <span class="comment">// this will be set on the root instance on initial mount.</span></span><br><span class="line">      vnode.<span class="property">appContext</span> = context</span><br><span class="line"></span><br><span class="line">      <span class="comment">// HMR root reload</span></span><br><span class="line">      <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        context.<span class="property">reload</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">render</span>(<span class="title function_">cloneVNode</span>(vnode), rootContainer, isSVG)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (isHydrate &amp;&amp; hydrate) &#123;</span><br><span class="line">        <span class="title function_">hydrate</span>(vnode <span class="keyword">as</span> <span class="title class_">VNode</span>&lt;<span class="title class_">Node</span>, <span class="title class_">Element</span>&gt;, rootContainer <span class="keyword">as</span> <span class="built_in">any</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">render</span>(vnode, rootContainer, isSVG)</span><br><span class="line">      &#125;</span><br><span class="line">      isMounted = <span class="literal">true</span></span><br><span class="line">      app.<span class="property">_container</span> = rootContainer</span><br><span class="line">      <span class="comment">// for devtools and telemetry</span></span><br><span class="line">      ;(rootContainer <span class="keyword">as</span> <span class="built_in">any</span>).<span class="property">__vue_app__</span> = app</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (__DEV__ || __FEATURE_PROD_DEVTOOLS__) &#123;</span><br><span class="line">        app.<span class="property">_instance</span> = vnode.<span class="property">component</span></span><br><span class="line">        <span class="title function_">devtoolsInitApp</span>(app, version)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">getExposeProxy</span>(vnode.<span class="property">component</span>!) || vnode.<span class="property">component</span>!.<span class="property">proxy</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      <span class="title function_">warn</span>(</span><br><span class="line">        <span class="string">`App has already been mounted.\n`</span> +</span><br><span class="line">          <span class="string">`If you want to remount the same app, move your app creation logic `</span> +</span><br><span class="line">          <span class="string">`into a factory function and create fresh app instances for each `</span> +</span><br><span class="line">          <span class="string">`mount - e.g. `</span><span class="keyword">const</span> <span class="title function_">createMyApp</span> = (<span class="params"></span>) =&gt; <span class="title function_">createApp</span>(<span class="title class_">App</span>)<span class="string">``</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">unmount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isMounted) &#123;</span><br><span class="line">      <span class="title function_">render</span>(<span class="literal">null</span>, app.<span class="property">_container</span>)</span><br><span class="line">      <span class="keyword">if</span> (__DEV__ || __FEATURE_PROD_DEVTOOLS__) &#123;</span><br><span class="line">        app.<span class="property">_instance</span> = <span class="literal">null</span></span><br><span class="line">        <span class="title function_">devtoolsUnmountApp</span>(app)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">delete</span> app.<span class="property">_container</span>.<span class="property">__vue_app__</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      <span class="title function_">warn</span>(<span class="string">`Cannot unmount an app that is not mounted.`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">provide</span>(<span class="params">key, value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__ &amp;&amp; (key <span class="keyword">as</span> <span class="built_in">string</span> | <span class="built_in">symbol</span>) <span class="keyword">in</span> context.<span class="property">provides</span>) &#123;</span><br><span class="line">      <span class="title function_">warn</span>(</span><br><span class="line">        <span class="string">`App already provides property with key &quot;<span class="subst">$&#123;<span class="built_in">String</span>(key)&#125;</span>&quot;. `</span> +</span><br><span class="line">          <span class="string">`It will be overwritten with the new value.`</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    context.<span class="property">provides</span>[key <span class="keyword">as</span> <span class="built_in">string</span> | <span class="built_in">symbol</span>] = value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>createApp</code>流程基本都弄明白了，但是我们并不清楚<code>render</code>的过程是如何进行的。后续会抽时间解读<code>render</code>函数的故事。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前 端 </tag>
            
            <tag> Vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3源码系列 (六) KeepAlive</title>
      <link href="/articals/e80db997/"/>
      <url>/articals/e80db997/</url>
      
        <content type="html"><![CDATA[<p><code>KeepAlive</code>是个抽象组件，自身不会渲染一个 DOM 元素，也不会出现在父组件链中，我们用它来缓存组件的状态。<code>KeepAlive</code>只对插入的单个组件起效果，因此一般只给它安排一个组件。适合与<code>component</code>或<code>router-view</code>搭配使用。</p><h2 id="一、ts-类型"><a href="#一、ts-类型" class="headerlink" title="一、ts 类型"></a>一、<code>ts</code> 类型</h2><p>先来和<code>KeepAlive</code>相关的类型：</p><ul><li><code>MatchPattern</code>：匹配模式，是传递的参数<code>include</code>和<code>exclude</code>接收的类型；</li><li><code>KeepAliveProps</code>：可传递三个参数，<code>include</code>指定被缓存的组件，<code>exclude</code>指定不缓存的组件，<code>max</code>指定最大缓存组件数量；</li><li><code>Cache</code>：变量<code>cache</code>的类型，<code>cache</code>用于缓存组件；</li><li><code>Keys</code>：变量<code>keys</code>的类型，<code>keys</code>用于存储被缓存组件对应的<code>key</code>，用于<code>LRU</code>算法；</li><li><code>KeepAliveContext</code>：继承自<code>ComponentRenderContext</code>，并拓展了<code>renderer</code>，<code>activate</code>，<code>deactivate</code>三个字段。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MatchPattern</span> = <span class="built_in">string</span> | <span class="title class_">RegExp</span> | (<span class="built_in">string</span> | <span class="title class_">RegExp</span>)[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">KeepAliveProps</span> &#123;</span><br><span class="line">  include?: <span class="title class_">MatchPattern</span>;</span><br><span class="line">  exclude?: <span class="title class_">MatchPattern</span>;</span><br><span class="line">  max?: <span class="built_in">number</span> | <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">CacheKey</span> = <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">symbol</span> | <span class="title class_">ConcreteComponent</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Cache</span> = <span class="title class_">Map</span>&lt;<span class="title class_">CacheKey</span>, <span class="title class_">VNode</span>&gt;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Keys</span> = <span class="title class_">Set</span>&lt;<span class="title class_">CacheKey</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">KeepAliveContext</span> <span class="keyword">extends</span> <span class="title class_">ComponentRenderContext</span> &#123;</span><br><span class="line">  <span class="attr">renderer</span>: <span class="title class_">RendererInternals</span>;</span><br><span class="line">  <span class="attr">activate</span>: <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    vnode: VNode,</span></span></span><br><span class="line"><span class="params"><span class="function">    container: RendererElement,</span></span></span><br><span class="line"><span class="params"><span class="function">    anchor: RendererNode | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    isSVG: <span class="built_in">boolean</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    optimized: <span class="built_in">boolean</span></span></span></span><br><span class="line"><span class="params"><span class="function">  </span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  <span class="attr">deactivate</span>: <span class="function">(<span class="params">vnode: VNode</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、KeepAliveImpl"><a href="#二、KeepAliveImpl" class="headerlink" title="二、KeepAliveImpl"></a>二、<code>KeepAliveImpl</code></h2><h3 id="1-KeepAliveImpl-的成员"><a href="#1-KeepAliveImpl-的成员" class="headerlink" title="1. KeepAliveImpl 的成员"></a>1. <code>KeepAliveImpl</code> 的成员</h3><p><code>KeepAliveImpl</code>是<code>KeepAlive</code>的核心实现。包含<code>name</code>，<code>__isKeepAlive</code>（用于判断组件是否是<code>KeepAlive</code>），<code>props</code>（上面提到的<code>KeepAliveProps</code>类型）以及<code>setup</code>方法。<code>KeepAlive</code>与实例化的<code>renderer</code>通过上下文来传递信息。在当前实例的上下文对象<code>ctx</code>上暴露了<code>activate</code>和<code>deactivate</code>两个方法。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">KeepAliveImpl</span>: <span class="title class_">ComponentOptions</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">`KeepAlive`</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Marker for special handling inside the renderer. We are not using a ===</span></span><br><span class="line">  <span class="comment">// check directly on KeepAlive in the renderer, because importing it directly</span></span><br><span class="line">  <span class="comment">// would prevent it from being tree-shaken.</span></span><br><span class="line">  <span class="attr">__isKeepAlive</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">include</span>: [<span class="title class_">String</span>, <span class="title class_">RegExp</span>, <span class="title class_">Array</span>],</span><br><span class="line">    <span class="attr">exclude</span>: [<span class="title class_">String</span>, <span class="title class_">RegExp</span>, <span class="title class_">Array</span>],</span><br><span class="line">    <span class="attr">max</span>: [<span class="title class_">String</span>, <span class="title class_">Number</span>],</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">setup</span>(<span class="params">props: KeepAliveProps, &#123; slots &#125;: SetupContext</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-setup"><a href="#2-setup" class="headerlink" title="2. setup"></a>2. <code>setup</code></h3><p>在<code>setup</code>中，拿到当前实例的上下文对象，并挂上<code>activate</code>和<code>deactivate</code>两个方法。</p><p>在<code>activate</code>中，通过调用<code>patch</code>来进行对比更新，以同步<code>props</code>传参可能的变更；调整组件为激活状态<code>instance.isDeactivated = false</code>；调用实例的<code>onActived</code>钩子等。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title function_">setup</span>(<span class="params">props: KeepAliveProps, &#123; slots &#125;: SetupContext</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> instance = <span class="title function_">getCurrentInstance</span>()!</span><br><span class="line">    <span class="comment">// KeepAlive communicates with the instantiated renderer via the</span></span><br><span class="line">    <span class="comment">// ctx where the renderer passes in its internals,</span></span><br><span class="line">    <span class="comment">// and the KeepAlive instance exposes activate/deactivate implementations.</span></span><br><span class="line">    <span class="comment">// The whole point of this is to avoid importing KeepAlive directly in the</span></span><br><span class="line">    <span class="comment">// renderer to facilitate tree-shaking.</span></span><br><span class="line">    <span class="keyword">const</span> sharedContext = instance.<span class="property">ctx</span> <span class="keyword">as</span> <span class="title class_">KeepAliveContext</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// if the internal renderer is not registered, it indicates that this is server-side rendering,</span></span><br><span class="line">    <span class="comment">// for KeepAlive, we just need to render its children</span></span><br><span class="line">    <span class="keyword">if</span> (__SSR__ &amp;&amp; !sharedContext.<span class="property">renderer</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> children = slots.<span class="property">default</span> &amp;&amp; slots.<span class="title function_">default</span>()</span><br><span class="line">        <span class="keyword">return</span> children &amp;&amp; children.<span class="property">length</span> === <span class="number">1</span> ? children[<span class="number">0</span>] : children</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于缓存组件</span></span><br><span class="line">    <span class="keyword">const</span> <span class="attr">cache</span>: <span class="title class_">Cache</span> = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">    <span class="keyword">const</span> <span class="attr">keys</span>: <span class="title class_">Keys</span> = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">current</span>: <span class="title class_">VNode</span> | <span class="literal">null</span> = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__DEV__ || __FEATURE_PROD_DEVTOOLS__) &#123;</span><br><span class="line">      ;(instance <span class="keyword">as</span> <span class="built_in">any</span>).<span class="property">__v_cache</span> = cache</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> parentSuspense = instance.<span class="property">suspense</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">      <span class="attr">renderer</span>: &#123;</span><br><span class="line">        <span class="attr">p</span>: patch,</span><br><span class="line">        <span class="attr">m</span>: move,</span><br><span class="line">        <span class="attr">um</span>: _unmount,</span><br><span class="line">        <span class="attr">o</span>: &#123; createElement &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; = sharedContext</span><br><span class="line">    <span class="keyword">const</span> storageContainer = <span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    sharedContext.<span class="property">activate</span> = <span class="function">(<span class="params">vnode, container, anchor, isSVG, optimized</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> instance = vnode.<span class="property">component</span>!</span><br><span class="line">      <span class="title function_">move</span>(vnode, container, anchor, <span class="title class_">MoveType</span>.<span class="property">ENTER</span>, parentSuspense)</span><br><span class="line">      <span class="comment">// in case props have changed</span></span><br><span class="line">      <span class="title function_">patch</span>(</span><br><span class="line">        instance.<span class="property">vnode</span>,</span><br><span class="line">        vnode,</span><br><span class="line">        container,</span><br><span class="line">        anchor,</span><br><span class="line">        instance,</span><br><span class="line">        parentSuspense,</span><br><span class="line">        isSVG,</span><br><span class="line">        vnode.<span class="property">slotScopeIds</span>,</span><br><span class="line">        optimized</span><br><span class="line">      )</span><br><span class="line">      <span class="title function_">queuePostRenderEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        instance.<span class="property">isDeactivated</span> = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span> (instance.<span class="property">a</span>) &#123;</span><br><span class="line">          <span class="title function_">invokeArrayFns</span>(instance.<span class="property">a</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> vnodeHook = vnode.<span class="property">props</span> &amp;&amp; vnode.<span class="property">props</span>.<span class="property">onVnodeMounted</span></span><br><span class="line">        <span class="keyword">if</span> (vnodeHook) &#123;</span><br><span class="line">          <span class="title function_">invokeVNodeHook</span>(vnodeHook, instance.<span class="property">parent</span>, vnode)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, parentSuspense)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (__DEV__ || __FEATURE_PROD_DEVTOOLS__) &#123;</span><br><span class="line">        <span class="comment">// Update components tree</span></span><br><span class="line">        <span class="title function_">devtoolsComponentAdded</span>(instance)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>deactivate</code>中的操作类似。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    sharedContext.<span class="property">deactivate</span> = <span class="function">(<span class="params">vnode: VNode</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> instance = vnode.<span class="property">component</span>!</span><br><span class="line">      <span class="title function_">move</span>(vnode, storageContainer, <span class="literal">null</span>, <span class="title class_">MoveType</span>.<span class="property">LEAVE</span>, parentSuspense)</span><br><span class="line">      <span class="title function_">queuePostRenderEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance.<span class="property">da</span>) &#123;</span><br><span class="line">          <span class="title function_">invokeArrayFns</span>(instance.<span class="property">da</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> vnodeHook = vnode.<span class="property">props</span> &amp;&amp; vnode.<span class="property">props</span>.<span class="property">onVnodeUnmounted</span></span><br><span class="line">        <span class="keyword">if</span> (vnodeHook) &#123;</span><br><span class="line">          <span class="title function_">invokeVNodeHook</span>(vnodeHook, instance.<span class="property">parent</span>, vnode)</span><br><span class="line">        &#125;</span><br><span class="line">        instance.<span class="property">isDeactivated</span> = <span class="literal">true</span></span><br><span class="line">      &#125;, parentSuspense)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (__DEV__ || __FEATURE_PROD_DEVTOOLS__) &#123;</span><br><span class="line">        <span class="comment">// Update components tree</span></span><br><span class="line">        <span class="title function_">devtoolsComponentAdded</span>(instance)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随之声明了组件卸载以及销毁缓存的方法。基本都用在<code>setup</code>返回的函数里。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 组件卸载</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">unmount</span>(<span class="params">vnode: VNode</span>) &#123;</span><br><span class="line">      <span class="comment">// reset the shapeFlag so it can be properly unmounted</span></span><br><span class="line">      <span class="title function_">resetShapeFlag</span>(vnode)</span><br><span class="line">      <span class="title function_">_unmount</span>(vnode, instance, parentSuspense, <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据组件名 和 filter 销毁缓存</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">pruneCache</span>(<span class="params">filter?: (name: <span class="built_in">string</span>) =&gt; <span class="built_in">boolean</span></span>) &#123;</span><br><span class="line">      cache.<span class="title function_">forEach</span>(<span class="function">(<span class="params">vnode, key</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> name = <span class="title function_">getComponentName</span>(vnode.<span class="property">type</span> <span class="keyword">as</span> <span class="title class_">ConcreteComponent</span>)</span><br><span class="line">        <span class="keyword">if</span> (name &amp;&amp; (!filter || !<span class="title function_">filter</span>(name))) &#123;</span><br><span class="line">          <span class="title function_">pruneCacheEntry</span>(key)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">pruneCacheEntry</span>(<span class="params">key: CacheKey</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> cached = cache.<span class="title function_">get</span>(key) <span class="keyword">as</span> <span class="title class_">VNode</span></span><br><span class="line">      <span class="keyword">if</span> (!current || cached.<span class="property">type</span> !== current.<span class="property">type</span>) &#123;</span><br><span class="line">        <span class="title function_">unmount</span>(cached)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current) &#123;</span><br><span class="line">        <span class="comment">// current active instance should no longer be kept-alive.</span></span><br><span class="line">        <span class="comment">// we can&#x27;t unmount it now but it might be later, so reset its flag now.</span></span><br><span class="line">        <span class="title function_">resetShapeFlag</span>(current)</span><br><span class="line">      &#125;</span><br><span class="line">      cache.<span class="title function_">delete</span>(key)</span><br><span class="line">      keys.<span class="title function_">delete</span>(key)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>watch API</code>侦听<code>include</code>、<code>exclude</code>的变化，一旦改变，根据<code>match</code>函数得到的<code>filter</code>去销毁相应的缓存。<code>match</code>函数根据<code>include</code>、<code>exclude</code>匹配模式来筛选出需要被销毁的缓存。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"> props </span>)&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// prune cache on include/exclude prop change</span></span><br><span class="line">    <span class="title function_">watch</span>(</span><br><span class="line">      <span class="function">() =&gt;</span> [props.<span class="property">include</span>, props.<span class="property">exclude</span>],</span><br><span class="line">      <span class="function">(<span class="params">[include, exclude]</span>) =&gt;</span> &#123;</span><br><span class="line">        include &amp;&amp; <span class="title function_">pruneCache</span>(<span class="function"><span class="params">name</span> =&gt;</span> <span class="title function_">matches</span>(include, name))</span><br><span class="line">        exclude &amp;&amp; <span class="title function_">pruneCache</span>(<span class="function"><span class="params">name</span> =&gt;</span> !<span class="title function_">matches</span>(exclude, name))</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// prune post-render after `current` has been updated</span></span><br><span class="line">      &#123; <span class="attr">flush</span>: <span class="string">&#x27;post&#x27;</span>, <span class="attr">deep</span>: <span class="literal">true</span> &#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// match</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">matches</span>(<span class="params">pattern: MatchPattern, name: <span class="built_in">string</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isArray</span>(pattern)) &#123;</span><br><span class="line">    <span class="keyword">return</span> pattern.<span class="title function_">some</span>(<span class="function">(<span class="params">p: <span class="built_in">string</span> | <span class="built_in">RegExp</span></span>) =&gt;</span> <span class="title function_">matches</span>(p, name))</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isString</span>(pattern)) &#123;</span><br><span class="line">    <span class="keyword">return</span> pattern.<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>).<span class="title function_">includes</span>(name)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pattern.<span class="property">test</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> pattern.<span class="title function_">test</span>(name)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* istanbul ignore next */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来给<code>onMounted</code>和<code>onUpdated</code>和<code>onBeforeUnmount</code>安排任务。在挂载和更新时执行<code>cacheSubtree</code>来缓存子组件树，<strong>卸载前调用其中的组件的<code>onDeactived</code>钩子</strong>，再卸载组件。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// cache sub tree after render</span></span><br><span class="line">    <span class="keyword">let</span> <span class="attr">pendingCacheKey</span>: <span class="title class_">CacheKey</span> | <span class="literal">null</span> = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">cacheSubtree</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      <span class="comment">// fix #1621, the pendingCacheKey could be 0</span></span><br><span class="line">      <span class="keyword">if</span> (pendingCacheKey != <span class="literal">null</span>) &#123;</span><br><span class="line">        cache.<span class="title function_">set</span>(pendingCacheKey, <span class="title function_">getInnerChild</span>(instance.<span class="property">subTree</span>))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">onMounted</span>(cacheSubtree)</span><br><span class="line">    <span class="title function_">onUpdated</span>(cacheSubtree)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 卸载前，在其中调用组件的 onDeactived 钩子</span></span><br><span class="line">    <span class="title function_">onBeforeUnmount</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      cache.<span class="title function_">forEach</span>(<span class="function"><span class="params">cached</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; subTree, suspense &#125; = instance</span><br><span class="line">        <span class="keyword">const</span> vnode = <span class="title function_">getInnerChild</span>(subTree)</span><br><span class="line">        <span class="keyword">if</span> (cached.<span class="property">type</span> === vnode.<span class="property">type</span>) &#123;</span><br><span class="line">          <span class="comment">// current instance will be unmounted as part of keep-alive&#x27;s unmount</span></span><br><span class="line">          <span class="title function_">resetShapeFlag</span>(vnode)</span><br><span class="line">          <span class="comment">// but invoke its deactivated hook here</span></span><br><span class="line">          <span class="keyword">const</span> da = vnode.<span class="property">component</span>!.<span class="property">da</span></span><br><span class="line">          da &amp;&amp; <span class="title function_">queuePostRenderEffect</span>(da, suspense)</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">unmount</span>(cached)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是<code>KeepAlive</code>的<code>setup</code>的返回值的部分了，这里<code>setup</code>返回一个函数。可以看到<code>KeepAlive</code>只对插入单个组件有效果，即<code>rawVNode = $slots.default()[0]</code>。根据<code>rawVNode</code>获取到<code>vnode</code>：<code>let vnode = getInnerChild(rawVNode)</code>。</p><p>以下各项条件会直接返回该组件，且无法进入缓存流程。</p><ul><li>默认插槽有多个组件，即<code>slots.default()</code>的长度大于<code>1</code>，则直接返回<code>$slots.default()</code>；</li><li><code>rawVNode</code>不属于<code>VNode</code>类型，直接返回<code>rawVNode</code>；</li><li><code>rawVNode</code>的形状标志被重置了，发生在当前组件是缓存组件且处于卸载流程时；</li></ul><p>此外，当<code>rawVNode</code>是异步组件时，也会返回<code>rawVNode</code>，但是缓存程序会执行。</p><p>而当<code>rawVNode</code>未被直接返回，且不是异步组件时：</p><ul><li>如果已有缓存，则取缓存的值更新到<code>vnode</code>里，更新<code>key</code>的位置(<code>LRU</code>算法)，最后返回<code>vnode</code>；</li><li>没有缓存的值，则进行缓存，并返回<code>vnode</code>。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">() =&gt; &#123;</span><br><span class="line">  pendingCacheKey = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!slots.<span class="property">default</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取默认插槽中的第一个组件</span></span><br><span class="line">  <span class="keyword">const</span> children = slots.<span class="title function_">default</span>();</span><br><span class="line">  <span class="keyword">const</span> rawVNode = children[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果默认插槽中有多个组件，则直接返回它们，导致无法进入缓存流程</span></span><br><span class="line">  <span class="keyword">if</span> (children.<span class="property">length</span> &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      <span class="title function_">warn</span>(<span class="string">`KeepAlive should contain exactly one component child.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    current = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回这些组件</span></span><br><span class="line">    <span class="keyword">return</span> children;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">    <span class="comment">// 不是vnode，或者没有缓存标志了，直接返回，不进入缓存流程</span></span><br><span class="line">    !<span class="title function_">isVNode</span>(rawVNode) ||</span><br><span class="line">    (!(rawVNode.<span class="property">shapeFlag</span> &amp; <span class="title class_">ShapeFlags</span>.<span class="property">STATEFUL_COMPONENT</span>) &amp;&amp;</span><br><span class="line">      !(rawVNode.<span class="property">shapeFlag</span> &amp; <span class="title class_">ShapeFlags</span>.<span class="property">SUSPENSE</span>))</span><br><span class="line">  ) &#123;</span><br><span class="line">    current = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> rawVNode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> vnode = <span class="title function_">getInnerChild</span>(rawVNode);</span><br><span class="line">  <span class="comment">/** 把 getInnerChild 函数搬到这里方便阅读</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   *   function getInnerChild(vnode: VNode) &#123;</span></span><br><span class="line"><span class="comment">   *     return vnode.shapeFlag &amp; ShapeFlags.SUSPENSE ? vnode.ssContent! : vnode</span></span><br><span class="line"><span class="comment">   *   &#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">const</span> comp = vnode.<span class="property">type</span> <span class="keyword">as</span> <span class="title class_">ConcreteComponent</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// for async components, name check should be based in its loaded</span></span><br><span class="line">  <span class="comment">// inner component if available</span></span><br><span class="line">  <span class="keyword">const</span> name = <span class="title function_">getComponentName</span>(</span><br><span class="line">    <span class="title function_">isAsyncWrapper</span>(vnode)</span><br><span class="line">      ? (vnode.<span class="property">type</span> <span class="keyword">as</span> <span class="title class_">ComponentOptions</span>).<span class="property">__asyncResolved</span> || &#123;&#125;</span><br><span class="line">      : comp</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; include, exclude, max &#125; = props;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据 匹配模式 和 组件名 校验</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    (include &amp;&amp; (!name || !<span class="title function_">matches</span>(include, name))) ||</span><br><span class="line">    (exclude &amp;&amp; name &amp;&amp; <span class="title function_">matches</span>(exclude, name))</span><br><span class="line">  ) &#123;</span><br><span class="line">    current = vnode;</span><br><span class="line">    <span class="keyword">return</span> rawVNode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取缓存的值</span></span><br><span class="line">  <span class="keyword">const</span> key = vnode.<span class="property">key</span> == <span class="literal">null</span> ? comp : vnode.<span class="property">key</span>;</span><br><span class="line">  <span class="keyword">const</span> cachedVNode = cache.<span class="title function_">get</span>(key);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// clone vnode if it&#x27;s reused because we are going to mutate it</span></span><br><span class="line">  <span class="keyword">if</span> (vnode.<span class="property">el</span>) &#123;</span><br><span class="line">    vnode = <span class="title function_">cloneVNode</span>(vnode);</span><br><span class="line">    <span class="keyword">if</span> (rawVNode.<span class="property">shapeFlag</span> &amp; <span class="title class_">ShapeFlags</span>.<span class="property">SUSPENSE</span>) &#123;</span><br><span class="line">      rawVNode.<span class="property">ssContent</span> = vnode;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// #1513 it&#x27;s possible for the returned vnode to be cloned due to attr</span></span><br><span class="line">  <span class="comment">// fallthrough or scopeId, so the vnode here may not be the final vnode</span></span><br><span class="line">  <span class="comment">// that is mounted. Instead of caching it directly, we store the pending</span></span><br><span class="line">  <span class="comment">// key and cache `instance.subTree` (the normalized vnode) in</span></span><br><span class="line">  <span class="comment">// beforeMount/beforeUpdate hooks.</span></span><br><span class="line">  pendingCacheKey = key;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存在缓存的值，就</span></span><br><span class="line">  <span class="keyword">if</span> (cachedVNode) &#123;</span><br><span class="line">    <span class="comment">// copy over mounted state</span></span><br><span class="line">    vnode.<span class="property">el</span> = cachedVNode.<span class="property">el</span>;</span><br><span class="line">    vnode.<span class="property">component</span> = cachedVNode.<span class="property">component</span>;</span><br><span class="line">    <span class="keyword">if</span> (vnode.<span class="property">transition</span>) &#123;</span><br><span class="line">      <span class="comment">// recursively update transition hooks on subTree</span></span><br><span class="line">      <span class="title function_">setTransitionHooks</span>(vnode, vnode.<span class="property">transition</span>!);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// avoid vnode being mounted as fresh</span></span><br><span class="line">    vnode.<span class="property">shapeFlag</span> |= <span class="title class_">ShapeFlags</span>.<span class="property">COMPONENT_KEPT_ALIVE</span>;</span><br><span class="line">    <span class="comment">// make this key the freshest</span></span><br><span class="line">    keys.<span class="title function_">delete</span>(key);</span><br><span class="line">    keys.<span class="title function_">add</span>(key);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 限制最大缓存数量</span></span><br><span class="line">    keys.<span class="title function_">add</span>(key);</span><br><span class="line">    <span class="comment">// prune oldest entry</span></span><br><span class="line">    <span class="keyword">if</span> (max &amp;&amp; keys.<span class="property">size</span> &gt; <span class="built_in">parseInt</span>(max <span class="keyword">as</span> <span class="built_in">string</span>, <span class="number">10</span>)) &#123;</span><br><span class="line">      <span class="title function_">pruneCacheEntry</span>(keys.<span class="title function_">values</span>().<span class="title function_">next</span>().<span class="property">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// avoid vnode being unmounted</span></span><br><span class="line">  vnode.<span class="property">shapeFlag</span> |= <span class="title class_">ShapeFlags</span>.<span class="property">COMPONENT_SHOULD_KEEP_ALIVE</span>;</span><br><span class="line"></span><br><span class="line">  current = vnode;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">isSuspense</span>(rawVNode.<span class="property">type</span>) ? rawVNode : vnode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="三、KeepAlive"><a href="#三、KeepAlive" class="headerlink" title="三、KeepAlive"></a>三、<code>KeepAlive</code></h2><p><code>KeepAlive</code>就是<code>KeepAliveImpl</code>，重新声明了类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/ <span class="keyword">export</span> the <span class="keyword">public</span> <span class="keyword">type</span> <span class="keyword">for</span> h/tsx inference</span><br><span class="line"><span class="comment">// also to avoid inline import() in generated d.ts files</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">KeepAlive</span> = <span class="title class_">KeepAliveImpl</span> <span class="keyword">as</span> <span class="built_in">any</span> <span class="keyword">as</span> &#123;</span><br><span class="line">  <span class="attr">__isKeepAlive</span>: <span class="literal">true</span></span><br><span class="line">  <span class="keyword">new</span> (): &#123;</span><br><span class="line">    <span class="attr">$props</span>: <span class="title class_">VNodeProps</span> &amp; <span class="title class_">KeepAliveProps</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、onActived-和-onDeactived"><a href="#四、onActived-和-onDeactived" class="headerlink" title="四、onActived 和 onDeactived"></a>四、<code>onActived</code> 和 <code>onDeactived</code></h2><p>这两个生命周期钩子通过<code>registerKeepAliveHook</code>来注册。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">onActivated</span>(<span class="params"></span></span><br><span class="line"><span class="params">  hook: <span class="built_in">Function</span>,</span></span><br><span class="line"><span class="params">  target?: ComponentInternalInstance | <span class="literal">null</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">registerKeepAliveHook</span>(hook, <span class="title class_">LifecycleHooks</span>.<span class="property">ACTIVATED</span>, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">onDeactivated</span>(<span class="params"></span></span><br><span class="line"><span class="params">  hook: <span class="built_in">Function</span>,</span></span><br><span class="line"><span class="params">  target?: ComponentInternalInstance | <span class="literal">null</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">registerKeepAliveHook</span>(hook, <span class="title class_">LifecycleHooks</span>.<span class="property">DEACTIVATED</span>, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>registerKeepAliveHook</code>把<code>hook</code>包装成<code>wrappedHook</code>并注入钩子。此外，通过<code>injectToKeepAliveRoot</code>把包装的钩子<code>wrappedHook</code>注入到<code>KeepAlive</code>里相应的钩子列表的前面（<code>unshift</code>方法），之后可以不用再去递归遍历整个组件树了查找相应组件的<code>onActived</code>或<code>onDeactived</code>钩子了，只需要遍历调用<code>KeepAlive</code>中的钩子列表，当然，需要注意在组件卸载时移除相应的钩子。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">registerKeepAliveHook</span>(<span class="params"></span></span><br><span class="line"><span class="params">  hook: <span class="built_in">Function</span> &amp; &#123; __wdc?: <span class="built_in">Function</span> &#125;,</span></span><br><span class="line"><span class="params">  <span class="keyword">type</span>: LifecycleHooks,</span></span><br><span class="line"><span class="params">  target: ComponentInternalInstance | <span class="literal">null</span> = currentInstance</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// cache the deactivate branch check wrapper for injected hooks so the same</span></span><br><span class="line">  <span class="comment">// hook can be properly deduped by the scheduler. &quot;__wdc&quot; stands for &quot;with</span></span><br><span class="line">  <span class="comment">// deactivation check&quot;.</span></span><br><span class="line">  <span class="keyword">const</span> wrappedHook =</span><br><span class="line">    hook.<span class="property">__wdc</span> ||</span><br><span class="line">    (hook.<span class="property">__wdc</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// only fire the hook if the target instance is NOT in a deactivated branch.</span></span><br><span class="line">      <span class="keyword">let</span> <span class="attr">current</span>: <span class="title class_">ComponentInternalInstance</span> | <span class="literal">null</span> = target;</span><br><span class="line">      <span class="keyword">while</span> (current) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current.<span class="property">isDeactivated</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        current = current.<span class="property">parent</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">hook</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="title function_">injectHook</span>(<span class="keyword">type</span>, wrappedHook, target);</span><br><span class="line">  <span class="comment">// In addition to registering it on the target instance, we walk up the parent</span></span><br><span class="line">  <span class="comment">// chain and register it on all ancestor instances that are keep-alive roots.</span></span><br><span class="line">  <span class="comment">// This avoids the need to walk the entire component tree when invoking these</span></span><br><span class="line">  <span class="comment">// hooks, and more importantly, avoids the need to track child components in</span></span><br><span class="line">  <span class="comment">// arrays.</span></span><br><span class="line">  <span class="keyword">if</span> (target) &#123;</span><br><span class="line">    <span class="keyword">let</span> current = target.<span class="property">parent</span>;</span><br><span class="line">    <span class="keyword">while</span> (current &amp;&amp; current.<span class="property">parent</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isKeepAlive</span>(current.<span class="property">parent</span>.<span class="property">vnode</span>)) &#123;</span><br><span class="line">        <span class="title function_">injectToKeepAliveRoot</span>(wrappedHook, <span class="keyword">type</span>, target, current);</span><br><span class="line">      &#125;</span><br><span class="line">      current = current.<span class="property">parent</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// injectHook(type, hook, keepAliveRoot, true /* prepend */)</span></span><br><span class="line"><span class="comment">// true 表示把 hook 放到 keepAliveRoot[type] 对应的钩子列表的前面，即使用 unshift() 方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">injectToKeepAliveRoot</span>(<span class="params"></span></span><br><span class="line"><span class="params">  hook: <span class="built_in">Function</span> &amp; &#123; __weh?: <span class="built_in">Function</span> &#125;,</span></span><br><span class="line"><span class="params">  <span class="keyword">type</span>: LifecycleHooks,</span></span><br><span class="line"><span class="params">  target: ComponentInternalInstance,</span></span><br><span class="line"><span class="params">  keepAliveRoot: ComponentInternalInstance</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// injectHook wraps the original for error handling, so make sure to remove</span></span><br><span class="line">  <span class="comment">// the wrapped version.</span></span><br><span class="line">  <span class="keyword">const</span> injected = <span class="title function_">injectHook</span>(<span class="keyword">type</span>, hook, keepAliveRoot, <span class="literal">true</span> <span class="comment">/* prepend */</span>);</span><br><span class="line">  <span class="comment">// 卸载时移除</span></span><br><span class="line">  <span class="title function_">onUnmounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">remove</span>(keepAliveRoot[<span class="keyword">type</span>]!, injected);</span><br><span class="line">  &#125;, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前 端 </tag>
            
            <tag> Vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3源码系列 (五) effect和ReactiveEffect 、 track 与 trigger</title>
      <link href="/articals/9baf97c7/"/>
      <url>/articals/9baf97c7/</url>
      
        <content type="html"><![CDATA[<p>前面几篇文章里，介绍几个<code>API</code>的时候，我们发现里面常出现<code>effect</code>、<code>track</code>和<code>trigger</code>，虽然简单说了下<code>track</code>用于依赖收集，<code>trigger</code>来触发更新。但是毕竟没看到具体实现，心里没底。如今便可以一探究竟。</p><h2 id="一、ReactiveEffect"><a href="#一、ReactiveEffect" class="headerlink" title="一、ReactiveEffect"></a>一、<code>ReactiveEffect</code></h2><h3 id="1-相关的全局变量"><a href="#1-相关的全局变量" class="headerlink" title="1. 相关的全局变量"></a>1. 相关的全局变量</h3><p>之前提到的<code>effect</code>，便是<code>ReactiveEffect</code>的实例。用到了一些重要的全局变量。</p><ul><li><code>targetMap</code>：弱映射，以目标对象<code>target</code>为<code>key</code>，其收集到的依赖集<code>depsMap</code>为值，因此通过目标对象<code>target</code>可以获取到对应的所有依赖；</li><li><code>activeEffect</code>：当前活跃的<code>effect</code>，随后会被收集起来；</li><li><code>shouldTrack</code>：用作暂停和恢复依赖收集的标志；</li><li><code>trackStack</code>：历史<code>shouldTrack</code>的记录栈。</li></ul><p><code>targetMap</code>对比<code>reactive</code>篇章中提到的<code>proxyMap</code>：</p><ul><li>两者都是弱映射；</li><li>都以目标对象<code>target</code>为<code>key</code>；</li><li><code>targetMap</code>全局只有一个；而<code>proxyMap</code>有四种，分别对应<code>reactive</code>、<code>shallowReactive</code>、<code>readonly</code>、<code>shallowReadonly</code>；</li><li>一个<code>target</code>在一种<code>proxyMap</code>中最多只有一个对应的代理<code>proxy</code>，因此<code>proxyMap</code>的值为单个的<code>proxy</code>对象；</li><li>一个<code>target</code>可以由很多的依赖<code>dep</code>，因此<code>targetMap</code>的值为数据集<code>Map</code>。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> targetMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>&lt;<span class="built_in">any</span>, <span class="title class_">KeyToDepMap</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> <span class="attr">activeEffect</span>: <span class="title class_">ReactiveEffect</span> | <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> shouldTrack = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">trackStack</span>: <span class="built_in">boolean</span>[] = [];</span><br></pre></td></tr></table></figure><p>以及控制暂停、恢复依赖收集的函数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暂停收集</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">pauseTracking</span>(<span class="params"></span>) &#123;</span><br><span class="line">  trackStack.<span class="title function_">push</span>(shouldTrack);</span><br><span class="line">  shouldTrack = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 恢复收集</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">enableTracking</span>(<span class="params"></span>) &#123;</span><br><span class="line">  trackStack.<span class="title function_">push</span>(shouldTrack);</span><br><span class="line">  shouldTrack = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置为上一次的状态</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">resetTracking</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> last = trackStack.<span class="title function_">pop</span>();</span><br><span class="line">  shouldTrack = last === <span class="literal">undefined</span> ? <span class="literal">true</span> : last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-class-声明"><a href="#2-class-声明" class="headerlink" title="2. class 声明"></a>2. <code>class</code> 声明</h3><p>在构造器中初始化<code>fn</code> ( 执行<code>run()</code>的过程中调用 ) 、调度器<code>scheduler</code>，并通过<code>recordEffectScope</code>来记录实例的作用域；声明一些实例属性，以及<code>run</code>、<code>stop</code>两个方法：</p><ul><li><code>active</code>：<code>boolean</code>类型，表示当前的<code>effect</code>是否起作用；</li><li><code>deps</code>：当前<code>effect</code>的依赖；</li><li><code>parent</code>：指向上一个活跃的<code>effect</code>，形成链表；</li><li><code>computed</code>：可选，在<code>computed</code>函数得到的<code>ComputedRefImpl</code>里的<code>effect</code>具有这个属性；</li><li><code>allowRecurse</code>，可选，表示是否允许自调用；</li><li><code>deferStop</code>：私有，可选，表示<code>stop()</code>是否延迟执行；</li><li><code>onStop</code>：可选，函数，在执行<code>stop()</code>时会调用<code>onStop</code>；</li><li><code>onTrack</code></li><li><code>onTrigger</code>：这两个<code>listener</code>为调试用，分别在依赖收集和响应式更新时触发；</li><li><strong>run</strong>：<code>effect</code>最核心的方法。</li><li><strong><code>stop</code></strong>：调用<code>cleanupEffect</code>让<code>effect</code>停止起作用，如果是<code>stop</code>当前活跃的<code>effect</code>，也就是自己停止自己，则会将<code>deferStop</code>调为<code>true</code>，从而延迟停止的时机；触发<code>onStop</code>；将<code>active</code>调为<code>false</code>。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">ReactiveEffect</span>&lt;T = <span class="built_in">any</span>&gt; &#123;</span><br><span class="line">  active = <span class="literal">true</span>;</span><br><span class="line">  <span class="attr">deps</span>: <span class="title class_">Dep</span>[] = [];</span><br><span class="line">  <span class="attr">parent</span>: <span class="title class_">ReactiveEffect</span> | <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Can be attached after creation</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@internal</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  computed?: <span class="title class_">ComputedRefImpl</span>&lt;T&gt;;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@internal</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  allowRecurse?: <span class="built_in">boolean</span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@internal</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> deferStop?: <span class="built_in">boolean</span>;</span><br><span class="line"></span><br><span class="line">  onStop?: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  <span class="comment">// dev only</span></span><br><span class="line">  onTrack?: <span class="function">(<span class="params">event: DebuggerEvent</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  <span class="comment">// dev only</span></span><br><span class="line">  onTrigger?: <span class="function">(<span class="params">event: DebuggerEvent</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="keyword">public</span> fn: () =&gt; T,</span></span><br><span class="line"><span class="params">    <span class="keyword">public</span> scheduler: EffectScheduler | <span class="literal">null</span> = <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">    scope?: EffectScope</span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="title function_">recordEffectScope</span>(<span class="variable language_">this</span>, scope);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">run</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">active</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">fn</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前活跃的effect</span></span><br><span class="line">    <span class="keyword">let</span> <span class="attr">parent</span>: <span class="title class_">ReactiveEffect</span> | <span class="literal">undefined</span> = activeEffect;</span><br><span class="line">    <span class="keyword">let</span> lastShouldTrack = shouldTrack;</span><br><span class="line">    <span class="comment">// 如果当前活跃的effect就是这个effect本身，则直接返回</span></span><br><span class="line">    <span class="keyword">while</span> (parent) &#123;</span><br><span class="line">      <span class="keyword">if</span> (parent === <span class="variable language_">this</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      parent = parent.<span class="property">parent</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 依次活跃的effect形成链表，由parent属性连接</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">parent</span> = activeEffect;</span><br><span class="line">      activeEffect = <span class="variable language_">this</span>;</span><br><span class="line">      shouldTrack = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">      trackOpBit = <span class="number">1</span> &lt;&lt; ++effectTrackDepth;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (effectTrackDepth &lt;= maxMarkerBits) &#123;</span><br><span class="line">        <span class="comment">// 遍历 this.deps 将其中的effect设置为已捕获 tracked</span></span><br><span class="line">        <span class="title function_">initDepMarkers</span>(<span class="variable language_">this</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 层级溢出则清除当前副作用</span></span><br><span class="line">        <span class="title function_">cleanupEffect</span>(<span class="variable language_">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 尾调用传入的fn</span></span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">fn</span>();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 因为前面有return，因此当 try 的代码块发生异常时执行</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (effectTrackDepth &lt;= maxMarkerBits) &#123;</span><br><span class="line">        <span class="comment">// 该方法遍历 this.deps，将其中过气的effect删除，未捕获的effect加入</span></span><br><span class="line">        <span class="comment">// effect 就是其中的 dep</span></span><br><span class="line">        <span class="title function_">finalizeDepMarkers</span>(<span class="variable language_">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      trackOpBit = <span class="number">1</span> &lt;&lt; --effectTrackDepth;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 复原一些状态</span></span><br><span class="line">      activeEffect = <span class="variable language_">this</span>.<span class="property">parent</span>;</span><br><span class="line">      shouldTrack = lastShouldTrack;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">parent</span> = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 若设置了延迟停止，则执行stop，进行延迟清理</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">deferStop</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">stop</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 清除副作用</span></span><br><span class="line">  <span class="title function_">stop</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// stopped while running itself - defer the cleanup</span></span><br><span class="line">    <span class="keyword">if</span> (activeEffect === <span class="variable language_">this</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">deferStop</span> = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">active</span>) &#123;</span><br><span class="line">      <span class="title function_">cleanupEffect</span>(<span class="variable language_">this</span>);</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">onStop</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">onStop</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">active</span> = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-cleanupEffect"><a href="#3-cleanupEffect" class="headerlink" title="3. cleanupEffect"></a>3. <code>cleanupEffect</code></h3><p><code>cleanupEffect</code>用于清除副作用。接收一个<code>effect</code>，遍历<code>effect.deps</code>，并逐个删除副作用<code>effect</code>。随后清空<code>effect.deps</code>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">cleanupEffect</span>(<span class="params">effect: ReactiveEffect</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; deps &#125; = effect;</span><br><span class="line">  <span class="keyword">if</span> (deps.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; deps.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      deps[i].<span class="title function_">delete</span>(effect);</span><br><span class="line">    &#125;</span><br><span class="line">    deps.<span class="property">length</span> = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、effect-函数"><a href="#二、effect-函数" class="headerlink" title="二、effect 函数"></a>二、<code>effect</code> 函数</h2><h3 id="1-相关ts类型"><a href="#1-相关ts类型" class="headerlink" title="1. 相关ts类型"></a>1. 相关<code>ts</code>类型</h3><p><code>effect</code>函数有几个相关的类型：</p><ul><li><code>ReactiveEffectOptions</code>：<code>effect</code>函数的入参类型之一；</li><li><code>ReactiveEffectRunner</code>：是一个函数，且具有<code>effect</code>属性的类型；</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">DebuggerOptions</span> &#123;</span><br><span class="line">  onTrack?: <span class="function">(<span class="params">event: DebuggerEvent</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  onTrigger?: <span class="function">(<span class="params">event: DebuggerEvent</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">ReactiveEffectOptions</span> <span class="keyword">extends</span> <span class="title class_">DebuggerOptions</span> &#123;</span><br><span class="line">  lazy?: <span class="built_in">boolean</span>;</span><br><span class="line">  scheduler?: <span class="title class_">EffectScheduler</span>;</span><br><span class="line">  scope?: <span class="title class_">EffectScope</span>;</span><br><span class="line">  allowRecurse?: <span class="built_in">boolean</span>;</span><br><span class="line">  onStop?: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">ReactiveEffectRunner</span>&lt;T = <span class="built_in">any</span>&gt; &#123;</span><br><span class="line">  (): T;</span><br><span class="line">  <span class="attr">effect</span>: <span class="title class_">ReactiveEffect</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-函数声明"><a href="#2-函数声明" class="headerlink" title="2. 函数声明"></a>2. 函数声明</h3><p><code>effect</code>函数有两个入参：</p><ul><li><code>fn</code>：是一个函数，经处理后用于创建 <code>ReactiveEffect</code>实例<code>_effect</code>；</li><li><code>options</code>：可选，用于覆盖<code>_effect</code>上的属性。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> effect&lt;T = <span class="built_in">any</span>&gt;(</span><br><span class="line">  <span class="attr">fn</span>: <span class="function">() =&gt;</span> T,</span><br><span class="line">  options?: <span class="title class_">ReactiveEffectOptions</span></span><br><span class="line">): <span class="title class_">ReactiveEffectRunner</span> &#123;</span><br><span class="line">  <span class="comment">// 处理fn</span></span><br><span class="line">  <span class="keyword">if</span> ((fn <span class="keyword">as</span> <span class="title class_">ReactiveEffectRunner</span>).<span class="property">effect</span>) &#123;</span><br><span class="line">    fn = (fn <span class="keyword">as</span> <span class="title class_">ReactiveEffectRunner</span>).<span class="property">effect</span>.<span class="property">fn</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据 fn 创建一个 _effect</span></span><br><span class="line">  <span class="keyword">const</span> _effect = <span class="keyword">new</span> <span class="title class_">ReactiveEffect</span>(fn);</span><br><span class="line">  <span class="keyword">if</span> (options) &#123;</span><br><span class="line">    <span class="comment">// 用 options 覆盖 _effect 上的属性</span></span><br><span class="line">    <span class="title function_">extend</span>(_effect, options);</span><br><span class="line">    <span class="keyword">if</span> (options.<span class="property">scope</span>) <span class="title function_">recordEffectScope</span>(_effect, options.<span class="property">scope</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 没有 lazy , 则 _effect 立即执行一次 run()</span></span><br><span class="line">  <span class="keyword">if</span> (!options || !options.<span class="property">lazy</span>) &#123;</span><br><span class="line">    _effect.<span class="title function_">run</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// runner：拿到 _effect.run 并挂上 effect 属性，包装成 ReactiveEffectRunner 类型</span></span><br><span class="line">  <span class="keyword">const</span> runner = _effect.<span class="property">run</span>.<span class="title function_">bind</span>(_effect) <span class="keyword">as</span> <span class="title class_">ReactiveEffectRunner</span>;</span><br><span class="line">  <span class="comment">// effect属性指回 _effect 自身，方便使用 runner 调用 run 和 stop</span></span><br><span class="line">  runner.<span class="property">effect</span> = _effect;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回 runner</span></span><br><span class="line">  <span class="keyword">return</span> runner;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-stop函数"><a href="#3-stop函数" class="headerlink" title="3. stop函数"></a>3. <code>stop</code>函数</h3><p><code>stop</code>用于清除<code>effect</code>。入参为<code>ReactiveEffectRunner</code>；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">stop</span>(<span class="params">runner: ReactiveEffectRunner</span>) &#123;</span><br><span class="line">  runner.<span class="property">effect</span>.<span class="title function_">stop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、track-依赖收集"><a href="#三、track-依赖收集" class="headerlink" title="三、track 依赖收集"></a>三、<code>track</code> 依赖收集</h2><h3 id="1-track"><a href="#1-track" class="headerlink" title="1. track"></a>1. <code>track</code></h3><p>一直在说<code>track</code>进行依赖收集，这里看下它到底怎么做的。</p><ul><li>以目标对象<code>target</code>为<code>key</code>，<code>depsMap</code>为<code>targetMap</code>的值；以<code>target</code>的<code>key</code>为<code>key</code>，使用<code>createDep()</code>创建依赖<code>dep</code>为值，存放在<code>target</code>对应的<code>depsMap</code>中。</li><li>通过<code>trackEffects(dep, eventInfo)</code>来收集副作用。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局变量 targetMap</span></span><br><span class="line"><span class="keyword">const</span> targetMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>&lt;<span class="built_in">any</span>, <span class="title class_">KeyToDepMap</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">track</span>(<span class="params">target: <span class="built_in">object</span>, <span class="keyword">type</span>: TrackOpTypes, key: <span class="built_in">unknown</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (shouldTrack &amp;&amp; activeEffect) &#123;</span><br><span class="line">    <span class="keyword">let</span> depsMap = targetMap.<span class="title function_">get</span>(target);</span><br><span class="line">    <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">      targetMap.<span class="title function_">set</span>(target, (depsMap = <span class="keyword">new</span> <span class="title class_">Map</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> dep = depsMap.<span class="title function_">get</span>(key);</span><br><span class="line">    <span class="keyword">if</span> (!dep) &#123;</span><br><span class="line">      depsMap.<span class="title function_">set</span>(key, (dep = <span class="title function_">createDep</span>()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> eventInfo = __DEV__</span><br><span class="line">      ? &#123; <span class="attr">effect</span>: activeEffect, target, <span class="keyword">type</span>, key &#125;</span><br><span class="line">      : <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">trackEffects</span>(dep, eventInfo);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-createDep"><a href="#2-createDep" class="headerlink" title="2. createDep"></a>2. <code>createDep</code></h3><p>使用<code>createDep</code>创建一个新的<code>dep</code>。可以看到，<code>dep</code>是个<code>Set</code>实例，且添加了两个属性：</p><ul><li><code>w</code>：<code>wasTracked</code>的首字母，表示当前依赖是否被收集；</li><li><code>n</code>：<code>newlyTracked</code>的首字母，表示当前依赖是否是新收集的。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createDep = (effects?: <span class="title class_">ReactiveEffect</span>[]): <span class="function"><span class="params">Dep</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> <span class="title class_">Set</span>&lt;<span class="title class_">ReactiveEffect</span>&gt;(effects) <span class="keyword">as</span> <span class="title class_">Dep</span>;</span><br><span class="line">  dep.<span class="property">w</span> = <span class="number">0</span>;</span><br><span class="line">  dep.<span class="property">n</span> = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> dep;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-trackEffects"><a href="#3-trackEffects" class="headerlink" title="3. trackEffects"></a>3. <code>trackEffects</code></h3><p><code>trackEffects</code>用于收集副作用。主要把当前活跃的<code>activeEffect</code>加入<code>dep</code>，以及在<code>activeEffect.deps</code>中加入该副作用影响到的所有依赖。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">trackEffects</span>(<span class="params"></span></span><br><span class="line"><span class="params">  dep: Dep,</span></span><br><span class="line"><span class="params">  debuggerEventExtraInfo?: DebuggerEventExtraInfo</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> shouldTrack = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (effectTrackDepth &lt;= maxMarkerBits) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_">newTracked</span>(dep)) &#123;</span><br><span class="line">      dep.<span class="property">n</span> |= trackOpBit; <span class="comment">// set newly tracked</span></span><br><span class="line">      shouldTrack = !<span class="title function_">wasTracked</span>(dep);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Full cleanup mode.</span></span><br><span class="line">    shouldTrack = !dep.<span class="title function_">has</span>(activeEffect!);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前依赖 dep 还未被捕获 / 当前依赖 dep 中，还没有当前活跃的副作用时，</span></span><br><span class="line">  <span class="comment">// 将当前活跃的副作用 effect 添加进 dep 里，同时在把 dep 加入受副作用影响的依赖集合 activeEffect.deps 中</span></span><br><span class="line">  <span class="keyword">if</span> (shouldTrack) &#123;</span><br><span class="line">    dep.<span class="title function_">add</span>(activeEffect!);</span><br><span class="line">    activeEffect!.<span class="property">deps</span>.<span class="title function_">push</span>(dep);</span><br><span class="line">    <span class="keyword">if</span> (__DEV__ &amp;&amp; activeEffect!.<span class="property">onTrack</span>) &#123;</span><br><span class="line">      activeEffect!.<span class="title function_">onTrack</span>(&#123;</span><br><span class="line">        <span class="attr">effect</span>: activeEffect!,</span><br><span class="line">        ...debuggerEventExtraInfo!,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h3><p>用一句比较拗口的话来说，依赖收集就是把当前活跃的副作用<code>activeEffect</code>存入全局变量<code>targetMap</code>中的 ( <code>target</code> 对应的 <code>depsMap</code>) 中 （<code>target</code>的<code>key</code>）对应的 <code>dep</code> ( 类型为<code>Set</code>) 中，并把这个<code>dep</code>加入到受<code>activeEffect</code>副作用影响的所有依赖<code>activeEffect.deps</code>列表中。</p><h2 id="四、trigger"><a href="#四、trigger" class="headerlink" title="四、trigger"></a>四、<code>trigger</code></h2><p>触发更新实际上就是触发副作用，因此这一小节决定以与<code>track</code>相反的顺序来介绍。</p><h3 id="1-triggerEffect"><a href="#1-triggerEffect" class="headerlink" title="1. triggerEffect"></a>1. <code>triggerEffect</code></h3><p><code>triggerEffect</code>触发副作用从而更新。当触发更新的副作用<code>effect</code>允许自调用，且不是当前活跃的副作用时，通过调度器<code>scheduler</code>执行副作用或者直接执行<code>run</code>，是实际上触发更新的地方。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">triggerEffect</span>(<span class="params"></span></span><br><span class="line"><span class="params">  effect: ReactiveEffect,</span></span><br><span class="line"><span class="params">  debuggerEventExtraInfo?: DebuggerEventExtraInfo</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (effect !== activeEffect || effect.<span class="property">allowRecurse</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__ &amp;&amp; effect.<span class="property">onTrigger</span>) &#123;</span><br><span class="line">      effect.<span class="title function_">onTrigger</span>(<span class="title function_">extend</span>(&#123; effect &#125;, debuggerEventExtraInfo));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实际触发更新的地方</span></span><br><span class="line">    <span class="keyword">if</span> (effect.<span class="property">scheduler</span>) &#123;</span><br><span class="line">      effect.<span class="title function_">scheduler</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      effect.<span class="title function_">run</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-triggerEffects"><a href="#2-triggerEffects" class="headerlink" title="2. triggerEffects"></a>2. <code>triggerEffects</code></h3><p>接收一个<code>dep</code>和用于调试的额外信息。遍历<code>dep</code>中的<code>effect</code>，逐一使用<code>triggerEffect</code>来执行副作用。源码在这里有点蜜汁操作。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">triggerEffects</span>(<span class="params"></span></span><br><span class="line"><span class="params">  dep: Dep | ReactiveEffect[],</span></span><br><span class="line"><span class="params">  debuggerEventExtraInfo?: DebuggerEventExtraInfo</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// spread into array for stabilization</span></span><br><span class="line">  <span class="keyword">const</span> effects = <span class="title function_">isArray</span>(dep) ? dep : [...dep];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 两者互斥，但是执行的操作相同？而且为什么不写在一个 for...of... 里 ？</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> effect <span class="keyword">of</span> effects) &#123;</span><br><span class="line">    <span class="keyword">if</span> (effect.<span class="property">computed</span>) &#123;</span><br><span class="line">      <span class="title function_">triggerEffect</span>(effect, debuggerEventExtraInfo);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> effect <span class="keyword">of</span> effects) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!effect.<span class="property">computed</span>) &#123;</span><br><span class="line">      <span class="title function_">triggerEffect</span>(effect, debuggerEventExtraInfo);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-trigger"><a href="#3-trigger" class="headerlink" title="3. trigger"></a>3. <code>trigger</code></h3><p>之前一直说<code>trigger</code>触发更新，其实是现在已经知道了，实际是<code>triggerEffect</code>来执行副作用从而实现更新。</p><p>这里是创建一个<code>deps</code>数组，根据<code>target</code>、<code>key</code>和触发更新的操作类型<code>type</code>等参数，来获取所有的相关<code>dep</code>，放入<code>deps</code>。再取出<code>deps</code>中所有的<code>dep</code>里的所有<code>effect</code>，放入<code>effects</code>列表中，通过<code>triggerEffects(effects)</code>来触发所有的相关副作用，最终实现更新。</p><p>需要注意的是对于数组：</p><ul><li>修改<code>length</code>属性会导致该数组所有依赖的更新；</li><li>修数组新增成员会引起<code>length</code>属性相关的依赖的更新，因为<code>length</code>的值发生了变化。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params"></span></span><br><span class="line"><span class="params">  target: <span class="built_in">object</span>,</span></span><br><span class="line"><span class="params">  <span class="keyword">type</span>: TriggerOpTypes,</span></span><br><span class="line"><span class="params">  key?: <span class="built_in">unknown</span>,</span></span><br><span class="line"><span class="params">  newValue?: <span class="built_in">unknown</span>,</span></span><br><span class="line"><span class="params">  oldValue?: <span class="built_in">unknown</span>,</span></span><br><span class="line"><span class="params">  oldTarget?: <span class="built_in">Map</span>&lt;<span class="built_in">unknown</span>, <span class="built_in">unknown</span>&gt; | <span class="built_in">Set</span>&lt;<span class="built_in">unknown</span>&gt;</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> depsMap = targetMap.<span class="title function_">get</span>(target);</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    <span class="comment">// never been tracked</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于聚集所有相关依赖</span></span><br><span class="line">  <span class="keyword">let</span> <span class="attr">deps</span>: (<span class="title class_">Dep</span> | <span class="literal">undefined</span>)[] = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">type</span> === <span class="title class_">TriggerOpTypes</span>.<span class="property">CLEAR</span>) &#123;</span><br><span class="line">    <span class="comment">// 调用了Set、Map实例的clear方法，将触发全部相关的副作用</span></span><br><span class="line">    <span class="comment">// collection being cleared</span></span><br><span class="line">    <span class="comment">// trigger all effects for target</span></span><br><span class="line">    deps = [...depsMap.<span class="title function_">values</span>()];</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="string">&quot;length&quot;</span> &amp;&amp; <span class="title function_">isArray</span>(target)) &#123;</span><br><span class="line">    <span class="comment">// 目标对象是数组，且修改了length属性时，会触发全部相关的副作用</span></span><br><span class="line">    depsMap.<span class="title function_">forEach</span>(<span class="function">(<span class="params">dep, key</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (key === <span class="string">&quot;length&quot;</span> || key &gt;= (newValue <span class="keyword">as</span> <span class="built_in">number</span>)) &#123;</span><br><span class="line">        deps.<span class="title function_">push</span>(dep);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// schedule runs for SET | ADD | DELETE</span></span><br><span class="line">    <span class="keyword">if</span> (key !== <span class="built_in">void</span> <span class="number">0</span>) &#123;</span><br><span class="line">      deps.<span class="title function_">push</span>(depsMap.<span class="title function_">get</span>(key));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// also run for iteration key on ADD | DELETE | Map.SET</span></span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">type</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="title class_">TriggerOpTypes</span>.<span class="property">ADD</span>:</span><br><span class="line">        <span class="keyword">if</span> (!<span class="title function_">isArray</span>(target)) &#123;</span><br><span class="line">          deps.<span class="title function_">push</span>(depsMap.<span class="title function_">get</span>(<span class="variable constant_">ITERATE_KEY</span>));</span><br><span class="line">          <span class="keyword">if</span> (<span class="title function_">isMap</span>(target)) &#123;</span><br><span class="line">            deps.<span class="title function_">push</span>(depsMap.<span class="title function_">get</span>(<span class="variable constant_">MAP_KEY_ITERATE_KEY</span>));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isIntegerKey</span>(key)) &#123;</span><br><span class="line">          <span class="comment">// 数组下标成员的更改 会引起 length 属性相关的更新</span></span><br><span class="line">          <span class="comment">// new index added to array -&gt; length changes</span></span><br><span class="line">          deps.<span class="title function_">push</span>(depsMap.<span class="title function_">get</span>(<span class="string">&quot;length&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="title class_">TriggerOpTypes</span>.<span class="property">DELETE</span>:</span><br><span class="line">        <span class="keyword">if</span> (!<span class="title function_">isArray</span>(target)) &#123;</span><br><span class="line">          deps.<span class="title function_">push</span>(depsMap.<span class="title function_">get</span>(<span class="variable constant_">ITERATE_KEY</span>));</span><br><span class="line">          <span class="keyword">if</span> (<span class="title function_">isMap</span>(target)) &#123;</span><br><span class="line">            deps.<span class="title function_">push</span>(depsMap.<span class="title function_">get</span>(<span class="variable constant_">MAP_KEY_ITERATE_KEY</span>));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="title class_">TriggerOpTypes</span>.<span class="property">SET</span>:</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isMap</span>(target)) &#123;</span><br><span class="line">          deps.<span class="title function_">push</span>(depsMap.<span class="title function_">get</span>(<span class="variable constant_">ITERATE_KEY</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> eventInfo = __DEV__</span><br><span class="line">    ? &#123; target, <span class="keyword">type</span>, key, newValue, oldValue, oldTarget &#125;</span><br><span class="line">    : <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (deps.<span class="property">length</span> === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (deps[<span class="number">0</span>]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        <span class="title function_">triggerEffects</span>(deps[<span class="number">0</span>], eventInfo);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">triggerEffects</span>(deps[<span class="number">0</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="attr">effects</span>: <span class="title class_">ReactiveEffect</span>[] = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> dep <span class="keyword">of</span> deps) &#123;</span><br><span class="line">      <span class="keyword">if</span> (dep) &#123;</span><br><span class="line">        effects.<span class="title function_">push</span>(...dep);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里triggerEffects接受的参数类型为Set，之前的是数组</span></span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      <span class="title function_">triggerEffects</span>(<span class="title function_">createDep</span>(effects), eventInfo);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">triggerEffects</span>(<span class="title function_">createDep</span>(effects));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、小结"><a href="#五、小结" class="headerlink" title="五、小结"></a>五、小结</h2><h3 id="1-依赖收集"><a href="#1-依赖收集" class="headerlink" title="1. 依赖收集"></a>1. 依赖收集</h3><p><code>targetMap</code>中有<code>depsMap</code>（以<code>target</code>为<code>key</code>）；<code>depsMap</code>中有许多<code>dep</code>（以<code>targetMap</code>的<code>key</code>为<code>key</code>）；简单理解为：在编译时根据<code>target</code>和<code>key</code>，创建副作用，将<code>activeEffect</code>指向新建的副作用，并存放到相关的依赖<code>dep</code>里的过程就是依赖收集。</p><h3 id="2-触发更新"><a href="#2-触发更新" class="headerlink" title="2. 触发更新"></a>2. 触发更新</h3><p>反过来，触发<code>target</code>、<code>key</code>相关的<code>dep</code>中所有相关的副作用，通过各个副作用上的<code>effect.scheduler()</code>或者<code>effect.run()</code>来实现更新。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前 端 </tag>
            
            <tag> Vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3源码系列 (四) ref</title>
      <link href="/articals/f1070434/"/>
      <url>/articals/f1070434/</url>
      
        <content type="html"><![CDATA[<p>我们知道，一般用<code>reactive</code>来定义一个响应式对象，<code>ref</code>常用来定义一个响应式的原始值。上篇文章已经聊过了<code>reactive</code>，知晓了如何通过<code>Proxy</code>来对目标对象进行代理从而实现响应式，而非对象的这些原始值的响应式问题就交给<code>ref</code>来解决了。</p><h2 id="一、ref-和-shallowRef的函数签名"><a href="#一、ref-和-shallowRef的函数签名" class="headerlink" title="一、ref 和 shallowRef的函数签名"></a>一、<code>ref</code> 和 <code>shallowRef</code>的函数签名</h2><p><code>ref</code>和<code>shallowRef</code>各有三种重载，入参各不相同，都返回一个<code>Ref</code>/<code>ShallowRef</code>类型的值。通过<code>createRef</code>函数创建一个响应式的值。和 <code>reactive</code> 相似，<code>reactive</code>也是通过调用<code>createReactiveObject</code>来创建一个响应式的对象。而<code>createRef</code>创建并返回一个 <code>RefImpl</code> 实例。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ref</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> ref&lt;T <span class="keyword">extends</span> <span class="built_in">object</span>&gt;(</span><br><span class="line">  <span class="attr">value</span>: T</span><br><span class="line">): [T] <span class="keyword">extends</span> [<span class="title class_">Ref</span>] ? T : <span class="title class_">Ref</span>&lt;<span class="title class_">UnwrapRef</span>&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> ref&lt;T&gt;(<span class="attr">value</span>: T): <span class="title class_">Ref</span>&lt;<span class="title class_">UnwrapRef</span>&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> ref&lt;T = <span class="built_in">any</span>&gt;(): <span class="title class_">Ref</span>&lt;T | <span class="literal">undefined</span>&gt;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">ref</span>(<span class="params">value?: <span class="built_in">unknown</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createRef</span>(value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// shallowRef</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> shallowRef&lt;T <span class="keyword">extends</span> <span class="built_in">object</span>&gt;(</span><br><span class="line">  <span class="attr">value</span>: T</span><br><span class="line">): T <span class="keyword">extends</span> <span class="title class_">Ref</span> ? T : <span class="title class_">ShallowRef</span>&lt;T&gt;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> shallowRef&lt;T&gt;(<span class="attr">value</span>: T): <span class="title class_">ShallowRef</span>&lt;T&gt;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> shallowRef&lt;T = <span class="built_in">any</span>&gt;(): <span class="title class_">ShallowRef</span>&lt;T | <span class="literal">undefined</span>&gt;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">shallowRef</span>(<span class="params">value?: <span class="built_in">unknown</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createRef</span>(value, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// createRef</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createRef</span>(<span class="params">rawValue: <span class="built_in">unknown</span>, shallow: <span class="built_in">boolean</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isRef</span>(rawValue)) &#123;</span><br><span class="line">    <span class="keyword">return</span> rawValue;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RefImpl</span>(rawValue, shallow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、RefImpl"><a href="#二、RefImpl" class="headerlink" title="二、RefImpl"></a>二、<code>RefImpl</code></h2><p>顺带一说，在<code>ts</code>里，关键字<code>class</code>既声明了一个值，也声明了一个<code>ts</code>类型。<code>RefImpl</code>算是<code>ref</code>的核心内容了，构造器函数接收两个参数，<code>value</code>是传入的原本的值，<code>__v_isShallow</code>在上一篇讲<code>reeactive</code>和<code>readonly</code>的文章里，也有这个属性，用于区别深层/浅层。且<code>isShallow()</code>函数也会利用这个属性来做判断。在这里两个作用，一是作为实例属性供<code>isShallow</code>判断；而是根据传入时来值来判断是否是浅层的<code>Ref</code>，因为函数<code>shallowRef</code>也是创建一个<code>RefImpl</code>实例。</p><p>可以看到，<code>Ref</code>的响应式实现就比较简单了，用<code>_value</code>属性来存储实际的值，用<code>dep</code>属性存储依赖，用在<code>class</code>的<code>getter</code>里通过<code>trackRefValue(this)</code>来收集依赖，在<code>setter</code>里调用<code>triggerRefValue(this, newVal)</code>。和<code>vue2</code>里的实现相似，只是这里使用的 <code>class</code> 的<code>getter</code>和<code>setter</code>，而<code>vue2</code>里使用的是属性描述符里的<code>getter</code>和<code>setter</code>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RefImpl</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">_value</span>: T;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">_rawValue</span>: T;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> dep?: <span class="title class_">Dep</span> = <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">readonly</span> __v_isRef = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value: T, <span class="keyword">public</span> <span class="keyword">readonly</span> __v_isShallow: <span class="built_in">boolean</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_rawValue</span> = __v_isShallow ? value : <span class="title function_">toRaw</span>(value);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_value</span> = __v_isShallow ? value : <span class="title function_">toReactive</span>(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">    <span class="title function_">trackRefValue</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_value</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">value</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> useDirectValue =</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">__v_isShallow</span> || <span class="title function_">isShallow</span>(newVal) || <span class="title function_">isReadonly</span>(newVal);</span><br><span class="line">    <span class="comment">// shallowRef或者 新值 是浅层的或者只读的，则设置值的之前对新值解包</span></span><br><span class="line">    newVal = useDirectValue ? newVal : <span class="title function_">toRaw</span>(newVal);</span><br><span class="line">    <span class="comment">// 对比新值和旧值，如果有改变则触发更新</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">hasChanged</span>(newVal, <span class="variable language_">this</span>.<span class="property">_rawValue</span>)) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_rawValue</span> = newVal;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_value</span> = useDirectValue ? newVal : <span class="title function_">toReactive</span>(newVal);</span><br><span class="line">      <span class="title function_">triggerRefValue</span>(<span class="variable language_">this</span>, newVal);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、trackRefValue"><a href="#三、trackRefValue" class="headerlink" title="三、trackRefValue"></a>三、<code>trackRefValue</code></h2><p><code>trackRefValue</code>用于收集<code>Ref</code>的依赖，接收一个<code>RefBase</code>类型的值。在<code>ref</code>函数中则是接收<code>RefImpl</code>的实例。<code>shouldTrack</code>是从<code>effect</code>的模块引入的，用做暂停和恢复捕获依赖的标志；<code>activeEffect</code>也是从<code>effect</code>的模块引入，标记当前活跃的<code>effect</code>。可以看到，内部调用<code>trackEffects</code>函数来收集依赖，该函数来自<code>effect</code>的模块，放在<code>effect</code>的篇章里讲。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// trackRefValue</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">trackRefValue</span>(<span class="params">ref: RefBase&lt;<span class="built_in">any</span>&gt;</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (shouldTrack &amp;&amp; activeEffect) &#123;</span><br><span class="line">    <span class="comment">// 对Ref进行解包</span></span><br><span class="line">    ref = <span class="title function_">toRaw</span>(ref);</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      <span class="title function_">trackEffects</span>(ref.<span class="property">dep</span> || (ref.<span class="property">dep</span> = <span class="title function_">createDep</span>()), &#123;</span><br><span class="line">        <span class="attr">target</span>: ref,</span><br><span class="line">        <span class="attr">type</span>: <span class="title class_">TrackOpTypes</span>.<span class="property">GET</span>,</span><br><span class="line">        <span class="attr">key</span>: <span class="string">&quot;value&quot;</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">trackEffects</span>(ref.<span class="property">dep</span> || (ref.<span class="property">dep</span> = <span class="title function_">createDep</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、triggerRefValue"><a href="#四、triggerRefValue" class="headerlink" title="四、triggerRefValue"></a>四、<code>triggerRefValue</code></h2><p><code>triggerRefValue</code>函数用于触发<code>Ref</code>的响应式更新。<code>triggerEffects</code>函数来自<code>effect</code>的模块，在<code>effect</code>的篇章里讲到。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">triggerRefValue</span>(<span class="params">ref: RefBase&lt;<span class="built_in">any</span>&gt;, newVal?: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">  <span class="comment">// 对Ref进行解包</span></span><br><span class="line">  ref = <span class="title function_">toRaw</span>(ref);</span><br><span class="line">  <span class="comment">// 当有收集到依赖时，触发更新</span></span><br><span class="line">  <span class="keyword">if</span> (ref.<span class="property">dep</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      <span class="title function_">triggerEffects</span>(ref.<span class="property">dep</span>, &#123;</span><br><span class="line">        <span class="attr">target</span>: ref,</span><br><span class="line">        <span class="attr">type</span>: <span class="title class_">TriggerOpTypes</span>.<span class="property">SET</span>,</span><br><span class="line">        <span class="attr">key</span>: <span class="string">&quot;value&quot;</span>,</span><br><span class="line">        <span class="attr">newValue</span>: newVal,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">triggerEffects</span>(ref.<span class="property">dep</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、customRef-和-CustomRefImpl"><a href="#五、customRef-和-CustomRefImpl" class="headerlink" title="五、customRef 和 CustomRefImpl"></a>五、<code>customRef</code> 和 <code>CustomRefImpl</code></h2><p><code>Vue3</code>还提供了自定义的<code>Ref</code>，自己传入<code>getter</code>和<code>setter</code>，可以自由选择<code>track</code>和<code>trigger</code>的时机。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomRefImpl</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">public</span> dep?: <span class="title class_">Dep</span> = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="attr">_get</span>: <span class="title class_">ReturnType</span>&lt;<span class="title class_">CustomRefFactory</span>&lt;T&gt;&gt;[<span class="string">&quot;get&quot;</span>];</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="attr">_set</span>: <span class="title class_">ReturnType</span>&lt;<span class="title class_">CustomRefFactory</span>&lt;T&gt;&gt;[<span class="string">&quot;set&quot;</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">readonly</span> __v_isRef = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">factory: CustomRefFactory&lt;T&gt;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; get, set &#125; = <span class="title function_">factory</span>(</span><br><span class="line">      <span class="function">() =&gt;</span> <span class="title function_">trackRefValue</span>(<span class="variable language_">this</span>),</span><br><span class="line">      <span class="function">() =&gt;</span> <span class="title function_">triggerRefValue</span>(<span class="variable language_">this</span>)</span><br><span class="line">    );</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_get</span> = get;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_set</span> = set;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">_get</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">value</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">_set</span>(newVal);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> customRef&lt;T&gt;(<span class="attr">factory</span>: <span class="title class_">CustomRefFactory</span>&lt;T&gt;): <span class="title class_">Ref</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CustomRefImpl</span>(factory) <span class="keyword">as</span> <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、toRef、toRefs-和-ObjectRefImpl"><a href="#六、toRef、toRefs-和-ObjectRefImpl" class="headerlink" title="六、toRef、toRefs 和 ObjectRefImpl"></a>六、<code>toRef</code>、<code>toRefs</code> 和 <code>ObjectRefImpl</code></h2><p>在<code>setup</code>函数中返参时，我们有时候想要对响应式对象的某个属性进行解构，往往是用到<code>toRef</code>来创建一个<code>ObjectRefImpl</code>实例。</p><p>可以看到，原来的响应式对象依然被这个<code>ObjectRefImpl</code>实例通过<code>_object</code>属性引用。而在<code>getter</code>里面，会通过原本的响应式对象<code>_object</code>来访问该值，因而依赖的收集是由原本的响应式对象<code>_object</code>来进行的；同样的，在<code>setter</code>里，也是通过引用原本的响应式对象<code>_object</code>来达到赋值的操作，从而在<code>_object</code>中触发更新。也就是说，<code>ObjectRefImpl</code>不负责依赖收集和响应式更新，这些都是借由原本的响应式对象<code>_object</code>完成的。</p><p><code>toRef</code>简要判断入参是否是一个<code>Ref</code>，是则直接返回，否则返回一个新建的<code>ObjectRefImpl</code>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ObjectRefImpl</span>&lt;T <span class="keyword">extends</span> <span class="built_in">object</span>, K <span class="keyword">extends</span> keyof T&gt; &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">readonly</span> __v_isRef = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="comment">// 私有只读属性 原本的响应式对象</span></span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> <span class="keyword">readonly</span> _object: T,</span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> <span class="keyword">readonly</span> _key: K,</span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> <span class="keyword">readonly</span> _defaultValue?: T[K]</span></span><br><span class="line"><span class="params">  </span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">    <span class="keyword">const</span> val = <span class="variable language_">this</span>.<span class="property">_object</span>[<span class="variable language_">this</span>.<span class="property">_key</span>];</span><br><span class="line">    <span class="keyword">return</span> val === <span class="literal">undefined</span> ? (<span class="variable language_">this</span>.<span class="property">_defaultValue</span> <span class="keyword">as</span> T[K]) : val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">value</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_object</span>[<span class="variable language_">this</span>.<span class="property">_key</span>] = newVal;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ts类型ToRef&lt;T&gt;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">ToRef</span>&lt;T&gt; = <span class="title class_">IfAny</span>&lt;T, <span class="title class_">Ref</span>&lt;T&gt;, [T] <span class="keyword">extends</span> [<span class="title class_">Ref</span>] ? T : <span class="title class_">Ref</span>&lt;T&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> toRef&lt;T <span class="keyword">extends</span> <span class="built_in">object</span>, K <span class="keyword">extends</span> keyof T&gt;(</span><br><span class="line">  <span class="attr">object</span>: T,</span><br><span class="line">  <span class="attr">key</span>: K</span><br><span class="line">): <span class="title class_">ToRef</span>&lt;T[K]&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> toRef&lt;T <span class="keyword">extends</span> <span class="built_in">object</span>, K <span class="keyword">extends</span> keyof T&gt;(</span><br><span class="line">  <span class="attr">object</span>: T,</span><br><span class="line">  <span class="attr">key</span>: K,</span><br><span class="line">  <span class="attr">defaultValue</span>: T[K]</span><br><span class="line">): <span class="title class_">ToRef</span>&lt;<span class="title class_">Exclude</span>&lt;T[K], <span class="literal">undefined</span>&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> toRef&lt;T <span class="keyword">extends</span> <span class="built_in">object</span>, K <span class="keyword">extends</span> keyof T&gt;(</span><br><span class="line">  <span class="attr">object</span>: T,</span><br><span class="line">  <span class="attr">key</span>: K,</span><br><span class="line">  defaultValue?: T[K]</span><br><span class="line">): <span class="title class_">ToRef</span>&lt;T[K]&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> val = <span class="built_in">object</span>[key];</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">isRef</span>(val)</span><br><span class="line">    ? val</span><br><span class="line">    : (<span class="keyword">new</span> <span class="title class_">ObjectRefImpl</span>(<span class="built_in">object</span>, key, defaultValue) <span class="keyword">as</span> <span class="built_in">any</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<code>toRefs</code>则是对传入的对象/数组进行遍历并进行<code>toRef</code>解构。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> toRefs&lt;T <span class="keyword">extends</span> <span class="built_in">object</span>&gt;(<span class="attr">object</span>: T): <span class="title class_">ToRefs</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (__DEV__ &amp;&amp; !<span class="title function_">isProxy</span>(<span class="built_in">object</span>)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">warn</span>(</span><br><span class="line">      <span class="string">`toRefs() expects a reactive object but received a plain one.`</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">ret</span>: <span class="built_in">any</span> = <span class="title function_">isArray</span>(<span class="built_in">object</span>) ? <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="built_in">object</span>.<span class="property">length</span>) : &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> <span class="built_in">object</span>) &#123;</span><br><span class="line">    ret[key] = <span class="title function_">toRef</span>(<span class="built_in">object</span>, key);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前 端 </tag>
            
            <tag> Vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3源码系列 (三) reactive 和 readonly</title>
      <link href="/articals/f9a32caf/"/>
      <url>/articals/f9a32caf/</url>
      
        <content type="html"><![CDATA[<p>上次一起阅读了<code>watch</code>和<code>computed</code>的源码，其实应该先看副作用<code>effect</code>，因为各个响应式的<code>API</code>里基本都用到了，等结束了<code>reactive</code>和<code>readonly</code>和<code>ref</code>，就一起看看<code>effect</code>。这次要说的是<code>reactive</code>和<code>readonly</code>，两者在实现上流程大体一致。尤其是对<code>Map</code>和<code>Set</code>的方法的代理拦截，多少有点妙。</p><h2 id="一、reactive-和-readonly"><a href="#一、reactive-和-readonly" class="headerlink" title="一、reactive 和 readonly"></a>一、<code>reactive</code> 和 <code>readonly</code></h2><p><code>Vue3</code>使用<code>Proxy</code>来替代<code>Vue2</code>中<code>Object.defineProperty</code>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;onlyy~&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个对target的代理</span></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, &#123;</span><br><span class="line">  <span class="comment">// ...各种handler，例如get，set...</span></span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, property, receiver</span>) &#123;</span><br><span class="line">    <span class="comment">// 其它操作</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, property, receiver);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="1-reactive相关类型"><a href="#1-reactive相关类型" class="headerlink" title="1. reactive相关类型"></a>1. <code>reactive</code>相关类型</h3><p><code>reactive</code>利用<code>Proxy</code>来定义一个响应式对象。</p><ul><li><code>Target</code>：目标对象，包含几个标志，以及<code>__v_raw</code>字段，该字段表示它原本的非响应式状态的值；</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">  [<span class="title class_">ReactiveFlags</span>.<span class="property">SKIP</span>]?: <span class="built_in">boolean</span>;</span><br><span class="line">  [<span class="title class_">ReactiveFlags</span>.<span class="property">IS_REACTIVE</span>]?: <span class="built_in">boolean</span>;</span><br><span class="line">  [<span class="title class_">ReactiveFlags</span>.<span class="property">IS_READONLY</span>]?: <span class="built_in">boolean</span>;</span><br><span class="line">  [<span class="title class_">ReactiveFlags</span>.<span class="property">IS_SHALLOW</span>]?: <span class="built_in">boolean</span>;</span><br><span class="line">  [<span class="title class_">ReactiveFlags</span>.<span class="property">RAW</span>]?: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> reactiveMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>&lt;<span class="title class_">Target</span>, <span class="built_in">any</span>&gt;();</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> shallowReactiveMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>&lt;<span class="title class_">Target</span>, <span class="built_in">any</span>&gt;();</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> readonlyMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>&lt;<span class="title class_">Target</span>, <span class="built_in">any</span>&gt;();</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> shallowReadonlyMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>&lt;<span class="title class_">Target</span>, <span class="built_in">any</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> <span class="title class_">TargetType</span> &#123;</span><br><span class="line">  <span class="variable constant_">INVALID</span> = <span class="number">0</span>,</span><br><span class="line">  <span class="variable constant_">COMMON</span> = <span class="number">1</span>,</span><br><span class="line">  <span class="variable constant_">COLLECTION</span> = <span class="number">2</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-相关全局变量与方法"><a href="#2-相关全局变量与方法" class="headerlink" title="2. 相关全局变量与方法"></a>2. 相关全局变量与方法</h3><ul><li><code>ReactiveFlags</code>：定义了各种标志对应的字符串（作为<code>reactive</code>对象的属性）的枚举；</li><li><code>reactiveMap</code></li><li><code>shallowReactiveMap</code></li><li><code>readonlyMap</code></li><li><code>shallowReadonlyMap</code>：这几个<code>Map</code>分别用于存放对应<code>API</code>生成的响应式对象（以目标对象为<code>key</code>，代理对象为<code>value</code>），便于后续判断某个对象是否存在已创建的响应式对象；</li><li><code>TargetType</code>：枚举成员的内容分别用于区分代理目标是否校验合法、普通对象、<code>Set</code>或<code>Map</code>；</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 各个标志枚举</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="keyword">enum</span> <span class="title class_">ReactiveFlags</span> &#123;</span><br><span class="line">  <span class="variable constant_">SKIP</span> = <span class="string">&quot;__v_skip&quot;</span>,</span><br><span class="line">  <span class="variable constant_">IS_REACTIVE</span> = <span class="string">&quot;__v_isReactive&quot;</span>,</span><br><span class="line">  <span class="variable constant_">IS_READONLY</span> = <span class="string">&quot;__v_isReadonly&quot;</span>,</span><br><span class="line">  <span class="variable constant_">IS_SHALLOW</span> = <span class="string">&quot;__v_isShallow&quot;</span>,</span><br><span class="line">  <span class="variable constant_">RAW</span> = <span class="string">&quot;__v_raw&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> reactiveMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>&lt;<span class="title class_">Target</span>, <span class="built_in">any</span>&gt;();</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> shallowReactiveMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>&lt;<span class="title class_">Target</span>, <span class="built_in">any</span>&gt;();</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> readonlyMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>&lt;<span class="title class_">Target</span>, <span class="built_in">any</span>&gt;();</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> shallowReadonlyMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>&lt;<span class="title class_">Target</span>, <span class="built_in">any</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> <span class="title class_">TargetType</span> &#123;</span><br><span class="line">  <span class="variable constant_">INVALID</span> = <span class="number">0</span>,</span><br><span class="line">  <span class="variable constant_">COMMON</span> = <span class="number">1</span>,</span><br><span class="line">  <span class="variable constant_">COLLECTION</span> = <span class="number">2</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是两个函数：<code>targetTypeMap</code>用于判断各种<code>JS</code>类型属于<code>TargetType</code>中的哪种；<code>getTargetType</code>用于获取<code>target</code>对应的<code>TargetType</code>类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">targetTypeMap</span>(<span class="params">rawType: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (rawType) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Object&quot;</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Array&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">TargetType</span>.<span class="property">COMMON</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Map&quot;</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Set&quot;</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;WeakMap&quot;</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;WeakSet&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">TargetType</span>.<span class="property">COLLECTION</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">TargetType</span>.<span class="property">INVALID</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getTargetType</span>(<span class="params">value: Target</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> value[<span class="title class_">ReactiveFlags</span>.<span class="property">SKIP</span>] || !<span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(value)</span><br><span class="line">    ? <span class="title class_">TargetType</span>.<span class="property">INVALID</span></span><br><span class="line">    : <span class="title function_">targetTypeMap</span>(<span class="title function_">toRawType</span>(value));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-reactive函数"><a href="#3-reactive函数" class="headerlink" title="3. reactive函数"></a>3. <code>reactive</code>函数</h3><p><code>reactive</code>入参类型为<code>object</code>，返回值类型是<code>UnwrapNestedRefs</code>，对嵌套的<code>Ref</code>进行了解包。意味着即使<code>reactive</code>接收一个<code>Ref</code>，其返回值也不用再像<code>Ref</code>那样通过<code>.value</code>来读取值。源码的注释中也给出了示例。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * const count = ref(0)</span></span><br><span class="line"><span class="comment"> * const obj = reactive(&#123;</span></span><br><span class="line"><span class="comment"> *   count</span></span><br><span class="line"><span class="comment"> * &#125;)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * obj.count++</span></span><br><span class="line"><span class="comment"> * obj.count // -&gt; 1</span></span><br><span class="line"><span class="comment"> * count.value // -&gt; 1</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p><code>reactive</code>内部调用<code>createReactiveObject</code>来创建响应式对象。瞄一眼入参有五个：</p><ul><li><code>target</code>：代理目标；</li><li><code>false</code>：对应<code>createReactiveObject</code>的<code>isReadonly</code>参数；</li><li><code>mutableHandlers</code>：普通对象和数组的代理处理程序；</li><li><code>mutableCollectionHandlers</code>：<code>Set</code>和<code>Map</code>的代理处理程序；</li><li><code>reactiveMap</code>：之前定义的全局变量，收集<code>reactive</code>对应的依赖。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> reactive&lt;T <span class="keyword">extends</span> <span class="built_in">object</span>&gt;(<span class="attr">target</span>: T): <span class="title class_">UnwrapNestedRefs</span>&lt;T&gt;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">target: <span class="built_in">object</span></span>) &#123;</span><br><span class="line">  <span class="comment">// if trying to observe a readonly proxy, return the readonly version.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isReadonly</span>(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createReactiveObject</span>(</span><br><span class="line">    target,</span><br><span class="line">    <span class="literal">false</span>,</span><br><span class="line">    mutableHandlers,</span><br><span class="line">    mutableCollectionHandlers,</span><br><span class="line">    reactiveMap</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-造物主createReactiveObject"><a href="#4-造物主createReactiveObject" class="headerlink" title="4. 造物主createReactiveObject"></a>4. 造物主<code>createReactiveObject</code></h3><p>不论是<code>reactive</code>，还是<code>shallowReactive</code>、<code>readonly</code>和<code>shallowReadonly</code>，都是内部调用<code>createReactiveObject</code>来创建代理的。<code>createReactiveObject</code>也没什么操作，主要判断了下<code>target</code>的类型，再决定是直接返回<code>target</code>还是返回一个新建的<code>proxy</code>。</p><p>以下情况直接返回<code>target</code>：</p><ul><li><code>target</code>不是对象；</li><li><code>target</code>已经是一个响应式的对象，即由<code>createReactiveObject</code>创建的<code>proxy</code>；</li><li><code>target</code>类型校验不合法，例如<code>RegExp</code>、<code>Date</code>等；</li></ul><p>当参数<code>proxyMap</code>对应的实参（可能为<code>reactiveMap</code>、<code>shallowReactiveMap</code>、<code>readonlyMap</code>或<code>shallowReadonlyMap</code>，分别对应<code>ractive</code>、<code>shallowReactive</code>、<code>readonly</code>和<code>shallowReadonly</code>四个<code>API</code>）里已经存在了<code>target</code>的响应式对象时，直接取出并返回该响应式对象；</p><p>否则，创建一个<code>target</code>的响应式对象<code>proxy</code>，将<code>proxy</code>加入到<code>proxyMap</code>中，然后返回该<code>proxy</code>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createReactiveObject</span>(<span class="params"></span></span><br><span class="line"><span class="params">  target: Target,</span></span><br><span class="line"><span class="params">  isReadonly: <span class="built_in">boolean</span>,</span></span><br><span class="line"><span class="params">  baseHandlers: ProxyHandler&lt;<span class="built_in">any</span>&gt;,</span></span><br><span class="line"><span class="params">  collectionHandlers: ProxyHandler&lt;<span class="built_in">any</span>&gt;,</span></span><br><span class="line"><span class="params">  proxyMap: <span class="built_in">WeakMap</span>&lt;Target, <span class="built_in">any</span>&gt;</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">isObject</span>(target)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">`value cannot be made reactive: <span class="subst">$&#123;<span class="built_in">String</span>(target)&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// target is already a Proxy, return it.</span></span><br><span class="line">  <span class="comment">// exception: calling readonly() on a reactive object</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    target[<span class="title class_">ReactiveFlags</span>.<span class="property">RAW</span>] &amp;&amp;</span><br><span class="line">    !(isReadonly &amp;&amp; target[<span class="title class_">ReactiveFlags</span>.<span class="property">IS_REACTIVE</span>])</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// target already has corresponding Proxy</span></span><br><span class="line">  <span class="keyword">const</span> existingProxy = proxyMap.<span class="title function_">get</span>(target);</span><br><span class="line">  <span class="keyword">if</span> (existingProxy) &#123;</span><br><span class="line">    <span class="keyword">return</span> existingProxy;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// only specific value types can be observed.</span></span><br><span class="line">  <span class="keyword">const</span> targetType = <span class="title function_">getTargetType</span>(target);</span><br><span class="line">  <span class="keyword">if</span> (targetType === <span class="title class_">TargetType</span>.<span class="property">INVALID</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(</span><br><span class="line">    target,</span><br><span class="line">    targetType === <span class="title class_">TargetType</span>.<span class="property">COLLECTION</span> ? collectionHandlers : baseHandlers</span><br><span class="line">  );</span><br><span class="line">  proxyMap.<span class="title function_">set</span>(target, proxy);</span><br><span class="line">  <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道，代理的重点其实在与代理的处理程序，<code>createReactiveObject</code>根据普通对象和数组类型、<code>Set</code>和<code>Map</code>类型来区分<code>baseHandlers</code>和<code>collectionHandlers</code>。</p><h3 id="5-shallowReactive、readonly和shallowReadonly"><a href="#5-shallowReactive、readonly和shallowReadonly" class="headerlink" title="5. shallowReactive、readonly和shallowReadonly"></a>5. <code>shallowReactive</code>、<code>readonly</code>和<code>shallowReadonly</code></h3><p>事实上，<code>ractive</code>、<code>shallowReactive</code>、<code>readonly</code>和<code>shallowReadonly</code>这几个函数形式上基本一致，都是通过<code>createReactiveObject</code>来创建响应式对象，存储在对应的<code>proxyMap</code>里，但是对应的<code>baseHandlers</code>和<code>collectionHandlers</code>有区别。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shallowReactive</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> shallowReactive&lt;T <span class="keyword">extends</span> <span class="built_in">object</span>&gt;(</span><br><span class="line">  <span class="attr">target</span>: T</span><br><span class="line">): <span class="title class_">ShallowReactive</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createReactiveObject</span>(</span><br><span class="line">    target,</span><br><span class="line">    <span class="literal">false</span>,</span><br><span class="line">    shallowReactiveHandlers,</span><br><span class="line">    shallowCollectionHandlers,</span><br><span class="line">    shallowReactiveMap</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// raedonly</span></span><br><span class="line"><span class="comment">// 注意readonly不是响应式的，而是一个原对象的只读的拷贝</span></span><br><span class="line"><span class="comment">// 具体实现在对应的handlers里</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="keyword">readonly</span>&lt;T <span class="keyword">extends</span> <span class="built_in">object</span>&gt;(</span><br><span class="line">  <span class="attr">target</span>: T</span><br><span class="line">): <span class="title class_">DeepReadonly</span>&lt;<span class="title class_">UnwrapNestedRefs</span>&lt;T&gt;&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createReactiveObject</span>(</span><br><span class="line">    target,</span><br><span class="line">    <span class="literal">true</span>,</span><br><span class="line">    readonlyHandlers,</span><br><span class="line">    readonlyCollectionHandlers,</span><br><span class="line">    readonlyMap</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// shallowReadonly</span></span><br><span class="line"><span class="comment">// 是响应式的</span></span><br><span class="line"><span class="comment">// 只有最外层是只读的</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> shallowReadonly&lt;T <span class="keyword">extends</span> <span class="built_in">object</span>&gt;(<span class="attr">target</span>: T): <span class="title class_">Readonly</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createReactiveObject</span>(</span><br><span class="line">    target,</span><br><span class="line">    <span class="literal">true</span>,</span><br><span class="line">    shallowReadonlyHandlers,</span><br><span class="line">    shallowReadonlyCollectionHandlers,</span><br><span class="line">    shallowReadonlyMap</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，<code>ractive</code>、<code>shallowReactive</code>、<code>readonly</code>和<code>shallowReadonly</code>这几个函数形式上基本一致，都是通过<code>createReactiveObject</code>来创建响应式对象，存储在对应的<code>proxyMap</code>里，但是对应的<code>baseHandlers</code>和<code>collectionHandlers</code>有区别。那么我们就知道了，其实重点都在各种<code>handlers</code>里。</p><h2 id="二、对应的-Handlers"><a href="#二、对应的-Handlers" class="headerlink" title="二、对应的 Handlers"></a>二、对应的 <code>Handlers</code></h2><p><code>baseHandlers</code>用于普通对象和数组的代理，<code>collectionHandlers</code>用于<code>Set</code>、<code>Map</code>等的代理。对应<code>ractive</code>、<code>shallowReactive</code>、<code>readonly</code>和<code>shallowReadonly</code>四个<code>API</code>，每一个都有自己的<code>baseHandlers</code>和<code>collectionHandlers</code>。</p><h3 id="1-baseHandlers"><a href="#1-baseHandlers" class="headerlink" title="1. baseHandlers"></a>1. <code>baseHandlers</code></h3><p>在<code>packages/reactivity/src/baseHandlers.ts</code>文件中。分别导出了这 4 个<code>API</code>对应的<code>baseHandlers</code>。</p><h4 id="1-1-reactive"><a href="#1-1-reactive" class="headerlink" title="1.1 reactive"></a>1.1 <code>reactive</code></h4><p><code>reactive</code>的<code>baseHandlers</code>中有 5 个代理程序。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reactive</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">mutableHandlers</span>: <span class="title class_">ProxyHandler</span>&lt;<span class="built_in">object</span>&gt; = &#123;</span><br><span class="line">  get,</span><br><span class="line">  set,</span><br><span class="line">  deleteProperty,</span><br><span class="line">  has,</span><br><span class="line">  ownKeys,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在拦截过程中，在<code>get</code>、<code>has</code>和<code>ownKey</code>这几个访问程序中进行依赖捕获(<code>track</code>)，在<code>set</code>和<code>deleteProperty</code>这俩用于更改的程序中触发更新(<code>trigger</code>) 。</p><p><code>get</code>和<code>set</code>分别由函数<code>createGetter</code>和<code>createSetter</code>创建，这俩函数根据入参的不同，返回不同的<code>get</code>和<code>set</code>，<code>readonly</code>等<code>API</code>的<code>baseHandlers</code>中的<code>get</code>和<code>set</code>也大都源于此，除了两种<code>readonly</code>中用于告警的<code>set</code>。</p><h5 id="1-get"><a href="#1-get" class="headerlink" title="(1) get"></a>(1) <code>get</code></h5><p><code>createGetter</code>两个入参：<code>isReadonly</code>和<code>isShallow</code>，两两组合正好对应四个<code>API</code>。</p><ul><li><code>shallow</code>：为<code>true</code>时不会进入递归环节，因此是浅层的处理；</li><li><code>isReadonly</code>：在<code>createGetter</code>中影响<code>proxyMap</code>的选择和递归时<code>API</code>的选择，它主要发挥作用是在<code>set</code>中。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createGetter</span>(<span class="params">isReadonly = <span class="literal">false</span>, shallow = <span class="literal">false</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">get</span>(<span class="params">target: Target, key: <span class="built_in">string</span> | <span class="built_in">symbol</span>, receiver: <span class="built_in">object</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 以下几个if分支判断target是否已经是由这几个API创建的代理对象，代理得到的proxy才具有这些key</span></span><br><span class="line">    <span class="keyword">if</span> (key === <span class="title class_">ReactiveFlags</span>.<span class="property">IS_REACTIVE</span>) &#123;</span><br><span class="line">      <span class="comment">// 是否是响应式对象</span></span><br><span class="line">      <span class="keyword">return</span> !isReadonly;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="title class_">ReactiveFlags</span>.<span class="property">IS_READONLY</span>) &#123;</span><br><span class="line">      <span class="comment">// 是否是只读对象</span></span><br><span class="line">      <span class="keyword">return</span> isReadonly;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="title class_">ReactiveFlags</span>.<span class="property">IS_SHALLOW</span>) &#123;</span><br><span class="line">      <span class="comment">// 是否是浅层的 响应式/只读 对象</span></span><br><span class="line">      <span class="keyword">return</span> shallow;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">      <span class="comment">// __v_raw 属性对应 代理对象的目标对象</span></span><br><span class="line">      <span class="comment">// 当该属性有值，且在相应的proxyMap中存在代理对象时，说明target已经是一个proxy了</span></span><br><span class="line">      <span class="comment">// __v_raw 属性对应的值为target本身</span></span><br><span class="line">      key === <span class="title class_">ReactiveFlags</span>.<span class="property">RAW</span> &amp;&amp;</span><br><span class="line">      receiver ===</span><br><span class="line">        (isReadonly</span><br><span class="line">          ? shallow</span><br><span class="line">            ? shallowReadonlyMap</span><br><span class="line">            : readonlyMap</span><br><span class="line">          : shallow</span><br><span class="line">          ? shallowReactiveMap</span><br><span class="line">          : reactiveMap</span><br><span class="line">        ).<span class="title function_">get</span>(target)</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> targetIsArray = <span class="title function_">isArray</span>(target);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对数组的几个方法进行代理，在&#x27;includes&#x27;, &#x27;indexOf&#x27;, &#x27;lastIndexOf&#x27;等方法中进行track捕获依赖</span></span><br><span class="line">    <span class="keyword">if</span> (!isReadonly &amp;&amp; targetIsArray &amp;&amp; <span class="title function_">hasOwn</span>(arrayInstrumentations, key)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(arrayInstrumentations, key, receiver);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isSymbol</span>(key) ? builtInSymbols.<span class="title function_">has</span>(key) : <span class="title function_">isNonTrackableKeys</span>(key)) &#123;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不是readonly，则捕获依赖，因此，readonly 为非响应式的</span></span><br><span class="line">    <span class="keyword">if</span> (!isReadonly) &#123;</span><br><span class="line">      <span class="title function_">track</span>(target, <span class="title class_">TrackOpTypes</span>.<span class="property">GET</span>, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shallow) &#123;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果get到的值是一个Ref，会直接解包，无需再使用 .value 来获取真正需要的值</span></span><br><span class="line">    <span class="comment">// 除非目标对象target是数组，或者当前的key是整数</span></span><br><span class="line">    <span class="comment">// 例如，obj[0]，即使是一个Ref也不会直接解包，使用的时候依然要 obj[0].value</span></span><br><span class="line">    <span class="comment">// shallow没有走到这一步，因此也不会自动解包</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isRef</span>(res)) &#123;</span><br><span class="line">      <span class="comment">// ref unwrapping - skip unwrap for Array + integer key.</span></span><br><span class="line">      <span class="keyword">return</span> targetIsArray &amp;&amp; <span class="title function_">isIntegerKey</span>(key) ? res : res.<span class="property">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当get到的值是对象时，根据是否是readonly来递归操作，需要防止对象循环引用</span></span><br><span class="line">    <span class="comment">// shallow没有走到这一步，因此shallow是浅层的</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isObject</span>(res)) &#123;</span><br><span class="line">      <span class="comment">// Convert returned value into a proxy as well. we do the isObject check</span></span><br><span class="line">      <span class="comment">// here to avoid invalid value warning. Also need to lazy access readonly</span></span><br><span class="line">      <span class="comment">// and reactive here to avoid circular dependency.</span></span><br><span class="line">      <span class="keyword">return</span> isReadonly ? <span class="title function_">readonly</span>(res) : <span class="title function_">reactive</span>(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-set"><a href="#2-set" class="headerlink" title="(2) set"></a>(2) <code>set</code></h5><p>对于<code>reactive</code>，可以说最主要的任务就是在<code>set</code>中触发更新，<code>set</code>包括 新增 和 修改 属性值。如果当前的<code>key</code>对应的值是一个<code>Ref</code>，且其它条件满足时，则触发更新的操作是在<code>Ref</code>的内部。这些在后续讲解<code>Ref</code>的时候会提到。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createSetter</span>(<span class="params">shallow = <span class="literal">false</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">set</span>(<span class="params"></span></span><br><span class="line"><span class="params">    target: <span class="built_in">object</span>,</span></span><br><span class="line"><span class="params">    key: <span class="built_in">string</span> | <span class="built_in">symbol</span>,</span></span><br><span class="line"><span class="params">    value: <span class="built_in">unknown</span>,</span></span><br><span class="line"><span class="params">    receiver: <span class="built_in">object</span></span></span><br><span class="line"><span class="params">  </span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> oldValue = (target <span class="keyword">as</span> <span class="built_in">any</span>)[key];</span><br><span class="line">    <span class="comment">// 当前值是Readonly的Ref，而新值不是Ref时，不允许修改</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isReadonly</span>(oldValue) &amp;&amp; <span class="title function_">isRef</span>(oldValue) &amp;&amp; !<span class="title function_">isRef</span>(value)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是深层的修改</span></span><br><span class="line">    <span class="keyword">if</span> (!shallow) &#123;</span><br><span class="line">      <span class="comment">// 解出原本的非proxy值</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="title function_">isShallow</span>(value) &amp;&amp; !<span class="title function_">isReadonly</span>(value)) &#123;</span><br><span class="line">        oldValue = <span class="title function_">toRaw</span>(oldValue);</span><br><span class="line">        value = <span class="title function_">toRaw</span>(value);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 目标对象非数组，当前key的值是Ref而新值不是Ref，则通过 .value 赋值</span></span><br><span class="line">      <span class="comment">// 在Ref内部触发更新</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="title function_">isArray</span>(target) &amp;&amp; <span class="title function_">isRef</span>(oldValue) &amp;&amp; !<span class="title function_">isRef</span>(value)) &#123;</span><br><span class="line">        oldValue.<span class="property">value</span> = value;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 浅层模式下，忽略对象是否是响应式的</span></span><br><span class="line">      <span class="comment">// in shallow mode, objects are set as-is regardless of reactive or not</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 然后是触发更新的部分了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断当前key是否已经存在于target上</span></span><br><span class="line">    <span class="keyword">const</span> hadKey =</span><br><span class="line">      <span class="title function_">isArray</span>(target) &amp;&amp; <span class="title function_">isIntegerKey</span>(key)</span><br><span class="line">        ? <span class="title class_">Number</span>(key) &lt; target.<span class="property">length</span></span><br><span class="line">        : <span class="title function_">hasOwn</span>(target, key);</span><br><span class="line">    <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver);</span><br><span class="line">    <span class="comment">// don&#x27;t trigger if target is something up in the prototype chain of original</span></span><br><span class="line">    <span class="comment">// 如果是原型链上的字段则不会触发更新</span></span><br><span class="line">    <span class="keyword">if</span> (target === <span class="title function_">toRaw</span>(receiver)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!hadKey) &#123;</span><br><span class="line">        <span class="comment">// 当前的key已经存在，触发新增的更新</span></span><br><span class="line">        <span class="title function_">trigger</span>(target, <span class="title class_">TriggerOpTypes</span>.<span class="property">ADD</span>, key, value);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">hasChanged</span>(value, oldValue)) &#123;</span><br><span class="line">        <span class="comment">// 当前key不存在，触发修改的更新</span></span><br><span class="line">        <span class="title function_">trigger</span>(target, <span class="title class_">TriggerOpTypes</span>.<span class="property">SET</span>, key, value, oldValue);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-deleteProperty"><a href="#3-deleteProperty" class="headerlink" title="(3) deleteProperty"></a>(3) <code>deleteProperty</code></h5><p>删除操作的代理程序，和<code>set</code>一样，<code>deleteProperty</code>拦截<code>delete</code>和<code>Reflect.deleteProperty()</code>操作，它也能触发更新。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deleteProperty</span>(<span class="params">target: <span class="built_in">object</span>, key: <span class="built_in">string</span> | <span class="built_in">symbol</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> hadKey = <span class="title function_">hasOwn</span>(target, key);</span><br><span class="line">  <span class="keyword">const</span> oldValue = (target <span class="keyword">as</span> <span class="built_in">any</span>)[key];</span><br><span class="line">  <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target, key);</span><br><span class="line">  <span class="comment">// 删除成功 且 target中原来有这个属性时，触发删除的更新</span></span><br><span class="line">  <span class="keyword">if</span> (result &amp;&amp; hadKey) &#123;</span><br><span class="line">    <span class="title function_">trigger</span>(target, <span class="title class_">TriggerOpTypes</span>.<span class="property">DELETE</span>, key, <span class="literal">undefined</span>, oldValue);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-has"><a href="#4-has" class="headerlink" title="(4) has"></a>(4) <code>has</code></h5><p><code>has</code>用于判断<code>target</code>中是否有当前的<code>key</code>，拦截<code>a in obj</code>、<code>with(obj)&#123;(a)&#125;</code>、<code>Reflect.has</code>等操作，属于访问程序，在其中进行<code>has</code>操作的依赖收集。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">has</span>(<span class="params">target: <span class="built_in">object</span>, key: <span class="built_in">string</span> | <span class="built_in">symbol</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">has</span>(target, key);</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">isSymbol</span>(key) || !builtInSymbols.<span class="title function_">has</span>(key)) &#123;</span><br><span class="line">    <span class="title function_">track</span>(target, <span class="title class_">TrackOpTypes</span>.<span class="property">HAS</span>, key);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-ownKeys"><a href="#5-ownKeys" class="headerlink" title="(5) ownKeys"></a>(5) <code>ownKeys</code></h5><p>用于获取<code>target</code>所有自身拥有的<code>key</code>，拦截<code>Object.getOwnPropertyNames</code>、<code>Object.getOwnPropertySymbols</code>、<code>Object.keys</code>、<code>Reflect.ownKeys</code>，属于访问程序，在其中进行迭代的依赖收集。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ownKeys</span>(<span class="params">target: <span class="built_in">object</span></span>): (<span class="built_in">string</span> | <span class="built_in">symbol</span>)[] &#123;</span><br><span class="line">  <span class="title function_">track</span>(target, <span class="title class_">TrackOpTypes</span>.<span class="property">ITERATE</span>, <span class="title function_">isArray</span>(target) ? <span class="string">&quot;length&quot;</span> : <span class="variable constant_">ITERATE_KEY</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们算是都弄明白了，对于普通对象和数组，<code>reactive</code>创建<code>proxy</code>，通过<code>get</code>、<code>set</code>、<code>deleteProperty</code>、<code>has</code>、<code>ownKeys</code>五个代理处理程序，来拦截其属性访问操作，在其中进行依赖收集，拦截其增删改操作，其中触发更新。</p><h4 id="1-2-readonly"><a href="#1-2-readonly" class="headerlink" title="1.2 readonly"></a>1.2 <code>readonly</code></h4><p><code>readonly</code>的代理处理程序只有三个：</p><ul><li><code>get</code>：由<code>createGetter(true)</code>创建，还记得我们上面讲到的<code>createSetter</code>吗？</li><li><code>set</code></li><li><code>deleteProperty</code>：这两个代理处理程序用于告警，毕竟<code>readonly</code>不可修改。</li></ul><p>毕加思索一下<code>createGetter(true)</code>，传入的<code>readonly=true</code>，使得<code>get</code>中不会进行<code>track</code>操作来收集依赖，因而不具有响应性。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> readonlyGet = <span class="comment">/*#__PURE__*/</span> <span class="title function_">createGetter</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">readonlyHandlers</span>: <span class="title class_">ProxyHandler</span>&lt;<span class="built_in">object</span>&gt; = &#123;</span><br><span class="line">  <span class="attr">get</span>: readonlyGet,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      <span class="title function_">warn</span>(</span><br><span class="line">        <span class="string">`Set operation on key &quot;<span class="subst">$&#123;<span class="built_in">String</span>(key)&#125;</span>&quot; failed: target is readonly.`</span>,</span><br><span class="line">        target</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">deleteProperty</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      <span class="title function_">warn</span>(</span><br><span class="line">        <span class="string">`Delete operation on key &quot;<span class="subst">$&#123;<span class="built_in">String</span>(key)&#125;</span>&quot; failed: target is readonly.`</span>,</span><br><span class="line">        target</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="1-3-shallowReactive"><a href="#1-3-shallowReactive" class="headerlink" title="1.3 shallowReactive"></a>1.3 <code>shallowReactive</code></h4><p><code>shallowReactive</code>移植了<code>reactive</code>的<code>baseHandlers</code>，并且更新了<code>get</code>和<code>set</code>。具体实现也可以回顾上面说到的<code>createGetter</code>和<code>createSetter</code>。</p><p>回过头来看看<code>createGetter(false, true)</code>，<code>isReadonly = false</code>，则在<code>get</code>中，可以进行<code>track</code>依赖收集；<code>shallow = true</code>，则在<code>get</code>中不会对顶层的<code>Ref</code>进行解包，也不会进行递归操作。</p><p>而在<code>createSetter(true)</code>中，参数<code>shallow</code>几乎只影响是否要解出原本的<code>raw</code>值。如果新值<code>value</code>不是浅层且不是只读的，则需要解出它的原本<code>raw</code>值，之后才能进行赋值操作，否则我们的<code>shallowRef</code>将不再是浅层的了。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shallowGet = <span class="comment">/*#__PURE__*/</span> <span class="title function_">createGetter</span>(<span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">const</span> shallowSet = <span class="comment">/*#__PURE__*/</span> <span class="title function_">createSetter</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> shallowReactiveHandlers = <span class="comment">/*#__PURE__*/</span> <span class="title function_">extend</span>(</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">  mutableHandlers,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">get</span>: shallowGet,</span><br><span class="line">    <span class="attr">set</span>: shallowSet,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="1-4-shallowReadonly"><a href="#1-4-shallowReadonly" class="headerlink" title="1.4 shallowReadonly"></a>1.4 <code>shallowReadonly</code></h4><p>移植了<code>readonly</code>的<code>baseHandlers</code>，更新了其中的<code>get</code>，这个<code>get</code>也试试由<code>createGetter</code>创建。我们知道，<code>readonly</code>的<code>baseHandlers</code>里，除了<code>get</code>，另外俩都是用来拦截修改操作并告警的。</p><p>回顾一下<code>createGetter</code>，当<code>isReadonly===true</code>时，不会进行<code>track</code>操作来收集依赖；<code>shallow===true</code>时，不会对<code>Ref</code>进行解包，也不会走到递归环节，即是浅层的<code>readonly</code>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shallowReadonlyGet = <span class="comment">/*#__PURE__*/</span> <span class="title function_">createGetter</span>(<span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Props handlers are special in the sense that it should not unwrap top-level</span></span><br><span class="line"><span class="comment">// refs (in order to allow refs to be explicitly passed down), but should</span></span><br><span class="line"><span class="comment">// retain the reactivity of the normal readonly object.</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> shallowReadonlyHandlers = <span class="comment">/*#__PURE__*/</span> <span class="title function_">extend</span>(</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">  readonlyHandlers,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">get</span>: shallowReadonlyGet,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="2-cellectionHandlers"><a href="#2-cellectionHandlers" class="headerlink" title="2. cellectionHandlers"></a>2. <code>cellectionHandlers</code></h3><p>对于<code>Set</code>和<code>Map</code>较为复杂的数据结构，他们有自己的方法，因此代理程序会有些差别。基本都是拦截它们原本的方法，然后进行<code>track</code>或<code>trigger</code>。可以看到这几个<code>handlers</code>中，都只有由<code>createInstrumentationGetter</code>创建的<code>get</code>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">mutableCollectionHandlers</span>: <span class="title class_">ProxyHandler</span>&lt;<span class="title class_">CollectionTypes</span>&gt; = &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="comment">/*#__PURE__*/</span> <span class="title function_">createInstrumentationGetter</span>(<span class="literal">false</span>, <span class="literal">false</span>),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">shallowCollectionHandlers</span>: <span class="title class_">ProxyHandler</span>&lt;<span class="title class_">CollectionTypes</span>&gt; = &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="comment">/*#__PURE__*/</span> <span class="title function_">createInstrumentationGetter</span>(<span class="literal">false</span>, <span class="literal">true</span>),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">readonlyCollectionHandlers</span>: <span class="title class_">ProxyHandler</span>&lt;<span class="title class_">CollectionTypes</span>&gt; = &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="comment">/*#__PURE__*/</span> <span class="title function_">createInstrumentationGetter</span>(<span class="literal">true</span>, <span class="literal">false</span>),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">shallowReadonlyCollectionHandlers</span>: <span class="title class_">ProxyHandler</span>&lt;<span class="title class_">CollectionTypes</span>&gt; =</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="comment">/*#__PURE__*/</span> <span class="title function_">createInstrumentationGetter</span>(<span class="literal">true</span>, <span class="literal">true</span>),</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><h4 id="1-1-createInstrumentationGetter"><a href="#1-1-createInstrumentationGetter" class="headerlink" title="1.1 createInstrumentationGetter"></a>1.1 <code>createInstrumentationGetter</code></h4><p>因为是代理<code>Set</code>和<code>Map</code>，在拦截它们的实例方法之前，对实例的访问，即<code>get</code>，这个<code>get</code>并非<code>Map</code>或<code>Set</code>实例的<code>get</code>方法，而是表示对实例的访问操作。例如：<code>const map = new Map([[&#39;name&#39;, &#39;cc&#39;]]); map.set(&#39;age&#39;, 18);</code>。这里<code>map.set()</code>首先就是访问<code>map</code>的<code>set</code>方法，对应的<code>key</code>就是字符串<code>&#39;set&#39;</code>，而这一步就会被代理的<code>get</code>程序拦截，而真正的对方法的拦截，都在相应的<code>instrumentations</code>里预设好了。拦截了之后，如果<code>key</code>在<code>instrumentations</code>里存在，返回预设的方法，在其中进行<code>track</code>和<code>trigger</code>操作，否则是其它属性/方法，直接返回即可，不会进行<code>track</code>和<code>trigger</code>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [</span><br><span class="line">  mutableInstrumentations,</span><br><span class="line">  readonlyInstrumentations,</span><br><span class="line">  shallowInstrumentations,</span><br><span class="line">  shallowReadonlyInstrumentations,</span><br><span class="line">] = <span class="comment">/* #__PURE__*/</span> <span class="title function_">createInstrumentations</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createInstrumentationGetter</span>(<span class="params">isReadonly: <span class="built_in">boolean</span>, shallow: <span class="built_in">boolean</span></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> instrumentations = shallow</span><br><span class="line">    ? isReadonly</span><br><span class="line">      ? shallowReadonlyInstrumentations</span><br><span class="line">      : shallowInstrumentations</span><br><span class="line">    : isReadonly</span><br><span class="line">    ? readonlyInstrumentations</span><br><span class="line">    : mutableInstrumentations;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    target: CollectionTypes,</span></span></span><br><span class="line"><span class="params"><span class="function">    key: <span class="built_in">string</span> | <span class="built_in">symbol</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    receiver: CollectionTypes</span></span></span><br><span class="line"><span class="params"><span class="function">  </span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key === <span class="title class_">ReactiveFlags</span>.<span class="property">IS_REACTIVE</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> !isReadonly;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="title class_">ReactiveFlags</span>.<span class="property">IS_READONLY</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> isReadonly;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="title class_">ReactiveFlags</span>.<span class="property">RAW</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(</span><br><span class="line">      <span class="title function_">hasOwn</span>(instrumentations, key) &amp;&amp; key <span class="keyword">in</span> target</span><br><span class="line">        ? instrumentations</span><br><span class="line">        : target,</span><br><span class="line">      key,</span><br><span class="line">      receiver</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-instrumentations"><a href="#1-2-instrumentations" class="headerlink" title="1.2 instrumentations"></a>1.2 <code>instrumentations</code></h3><p>和<code>baseHandlers</code>相比，<code>Proxy</code>无法直接拦截<code>Map</code>和<code>Set</code>的方法的调用，而是通过<code>get</code>程序来拦截，再判断<code>key</code>是否为执行增删改查的方法，从而判断是否进行依赖收集或更新。因此，就需要先预设好，哪些<code>key</code>作为方法名时可以触发<code>track</code>和<code>trigger</code>。其实也就是<code>Map</code>和<code>Set</code>的那些实例方法和迭代器方法。而各种<code>Instrumentations</code>，就是这些预设的方法，<code>track</code>和<code>trigger</code>操作都在其中。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createInstrumentations</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 对应reactive</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">mutableInstrumentations</span>: <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="title class_">Function</span>&gt; = &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"><span class="variable language_">this</span>: MapTypes, key: <span class="built_in">unknown</span></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">get</span>(<span class="variable language_">this</span>, key);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">size</span>() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">size</span>(<span class="variable language_">this</span> <span class="keyword">as</span> <span class="built_in">unknown</span> <span class="keyword">as</span> <span class="title class_">IterableCollections</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    has,</span><br><span class="line">    add,</span><br><span class="line">    set,</span><br><span class="line">    <span class="attr">delete</span>: deleteEntry,</span><br><span class="line">    clear,</span><br><span class="line">    <span class="attr">forEach</span>: <span class="title function_">createForEach</span>(<span class="literal">false</span>, <span class="literal">false</span>),</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对应shallowReactive</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">shallowInstrumentations</span>: <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="title class_">Function</span>&gt; = &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"><span class="variable language_">this</span>: MapTypes, key: <span class="built_in">unknown</span></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">get</span>(<span class="variable language_">this</span>, key, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">size</span>() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">size</span>(<span class="variable language_">this</span> <span class="keyword">as</span> <span class="built_in">unknown</span> <span class="keyword">as</span> <span class="title class_">IterableCollections</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    has,</span><br><span class="line">    add,</span><br><span class="line">    set,</span><br><span class="line">    <span class="attr">delete</span>: deleteEntry,</span><br><span class="line">    clear,</span><br><span class="line">    <span class="attr">forEach</span>: <span class="title function_">createForEach</span>(<span class="literal">false</span>, <span class="literal">true</span>),</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对应readonly</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">readonlyInstrumentations</span>: <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="title class_">Function</span>&gt; = &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"><span class="variable language_">this</span>: MapTypes, key: <span class="built_in">unknown</span></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">get</span>(<span class="variable language_">this</span>, key, <span class="literal">true</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">size</span>() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">size</span>(<span class="variable language_">this</span> <span class="keyword">as</span> <span class="built_in">unknown</span> <span class="keyword">as</span> <span class="title class_">IterableCollections</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">has</span>(<span class="params"><span class="variable language_">this</span>: MapTypes, key: <span class="built_in">unknown</span></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> has.<span class="title function_">call</span>(<span class="variable language_">this</span>, key, <span class="literal">true</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">add</span>: <span class="title function_">createReadonlyMethod</span>(<span class="title class_">TriggerOpTypes</span>.<span class="property">ADD</span>),</span><br><span class="line">    <span class="attr">set</span>: <span class="title function_">createReadonlyMethod</span>(<span class="title class_">TriggerOpTypes</span>.<span class="property">SET</span>),</span><br><span class="line">    <span class="attr">delete</span>: <span class="title function_">createReadonlyMethod</span>(<span class="title class_">TriggerOpTypes</span>.<span class="property">DELETE</span>),</span><br><span class="line">    <span class="attr">clear</span>: <span class="title function_">createReadonlyMethod</span>(<span class="title class_">TriggerOpTypes</span>.<span class="property">CLEAR</span>),</span><br><span class="line">    <span class="attr">forEach</span>: <span class="title function_">createForEach</span>(<span class="literal">true</span>, <span class="literal">false</span>),</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对应shallowReadonly</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">shallowReadonlyInstrumentations</span>: <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="title class_">Function</span>&gt; = &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"><span class="variable language_">this</span>: MapTypes, key: <span class="built_in">unknown</span></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">get</span>(<span class="variable language_">this</span>, key, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">size</span>() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">size</span>(<span class="variable language_">this</span> <span class="keyword">as</span> <span class="built_in">unknown</span> <span class="keyword">as</span> <span class="title class_">IterableCollections</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">has</span>(<span class="params"><span class="variable language_">this</span>: MapTypes, key: <span class="built_in">unknown</span></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> has.<span class="title function_">call</span>(<span class="variable language_">this</span>, key, <span class="literal">true</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">add</span>: <span class="title function_">createReadonlyMethod</span>(<span class="title class_">TriggerOpTypes</span>.<span class="property">ADD</span>),</span><br><span class="line">    <span class="attr">set</span>: <span class="title function_">createReadonlyMethod</span>(<span class="title class_">TriggerOpTypes</span>.<span class="property">SET</span>),</span><br><span class="line">    <span class="attr">delete</span>: <span class="title function_">createReadonlyMethod</span>(<span class="title class_">TriggerOpTypes</span>.<span class="property">DELETE</span>),</span><br><span class="line">    <span class="attr">clear</span>: <span class="title function_">createReadonlyMethod</span>(<span class="title class_">TriggerOpTypes</span>.<span class="property">CLEAR</span>),</span><br><span class="line">    <span class="attr">forEach</span>: <span class="title function_">createForEach</span>(<span class="literal">true</span>, <span class="literal">true</span>),</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用 createIterableMethod 给这些 Instrumentations 挂上几个迭代器</span></span><br><span class="line">  <span class="keyword">const</span> iteratorMethods = [<span class="string">&quot;keys&quot;</span>, <span class="string">&quot;values&quot;</span>, <span class="string">&quot;entries&quot;</span>, <span class="title class_">Symbol</span>.<span class="property">iterator</span>];</span><br><span class="line">  iteratorMethods.<span class="title function_">forEach</span>(<span class="function">(<span class="params">method</span>) =&gt;</span> &#123;</span><br><span class="line">    mutableInstrumentations[method <span class="keyword">as</span> <span class="built_in">string</span>] = <span class="title function_">createIterableMethod</span>(</span><br><span class="line">      method,</span><br><span class="line">      <span class="literal">false</span>,</span><br><span class="line">      <span class="literal">false</span></span><br><span class="line">    );</span><br><span class="line">    readonlyInstrumentations[method <span class="keyword">as</span> <span class="built_in">string</span>] = <span class="title function_">createIterableMethod</span>(</span><br><span class="line">      method,</span><br><span class="line">      <span class="literal">true</span>,</span><br><span class="line">      <span class="literal">false</span></span><br><span class="line">    );</span><br><span class="line">    shallowInstrumentations[method <span class="keyword">as</span> <span class="built_in">string</span>] = <span class="title function_">createIterableMethod</span>(</span><br><span class="line">      method,</span><br><span class="line">      <span class="literal">false</span>,</span><br><span class="line">      <span class="literal">true</span></span><br><span class="line">    );</span><br><span class="line">    shallowReadonlyInstrumentations[method <span class="keyword">as</span> <span class="built_in">string</span>] = <span class="title function_">createIterableMethod</span>(</span><br><span class="line">      method,</span><br><span class="line">      <span class="literal">true</span>,</span><br><span class="line">      <span class="literal">true</span></span><br><span class="line">    );</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [</span><br><span class="line">    mutableInstrumentations,</span><br><span class="line">    readonlyInstrumentations,</span><br><span class="line">    shallowInstrumentations,</span><br><span class="line">    shallowReadonlyInstrumentations,</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数<code>createInstrumentations</code>分为两部分，前部分是利用已有的<code>get</code>、<code>set</code>、<code>add</code>、<code>has</code>、<code>clear</code>等等来得到各个<code>instrumentations</code>，后部分是对各个<code>instrumentations</code>中的迭代方法的更新。只要不是<code>isReadonly</code>不是真值，则无论是<code>get</code>、<code>set</code>等方法还是<code>keys</code>、<code>values</code>等迭代器接口，都在内部进行了<code>track</code>或<code>trigger</code>，当然，<code>get</code>、<code>has</code>、<code>size</code>等方法 和 几个迭代器方法都属于访问操作，因此内部是使用<code>track</code>来收集依赖，而<code>trigger</code>发生在增、删、改操作里，当然，也要根据<code>isReadonly</code>和<code>shallow</code>有所区分，思路基本和<code>baseHandlers</code>一致。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">get</span>(<span class="params"></span></span><br><span class="line"><span class="params">  target: MapTypes,</span></span><br><span class="line"><span class="params">  key: <span class="built_in">unknown</span>,</span></span><br><span class="line"><span class="params">  isReadonly = <span class="literal">false</span>,</span></span><br><span class="line"><span class="params">  isShallow = <span class="literal">false</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// #1772: readonly(reactive(Map)) should return readonly + reactive version</span></span><br><span class="line">  <span class="comment">// of the value</span></span><br><span class="line">  target = (target <span class="keyword">as</span> <span class="built_in">any</span>)[<span class="title class_">ReactiveFlags</span>.<span class="property">RAW</span>];</span><br><span class="line">  <span class="keyword">const</span> rawTarget = <span class="title function_">toRaw</span>(target);</span><br><span class="line">  <span class="keyword">const</span> rawKey = <span class="title function_">toRaw</span>(key);</span><br><span class="line">  <span class="keyword">if</span> (!isReadonly) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key !== rawKey) &#123;</span><br><span class="line">      <span class="title function_">track</span>(rawTarget, <span class="title class_">TrackOpTypes</span>.<span class="property">GET</span>, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">track</span>(rawTarget, <span class="title class_">TrackOpTypes</span>.<span class="property">GET</span>, rawKey);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> &#123; has &#125; = <span class="title function_">getProto</span>(rawTarget);</span><br><span class="line">  <span class="keyword">const</span> wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;</span><br><span class="line">  <span class="keyword">if</span> (has.<span class="title function_">call</span>(rawTarget, key)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">wrap</span>(target.<span class="title function_">get</span>(key));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (has.<span class="title function_">call</span>(rawTarget, rawKey)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">wrap</span>(target.<span class="title function_">get</span>(rawKey));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target !== rawTarget) &#123;</span><br><span class="line">    <span class="comment">// #3602 readonly(reactive(Map))</span></span><br><span class="line">    <span class="comment">// ensure that the nested reactive `Map` can do tracking for itself</span></span><br><span class="line">    target.<span class="title function_">get</span>(key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">has</span>(<span class="params"><span class="variable language_">this</span>: CollectionTypes, key: <span class="built_in">unknown</span>, isReadonly = <span class="literal">false</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> target = (<span class="variable language_">this</span> <span class="keyword">as</span> <span class="built_in">any</span>)[<span class="title class_">ReactiveFlags</span>.<span class="property">RAW</span>];</span><br><span class="line">  <span class="keyword">const</span> rawTarget = <span class="title function_">toRaw</span>(target);</span><br><span class="line">  <span class="keyword">const</span> rawKey = <span class="title function_">toRaw</span>(key);</span><br><span class="line">  <span class="keyword">if</span> (!isReadonly) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key !== rawKey) &#123;</span><br><span class="line">      <span class="title function_">track</span>(rawTarget, <span class="title class_">TrackOpTypes</span>.<span class="property">HAS</span>, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">track</span>(rawTarget, <span class="title class_">TrackOpTypes</span>.<span class="property">HAS</span>, rawKey);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> key === rawKey</span><br><span class="line">    ? target.<span class="title function_">has</span>(key)</span><br><span class="line">    : target.<span class="title function_">has</span>(key) || target.<span class="title function_">has</span>(rawKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">size</span>(<span class="params">target: IterableCollections, isReadonly = <span class="literal">false</span></span>) &#123;</span><br><span class="line">  target = (target <span class="keyword">as</span> <span class="built_in">any</span>)[<span class="title class_">ReactiveFlags</span>.<span class="property">RAW</span>];</span><br><span class="line">  !isReadonly &amp;&amp; <span class="title function_">track</span>(<span class="title function_">toRaw</span>(target), <span class="title class_">TrackOpTypes</span>.<span class="property">ITERATE</span>, <span class="variable constant_">ITERATE_KEY</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, <span class="string">&quot;size&quot;</span>, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"><span class="variable language_">this</span>: SetTypes, value: <span class="built_in">unknown</span></span>) &#123;</span><br><span class="line">  value = <span class="title function_">toRaw</span>(value);</span><br><span class="line">  <span class="keyword">const</span> target = <span class="title function_">toRaw</span>(<span class="variable language_">this</span>);</span><br><span class="line">  <span class="keyword">const</span> proto = <span class="title function_">getProto</span>(target);</span><br><span class="line">  <span class="keyword">const</span> hadKey = proto.<span class="property">has</span>.<span class="title function_">call</span>(target, value);</span><br><span class="line">  <span class="keyword">if</span> (!hadKey) &#123;</span><br><span class="line">    target.<span class="title function_">add</span>(value);</span><br><span class="line">    <span class="title function_">trigger</span>(target, <span class="title class_">TriggerOpTypes</span>.<span class="property">ADD</span>, value, value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">set</span>(<span class="params"><span class="variable language_">this</span>: MapTypes, key: <span class="built_in">unknown</span>, value: <span class="built_in">unknown</span></span>) &#123;</span><br><span class="line">  value = <span class="title function_">toRaw</span>(value);</span><br><span class="line">  <span class="keyword">const</span> target = <span class="title function_">toRaw</span>(<span class="variable language_">this</span>);</span><br><span class="line">  <span class="keyword">const</span> &#123; has, get &#125; = <span class="title function_">getProto</span>(target);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> hadKey = has.<span class="title function_">call</span>(target, key);</span><br><span class="line">  <span class="keyword">if</span> (!hadKey) &#123;</span><br><span class="line">    key = <span class="title function_">toRaw</span>(key);</span><br><span class="line">    hadKey = has.<span class="title function_">call</span>(target, key);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">    <span class="title function_">checkIdentityKeys</span>(target, has, key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> oldValue = get.<span class="title function_">call</span>(target, key);</span><br><span class="line">  target.<span class="title function_">set</span>(key, value);</span><br><span class="line">  <span class="keyword">if</span> (!hadKey) &#123;</span><br><span class="line">    <span class="title function_">trigger</span>(target, <span class="title class_">TriggerOpTypes</span>.<span class="property">ADD</span>, key, value);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">hasChanged</span>(value, oldValue)) &#123;</span><br><span class="line">    <span class="title function_">trigger</span>(target, <span class="title class_">TriggerOpTypes</span>.<span class="property">SET</span>, key, value, oldValue);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deleteEntry</span>(<span class="params"><span class="variable language_">this</span>: CollectionTypes, key: <span class="built_in">unknown</span></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> target = <span class="title function_">toRaw</span>(<span class="variable language_">this</span>);</span><br><span class="line">  <span class="keyword">const</span> &#123; has, get &#125; = <span class="title function_">getProto</span>(target);</span><br><span class="line">  <span class="keyword">let</span> hadKey = has.<span class="title function_">call</span>(target, key);</span><br><span class="line">  <span class="keyword">if</span> (!hadKey) &#123;</span><br><span class="line">    key = <span class="title function_">toRaw</span>(key);</span><br><span class="line">    hadKey = has.<span class="title function_">call</span>(target, key);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">    <span class="title function_">checkIdentityKeys</span>(target, has, key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> oldValue = get ? get.<span class="title function_">call</span>(target, key) : <span class="literal">undefined</span>;</span><br><span class="line">  <span class="comment">// forward the operation before queueing reactions</span></span><br><span class="line">  <span class="keyword">const</span> result = target.<span class="title function_">delete</span>(key);</span><br><span class="line">  <span class="keyword">if</span> (hadKey) &#123;</span><br><span class="line">    <span class="title function_">trigger</span>(target, <span class="title class_">TriggerOpTypes</span>.<span class="property">DELETE</span>, key, <span class="literal">undefined</span>, oldValue);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">clear</span>(<span class="params"><span class="variable language_">this</span>: IterableCollections</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> target = <span class="title function_">toRaw</span>(<span class="variable language_">this</span>);</span><br><span class="line">  <span class="keyword">const</span> hadItems = target.<span class="property">size</span> !== <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> oldTarget = __DEV__</span><br><span class="line">    ? <span class="title function_">isMap</span>(target)</span><br><span class="line">      ? <span class="keyword">new</span> <span class="title class_">Map</span>(target)</span><br><span class="line">      : <span class="keyword">new</span> <span class="title class_">Set</span>(target)</span><br><span class="line">    : <span class="literal">undefined</span>;</span><br><span class="line">  <span class="comment">// forward the operation before queueing reactions</span></span><br><span class="line">  <span class="keyword">const</span> result = target.<span class="title function_">clear</span>();</span><br><span class="line">  <span class="keyword">if</span> (hadItems) &#123;</span><br><span class="line">    <span class="title function_">trigger</span>(target, <span class="title class_">TriggerOpTypes</span>.<span class="property">CLEAR</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, oldTarget);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-createIterableMethod"><a href="#1-3-createIterableMethod" class="headerlink" title="1.3 createIterableMethod"></a>1.3 <code>createIterableMethod</code></h3><p>这里稍微提一下<code>createIterableMethod</code>，用于利用<code>Map</code>和<code>Set</code>本身的迭代器方法，并做了一点修改，在其中加入了<code>track</code>来收集依赖。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createIterableMethod</span>(<span class="params"></span></span><br><span class="line"><span class="params">  method: <span class="built_in">string</span> | <span class="built_in">symbol</span>,</span></span><br><span class="line"><span class="params">  isReadonly: <span class="built_in">boolean</span>,</span></span><br><span class="line"><span class="params">  isShallow: <span class="built_in">boolean</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span></span><br><span class="line"><span class="params">    <span class="variable language_">this</span>: IterableCollections,</span></span><br><span class="line"><span class="params">    ...args: <span class="built_in">unknown</span>[]</span></span><br><span class="line"><span class="params">  </span>): <span class="title class_">Iterable</span> &amp; <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> target = (<span class="variable language_">this</span> <span class="keyword">as</span> <span class="built_in">any</span>)[<span class="title class_">ReactiveFlags</span>.<span class="property">RAW</span>];</span><br><span class="line">    <span class="keyword">const</span> rawTarget = <span class="title function_">toRaw</span>(target);</span><br><span class="line">    <span class="keyword">const</span> targetIsMap = <span class="title function_">isMap</span>(rawTarget);</span><br><span class="line">    <span class="keyword">const</span> isPair =</span><br><span class="line">      method === <span class="string">&quot;entries&quot;</span> || (method === <span class="title class_">Symbol</span>.<span class="property">iterator</span> &amp;&amp; targetIsMap);</span><br><span class="line">    <span class="keyword">const</span> isKeyOnly = method === <span class="string">&quot;keys&quot;</span> &amp;&amp; targetIsMap;</span><br><span class="line">    <span class="keyword">const</span> innerIterator = target[method](...args);</span><br><span class="line">    <span class="keyword">const</span> wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;</span><br><span class="line">    !isReadonly &amp;&amp;</span><br><span class="line">      <span class="title function_">track</span>(</span><br><span class="line">        rawTarget,</span><br><span class="line">        <span class="title class_">TrackOpTypes</span>.<span class="property">ITERATE</span>,</span><br><span class="line">        isKeyOnly ? <span class="variable constant_">MAP_KEY_ITERATE_KEY</span> : <span class="variable constant_">ITERATE_KEY</span></span><br><span class="line">      );</span><br><span class="line">    <span class="comment">// return a wrapped iterator which returns observed versions of the</span></span><br><span class="line">    <span class="comment">// values emitted from the real iterator</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// iterator protocol</span></span><br><span class="line">      <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; value, done &#125; = innerIterator.<span class="title function_">next</span>();</span><br><span class="line">        <span class="keyword">return</span> done</span><br><span class="line">          ? &#123; value, done &#125;</span><br><span class="line">          : &#123;</span><br><span class="line">              <span class="attr">value</span>: isPair ? [<span class="title function_">wrap</span>(value[<span class="number">0</span>]), <span class="title function_">wrap</span>(value[<span class="number">1</span>])] : <span class="title function_">wrap</span>(value),</span><br><span class="line">              done,</span><br><span class="line">            &#125;;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// iterable protocol</span></span><br><span class="line">      [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-小结"><a href="#1-4-小结" class="headerlink" title="1.4 小结"></a>1.4 小结</h3><p>分析完各个部分，可以看到，无论是<code>baseHandlers</code>还是<code>collectionHandlers</code>，思路都是一致的。</p><p>但是<code>collectionHandlers</code>只有<code>get</code>这一个代理程序，通过拦截到的<code>key</code>判断是否是<code>Map</code>和<code>Set</code>实例自带的增删改查的方法，从而返回预设好的<code>hack</code>版本的方法或原本的属性值，然后继续后续的操作。在<code>hack</code>版本的方法里进行<code>track</code>和<code>trigger</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前 端 </tag>
            
            <tag> Vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3源码系列 (二) computed</title>
      <link href="/articals/16fef359/"/>
      <url>/articals/16fef359/</url>
      
        <content type="html"><![CDATA[<p>想起上次面试，被问了个古老的问题：<strong>watch 和 computed 的区别</strong>。多少有点感慨，现在已经很少见这种耳熟能详的问题了，网络上八股文不少。今天，我更想分享一下从源码的层面来区别这八竿子打不着的两者。上一篇看了<code>watch</code>的源码，本篇针对<strong>computed</strong>做分析。</p><h2 id="一、类型声明"><a href="#一、类型声明" class="headerlink" title="一、类型声明"></a>一、类型声明</h2><p><code>computed</code>的源码在<code>reactivity/src/computed.ts</code>里，先来看看相关的类型定义：</p><ul><li><code>ComputedRef</code>：调用<code>computed</code>得到的值的类型，继承自<code>WritableComputedRef</code>；</li><li><code>WritableComputedRef</code>：继承自<code>Ref</code>，拓展了一个<code>effect</code>属性；</li><li><code>ComputedGetter</code>：传递给<code>ComputedRef</code>的构造器函数，用于创建<code>effect</code>；</li><li><code>ComputedSetter</code>：传递给<code>ComputedRef</code>的构造器函数，用于在实例的值被更改时，即在<code>set</code>中调用；</li><li><code>WritableComputedOptions</code>：可写的<code>Computed</code>选项，包含<code>get</code>和<code>set</code>，是<code>computed</code>函数接收的参数类型之一。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> <span class="title class_">ComputedRefSymbol</span>: unique <span class="built_in">symbol</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ComputedRef的接口，调用computed()得到一个ComputedRef类型的值</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">ComputedRef</span>&lt;T = <span class="built_in">any</span>&gt; <span class="keyword">extends</span> <span class="title class_">WritableComputedRef</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">value</span>: T;</span><br><span class="line">  [<span class="title class_">ComputedRefSymbol</span>]: <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WritableComputedRef继承了Ref并拓展了一个只读属性effect</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">WritableComputedRef</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Ref</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">effect</span>: <span class="title class_">ReactiveEffect</span>&lt;T&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ComputedGetter 用于创建 effect ， ComputedSetter 对应的值在 ComputedRef 实例中的 set 里调用</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">ComputedGetter</span>&lt;T&gt; = <span class="function">(<span class="params">...args: <span class="built_in">any</span>[]</span>) =&gt;</span> T;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">ComputedSetter</span>&lt;T&gt; = <span class="function">(<span class="params">v: T</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可写的Computed</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">WritableComputedOptions</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="title class_">ComputedGetter</span>&lt;T&gt;;</span><br><span class="line">  <span class="attr">set</span>: <span class="title class_">ComputedSetter</span>&lt;T&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、ComputedRef"><a href="#二、ComputedRef" class="headerlink" title="二、ComputedRef"></a>二、<code>ComputedRef</code></h2><p>而<code>computed()</code>返回一个<code>ComputedRef</code>类型的值，那么这个<code>ComputedRef</code>就至关重要了。从接口声明中可以看出，它继承了<code>Ref</code>，因而其实现也和<code>Ref</code>较为相似：接收<code>getter</code>、<code>setter</code>等，用<code>getter</code>来创建<code>effect</code>，由<code>effect.run()</code>来获取<code>value</code>，在<code>get</code>中返回；而<code>setter</code>在实例的值更改时，即在<code>set</code>中调用。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">ComputedRefImpl</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">// dep: 收集的依赖</span></span><br><span class="line">  <span class="keyword">public</span> dep?: <span class="title class_">Dep</span> = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// getter获取的实际值</span></span><br><span class="line">  <span class="keyword">private</span> _value!: T;</span><br><span class="line">  <span class="comment">// 一个响应式的effect</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">readonly</span> <span class="attr">effect</span>: <span class="title class_">ReactiveEffect</span>&lt;T&gt;;</span><br><span class="line">  <span class="comment">// __v_isRef 提供给 isRef() 判断实例是否为Ref</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">readonly</span> __v_isRef = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">readonly</span> [<span class="title class_">ReactiveFlags</span>.<span class="property">IS_READONLY</span>]: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> _dirty = <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">// 是否可缓存</span></span><br><span class="line">  <span class="keyword">public</span> <span class="attr">_cacheable</span>: <span class="built_in">boolean</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造器接收 getter 和 setter ，是否只读，是否出自 SSR</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    getter: ComputedGetter&lt;T&gt;,</span></span><br><span class="line"><span class="params">    <span class="comment">// 接收只读的私有的 _setter</span></span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> <span class="keyword">readonly</span> _setter: ComputedSetter&lt;T&gt;,</span></span><br><span class="line"><span class="params">    isReadonly: <span class="built_in">boolean</span>,</span></span><br><span class="line"><span class="params">    isSSR: <span class="built_in">boolean</span></span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="comment">// 用传入的 getter 创建一个 effect</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">effect</span> = <span class="keyword">new</span> <span class="title class_">ReactiveEffect</span>(getter, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">_dirty</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_dirty</span> = <span class="literal">true</span>;</span><br><span class="line">        <span class="title function_">triggerRefValue</span>(<span class="variable language_">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 把 effect 的 computed 属性指回 ComputedRef 实例自身</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">effect</span>.<span class="property">computed</span> = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">effect</span>.<span class="property">active</span> = <span class="variable language_">this</span>.<span class="property">_cacheable</span> = !isSSR;</span><br><span class="line">    <span class="variable language_">this</span>[<span class="title class_">ReactiveFlags</span>.<span class="property">IS_READONLY</span>] = isReadonly;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 收集依赖，返回 this._value 的值</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">    <span class="comment">// the computed ref may get wrapped by other proxies e.g. readonly() #3376</span></span><br><span class="line">    <span class="keyword">const</span> self = <span class="title function_">toRaw</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="comment">// 收集Ref</span></span><br><span class="line">    <span class="title function_">trackRefValue</span>(self);</span><br><span class="line">    <span class="keyword">if</span> (self.<span class="property">_dirty</span> || !self.<span class="property">_cacheable</span>) &#123;</span><br><span class="line">      self.<span class="property">_dirty</span> = <span class="literal">false</span>;</span><br><span class="line">      <span class="comment">// effect.run() 会拿到 getter() 的值</span></span><br><span class="line">      <span class="comment">// 即_value的值来自于 effect，或者说来自于传入的 getter 的返回值</span></span><br><span class="line">      self.<span class="property">_value</span> = self.<span class="property">effect</span>.<span class="title function_">run</span>()!;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> self.<span class="property">_value</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当设置ComputedRef的实例的值时，调用传入的_setter</span></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">value</span>(<span class="params">newValue: T</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">_setter</span>(newValue);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、computed"><a href="#三、computed" class="headerlink" title="三、computed"></a>三、<code>computed</code></h2><h3 id="1-computed的重载签名"><a href="#1-computed的重载签名" class="headerlink" title="1. computed的重载签名"></a>1. <code>computed</code>的重载签名</h3><p><strong><code>computed</code>有两个</strong>，主要是接收的第一个参数不同。<strong>一是类型为<code>ComputedGetter</code>的函数<code>getter</code>，该函数返回一个值</strong>；二是类型为<code>WritableComputedOptions</code>的<strong><code>options</code>，它是一个对象，包含<code>get</code>和<code>set</code>两个函数，作用可以大致理解为与属性描述符里的<code>get</code>和<code>set</code>相似</strong>，但不是一回事，只是实现了相似的能力。事实上这个<code>get</code>的作用和第一种重载里的<code>getter</code>完全一致。换句话说，第一种重载没有<code>set</code>只有<code>get</code>，在后续的处理中，会给它包装一个<code>set</code>，只是包装的<code>set</code>只会触发警告。而第二种重载里自带<code>set</code>（由我们写代码时传入），除非我们传入的<code>set</code>是故意用于告警，否则是可以起作用的（通常在其中更新依赖数据的值，尤其是通过<code>emit</code>来告知父组件更新依赖数据）。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> computed&lt;T&gt;(</span><br><span class="line">  <span class="attr">getter</span>: <span class="title class_">ComputedGetter</span>&lt;T&gt;,</span><br><span class="line">  debugOptions?: <span class="title class_">DebuggerOptions</span></span><br><span class="line">): <span class="title class_">ComputedRef</span>&lt;T&gt;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> computed&lt;T&gt;(</span><br><span class="line">  <span class="attr">options</span>: <span class="title class_">WritableComputedOptions</span>&lt;T&gt;,</span><br><span class="line">  debugOptions?: <span class="title class_">DebuggerOptions</span></span><br><span class="line">): <span class="title class_">WritableComputedRef</span>&lt;T&gt;;</span><br></pre></td></tr></table></figure><h3 id="2-computed的实现"><a href="#2-computed的实现" class="headerlink" title="2. computed的实现"></a>2. <code>computed</code>的实现</h3><ul><li>判断我们传入的第一个参数是<code>getter</code>还是<code>options</code>；</li><li>如果是<code>getter</code>，则包装一个<code>setter</code>用于开发环境下告警；</li><li>如果是<code>options</code>，则取出其中的<code>get</code>和<code>set</code>，分别作为<code>getter</code>和<code>setter</code>；</li><li>用<code>getter</code>和<code>setter</code>创建一个<code>ComputedRef</code>实例并返回该实例。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> computed&lt;T&gt;(</span><br><span class="line">  <span class="attr">getterOrOptions</span>: <span class="title class_">ComputedGetter</span>&lt;T&gt; | <span class="title class_">WritableComputedOptions</span>&lt;T&gt;,</span><br><span class="line">  debugOptions?: <span class="title class_">DebuggerOptions</span>,</span><br><span class="line">  isSSR = <span class="literal">false</span></span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">getter</span>: <span class="title class_">ComputedGetter</span>&lt;T&gt;;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">setter</span>: <span class="title class_">ComputedSetter</span>&lt;T&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是getter还是options</span></span><br><span class="line">  <span class="keyword">const</span> onlyGetter = <span class="title function_">isFunction</span>(getterOrOptions);</span><br><span class="line">  <span class="keyword">if</span> (onlyGetter) &#123;</span><br><span class="line">    getter = getterOrOptions;</span><br><span class="line">    <span class="comment">// 包装setter</span></span><br><span class="line">    setter = __DEV__</span><br><span class="line">      ? <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">&quot;Write operation failed: computed value is readonly&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      : <span class="variable constant_">NOOP</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    getter = getterOrOptions.<span class="property">get</span>;</span><br><span class="line">    setter = getterOrOptions.<span class="property">set</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建并返回一个ComputedRef，</span></span><br><span class="line">  <span class="comment">// 第三个参数控制是否是只读的ComputedRef实例</span></span><br><span class="line">  <span class="keyword">const</span> cRef = <span class="keyword">new</span> <span class="title class_">ComputedRefImpl</span>(</span><br><span class="line">    getter,</span><br><span class="line">    setter,</span><br><span class="line">    onlyGetter || !setter,</span><br><span class="line">    isSSR</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 主要是开发环境下调试用</span></span><br><span class="line">  <span class="keyword">if</span> (__DEV__ &amp;&amp; debugOptions &amp;&amp; !isSSR) &#123;</span><br><span class="line">    cRef.<span class="property">effect</span>.<span class="property">onTrack</span> = debugOptions.<span class="property">onTrack</span>;</span><br><span class="line">    cRef.<span class="property">effect</span>.<span class="property">onTrigger</span> = debugOptions.<span class="property">onTrigger</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> cRef <span class="keyword">as</span> <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道，在<code>computed</code>里是不允许异步操作的，但是看完了<code>computed</code>的源码，好像也没发现哪里不允许异步操作。确实，单纯就<code>computed</code>的源码来看，它是允许异步操作的，但是<code>computed</code>作为计算属性，大致上是取<code>getter</code>的返回值，<code>return</code>是等不到异步操作结束的。而禁用异步操作的规定是在<code>eslint-plugin-vue</code>这个包中的<code>lib/rules/no-async-in-computed-properties.js</code>文件里的规定。</p><p>看完这两篇，下次如果还有人问<code>watch</code>和<code>computed</code>的区别这种古董问题，就从源码上逐一比较吧。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前 端 </tag>
            
            <tag> Vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3源码系列 (一) watch</title>
      <link href="/articals/dd689204/"/>
      <url>/articals/dd689204/</url>
      
        <content type="html"><![CDATA[<p>想起上次面试，问了个古老的问题：<strong>watch 和 computed 的区别</strong>。多少有点感慨，现在已经很少见这种耳熟能详的问题了，网络上八股文不少。今天，我更想分享一下从源码的层面来区别这八竿子打不着的两者。本篇针对<strong>watch</strong>做分析，下一篇分析<strong>computed</strong>。</p><h2 id="一、watch参数类型"><a href="#一、watch参数类型" class="headerlink" title="一、watch参数类型"></a>一、<code>watch</code>参数类型</h2><p>我们知道，<code>vue3</code>里的<code>watch</code>接收三个参数：侦听的数据源<code>source</code>、回调<code>cb</code>、以及可选的<code>optiions</code>。</p><h3 id="1-选项options"><a href="#1-选项options" class="headerlink" title="1. 选项options"></a>1. 选项<code>options</code></h3><p>我们可以在<code>options</code>里根据需要设置<strong><code>immediate</code></strong>来控制是否立即执行一次回调；设置<strong><code>deep</code></strong>来控制是否进行深度侦听；设置<strong><code>flush</code></strong>来控制回调的触发时机，默认为<code>&#123; flush: &#39;pre&#39; &#125;</code>，即<code>vue</code>组件更新前；若设置为<code>&#123; flush: &#39;post&#39; &#125;</code>则回调将在<code>vue</code>组件更新之后触发；此外还可以设置为<code>&#123; flush: &#39;sync&#39; &#125;</code>，表示同步触发；以及设置收集依赖时的<code>onTrack</code>和触发更新时的<code>onTrigger</code>两个<code>listener</code>，主要用于<code>debugger</code>。<code>watch</code>函数会返回一个<code>watchStopHandle</code>用于停止侦听。<strong><code>options</code></strong>的类型便是<code>WatchOptions</code>，在源码中的声明如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reactivity/src/effect.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">DebuggerOptions</span> &#123;</span><br><span class="line">  onTrack?: <span class="function">(<span class="params">event: DebuggerEvent</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  onTrigger?: <span class="function">(<span class="params">event: DebuggerEvent</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runtime-core/apiWatch.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">WatchOptionsBase</span> <span class="keyword">extends</span> <span class="title class_">DebuggerOptions</span> &#123;</span><br><span class="line">  flush?: <span class="string">&quot;pre&quot;</span> | <span class="string">&quot;post&quot;</span> | <span class="string">&quot;sync&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">WatchOptions</span>&lt;<span class="title class_">Immediate</span> = <span class="built_in">boolean</span>&gt; <span class="keyword">extends</span> <span class="title class_">WatchOptionsBase</span> &#123;</span><br><span class="line">  immediate?: <span class="title class_">Immediate</span>;</span><br><span class="line">  deep?: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-回调cb"><a href="#2-回调cb" class="headerlink" title="2. 回调cb"></a>2. 回调<code>cb</code></h3><p>了解完<code>options</code>，接下来我们看看回调<strong><code>cb</code></strong>。通常我们的<code>cb</code>接收三个参数：<code>value</code>、<code>oldValue</code>和<code>onCleanUp</code>，然后执行我们需要的操作，比如侦听表格的页码，发生变化时重新请求数据。第三个参数<code>onCleanUp</code>，用于注册副作用清理的回调函数, 在副作用下次执行之前，这个回调函数会被调用，通常用来清除不需要的或者无效的副作用。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 副作用</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">WatchEffect</span> = <span class="function">(<span class="params">onCleanup: OnCleanup</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">WatchCallback</span>&lt;V = <span class="built_in">any</span>, <span class="variable constant_">OV</span> = <span class="built_in">any</span>&gt; = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  value: V,</span></span></span><br><span class="line"><span class="params"><span class="function">  oldValue: OV,</span></span></span><br><span class="line"><span class="params"><span class="function">  onCleanup: OnCleanup</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">OnCleanup</span> = <span class="function">(<span class="params">cleanupFn: () =&gt; <span class="built_in">void</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure><h3 id="3-数据源source"><a href="#3-数据源source" class="headerlink" title="3. 数据源source"></a>3. 数据源<code>source</code></h3><p><code>watch</code>函数可以侦听单个数据或者多个数据，共有四种重载，对应四种类型的<code>source</code>。其中，单个数据源的类型有<code>WatchSource</code>和响应式的<code>object</code>，多个数据源的类型为<code>MultiWatchSources</code>，<code>Readonly&lt;MultiWatchSources&gt;</code>，而<code>MultiWatchSources</code>其实也就是由单个数据源组成的数组。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单数据源类型：可以是 Ref 或 ComputedRef 或 函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">WatchSource</span>&lt;T = <span class="built_in">any</span>&gt; = <span class="title class_">Ref</span>&lt;T&gt; | <span class="title class_">ComputedRef</span>&lt;T&gt; | (<span class="function">() =&gt;</span> T);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多数据源类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MultiWatchSources</span> = (<span class="title class_">WatchSource</span>&lt;<span class="built_in">unknown</span>&gt; | <span class="built_in">object</span>)[];</span><br></pre></td></tr></table></figure><h2 id="二、watch函数"><a href="#二、watch函数" class="headerlink" title="二、watch函数"></a>二、<code>watch</code>函数</h2><p>下面是源码中的类型声明，以及<code>watch</code>的重载签名和实现签名：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// watch的重载与实现</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> watch&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="title class_">MultiWatchSources</span>,</span><br><span class="line">  <span class="title class_">Immediate</span> <span class="keyword">extends</span> <span class="title class_">Readonly</span>&lt;<span class="built_in">boolean</span>&gt; = <span class="literal">false</span></span><br><span class="line">&gt;(</span><br><span class="line">  <span class="attr">sources</span>: [...T],</span><br><span class="line">  <span class="attr">cb</span>: <span class="title class_">WatchCallback</span>&lt;<span class="title class_">MapSources</span>&lt;T, <span class="literal">false</span>&gt;, <span class="title class_">MapSources</span>&lt;T, <span class="title class_">Immediate</span>&gt;&gt;,</span><br><span class="line">  options?: <span class="title class_">WatchOptions</span>&lt;<span class="title class_">Immediate</span>&gt;</span><br><span class="line">): <span class="title class_">WatchStopHandle</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// overload: multiple sources w/ `as const`</span></span><br><span class="line"><span class="comment">// watch([foo, bar] as const, () =&gt; &#123;&#125;)</span></span><br><span class="line"><span class="comment">// somehow [...T] breaks when the type is readonly</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> watch&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="title class_">Readonly</span>&lt;<span class="title class_">MultiWatchSources</span>&gt;,</span><br><span class="line">  <span class="title class_">Immediate</span> <span class="keyword">extends</span> <span class="title class_">Readonly</span>&lt;<span class="built_in">boolean</span>&gt; = <span class="literal">false</span></span><br><span class="line">&gt;(</span><br><span class="line">  <span class="attr">source</span>: T,</span><br><span class="line">  <span class="attr">cb</span>: <span class="title class_">WatchCallback</span>&lt;<span class="title class_">MapSources</span>&lt;T, <span class="literal">false</span>&gt;, <span class="title class_">MapSources</span>&lt;T, <span class="title class_">Immediate</span>&gt;&gt;,</span><br><span class="line">  options?: <span class="title class_">WatchOptions</span>&lt;<span class="title class_">Immediate</span>&gt;</span><br><span class="line">): <span class="title class_">WatchStopHandle</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// overload: single source + cb</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> watch&lt;T, <span class="title class_">Immediate</span> <span class="keyword">extends</span> <span class="title class_">Readonly</span>&lt;<span class="built_in">boolean</span>&gt; = <span class="literal">false</span>&gt;(</span><br><span class="line">  <span class="attr">source</span>: <span class="title class_">WatchSource</span>&lt;T&gt;,</span><br><span class="line">  <span class="attr">cb</span>: <span class="title class_">WatchCallback</span>&lt;T, <span class="title class_">Immediate</span> <span class="keyword">extends</span> <span class="literal">true</span> ? T | <span class="literal">undefined</span> : T&gt;,</span><br><span class="line">  options?: <span class="title class_">WatchOptions</span>&lt;<span class="title class_">Immediate</span>&gt;</span><br><span class="line">): <span class="title class_">WatchStopHandle</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// overload: watching reactive object w/ cb</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> watch&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">object</span>,</span><br><span class="line">  <span class="title class_">Immediate</span> <span class="keyword">extends</span> <span class="title class_">Readonly</span>&lt;<span class="built_in">boolean</span>&gt; = <span class="literal">false</span></span><br><span class="line">&gt;(</span><br><span class="line">  <span class="attr">source</span>: T,</span><br><span class="line">  <span class="attr">cb</span>: <span class="title class_">WatchCallback</span>&lt;T, <span class="title class_">Immediate</span> <span class="keyword">extends</span> <span class="literal">true</span> ? T | <span class="literal">undefined</span> : T&gt;,</span><br><span class="line">  options?: <span class="title class_">WatchOptions</span>&lt;<span class="title class_">Immediate</span>&gt;</span><br><span class="line">): <span class="title class_">WatchStopHandle</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// implementation</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> watch&lt;T = <span class="built_in">any</span>, <span class="title class_">Immediate</span> <span class="keyword">extends</span> <span class="title class_">Readonly</span>&lt;<span class="built_in">boolean</span>&gt; = <span class="literal">false</span>&gt;(</span><br><span class="line">  <span class="attr">source</span>: T | <span class="title class_">WatchSource</span>&lt;T&gt;,</span><br><span class="line">  <span class="attr">cb</span>: <span class="built_in">any</span>,</span><br><span class="line">  options?: <span class="title class_">WatchOptions</span>&lt;<span class="title class_">Immediate</span>&gt;</span><br><span class="line">): <span class="title class_">WatchStopHandle</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (__DEV__ &amp;&amp; !<span class="title function_">isFunction</span>(cb)) &#123;</span><br><span class="line">    <span class="title function_">warn</span>(</span><br><span class="line">      <span class="string">``</span><span class="title function_">watch</span>(fn, options?)<span class="string">` signature has been moved to a separate API. `</span> +</span><br><span class="line">        <span class="string">`Use `</span><span class="title function_">watchEffect</span>(fn, options?)<span class="string">` instead. `</span>watch<span class="string">` now only `</span> +</span><br><span class="line">        <span class="string">`supports `</span><span class="title function_">watch</span>(source, cb, options?) signature.<span class="string">`</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  return doWatch(source as any, cb, options)</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>在<code>watch</code>的实现签名中可以看到，和<code>watchEffect</code>不同，<code>watch</code>的第二个参数<code>cb</code>必须是函数，否则会警告。最后，尾调用了<code>doWatch</code>，那么具体的实现细节就都得看<code>doWatch</code>了。让我们来瞅瞅它到底是何方神圣。</p><h2 id="三、watch的核心：doWatch-函数"><a href="#三、watch的核心：doWatch-函数" class="headerlink" title="三、watch的核心：doWatch 函数"></a>三、<code>watch</code>的核心：<code>doWatch</code> 函数</h2><p>先瞄一下<code>doWatch</code>的签名：接收的参数大体和<code>watch</code>一致，其中<code>source</code>里多了个<code>WatchEffect</code>类型，这是由于在<code>watchApi.js</code>文件里，还导出了三个函数：<code>watchEffect</code>、<code>watchSyncEffect</code>和<code>watchPostEffect</code>，它们接收的第一个参数的类型就是<code>WatchEffect</code>，然后传递给<code>doWatch</code>，会在后面讲到，也可能不会；而<code>options</code>默认值为空对象，函数返回一个<code>WatchStopHandle</code>，用于停止侦听。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doWatch</span>(<span class="params"></span></span><br><span class="line"><span class="params">  source: WatchSource | WatchSource[] | WatchEffect | <span class="built_in">object</span>,</span></span><br><span class="line"><span class="params">  cb: WatchCallback | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  &#123; immediate, deep, flush, onTrack, onTrigger &#125;: WatchOptions = EMPTY_OBJ</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">WatchStopHandle</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看看<code>doWatch</code>的函数体，了解一下它干了些啥：</p><p>首先是判断在没有<code>cb</code>的情况下，如果<code>options</code>里设置了<code>immediate</code>和<code>deep</code>，就会告警，这俩属性只对有<code>cb</code>的<code>doWatch</code>签名有效。其实也就是上面说到的<code>watchEffect</code>等三个函数，它们是没有<code>cb</code>这个参数的，因此它们设置的<code>immediate</code>和<code>deep</code>是无效的。声明一个当<code>source</code>参数不合法时的警告函数，代码如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__DEV__ &amp;&amp; !cb) &#123;</span><br><span class="line">  <span class="keyword">if</span> (immediate !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="title function_">warn</span>(</span><br><span class="line">      <span class="string">`watch() &quot;immediate&quot; option is only respected when using the `</span> +</span><br><span class="line">        <span class="string">`watch(source, callback, options?) signature.`</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (deep !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="title function_">warn</span>(</span><br><span class="line">      <span class="string">`watch() &quot;deep&quot; option is only respected when using the `</span> +</span><br><span class="line">        <span class="string">`watch(source, callback, options?) signature.`</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个source参数不合法的警告函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">warnInvalidSource</span> = (<span class="params">s: <span class="built_in">unknown</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="title function_">warn</span>(</span><br><span class="line">    <span class="string">`Invalid watch source: `</span>,</span><br><span class="line">    s,</span><br><span class="line">    <span class="string">`A watch source can only be a getter/effect function, a ref, `</span> +</span><br><span class="line">      <span class="string">`a reactive object, or an array of these types.`</span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>接下来，就到了正文了。<strong>第一步的目标是设置<code>getter</code>，顺便配置一下强制触发和深层侦听</strong>等。<strong>拿到<code>getter</code>的目的是为了之后创建<code>effect</code></strong>，<code>vue3</code>的响应式离不开<code>effect</code>，日后再出一篇文章介绍。</p><p>先拿到当前实例，声明了空的 getter，初始化关闭强制触发，且默认为单数据源的侦听，然后根据传入的<code>source</code>的类型，做不同的处理：</p><ul><li><code>Ref</code>: <code>getter</code>返回值为<code>Ref</code>的·<code>value</code>,强制触发由<code>source</code>是否为浅层的<code>Ref</code>决定；</li><li><code>Reactive</code>响应式对象：<code>getter</code>的返回值为<code>source</code>本身，且设置深层侦听；</li><li><code>Array</code>：<code>source</code>为数组，则是多数据源侦听，将<code>isMultiSource</code>设置为<code>true</code>，强制触发由数组中是否存在<code>Reactive</code>响应式对象或者浅层的<code>Ref</code>来决定；并且设置<code>getter</code>的返回值为从<code>source</code>映射而来的新数组；</li><li><code>function</code>：当<code>source</code>为函数时，会判断有无<code>cb</code>，有<code>cb</code>则是<code>watch</code>，否则是<code>watchEffect</code>等。当有<code>cb</code>时，使用<code>callWithErrorHandling</code>包裹一层来调用<code>source</code>得到的结果，作为<code>getter</code>的返回值；</li><li><code>otherTypes</code>：其它类型，则告警<code>source</code>参数不合法，且<code>getter</code>设置为<code>NOOP</code>，一个空的函数。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拿到当前实例，声明了空的getter，初始化关闭强制触发，且默认为单数据源的侦听</span></span><br><span class="line"><span class="keyword">const</span> instance = currentInstance;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">getter</span>: <span class="function">() =&gt;</span> <span class="built_in">any</span>;</span><br><span class="line"><span class="keyword">let</span> forceTrigger = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> isMultiSource = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据侦听数据源的类型做相应的处理</span></span><br><span class="line"><span class="keyword">if</span> (<span class="title function_">isRef</span>(source)) &#123;</span><br><span class="line">  getter = <span class="function">() =&gt;</span> source.<span class="property">value</span>;</span><br><span class="line">  forceTrigger = <span class="title function_">isShallow</span>(source);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isReactive</span>(source)) &#123;</span><br><span class="line">  getter = <span class="function">() =&gt;</span> source;</span><br><span class="line">  deep = <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isArray</span>(source)) &#123;</span><br><span class="line">  isMultiSource = <span class="literal">true</span>;</span><br><span class="line">  forceTrigger = source.<span class="title function_">some</span>(<span class="function">(<span class="params">s</span>) =&gt;</span> <span class="title function_">isReactive</span>(s) || <span class="title function_">isShallow</span>(s));</span><br><span class="line">  getter = <span class="function">() =&gt;</span></span><br><span class="line">    <span class="comment">// 可见，数组成员只能是Ref、Reactive或者函数，其它类型无法通过校验，将引发告警</span></span><br><span class="line">    source.<span class="title function_">map</span>(<span class="function">(<span class="params">s</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isRef</span>(s)) &#123;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="property">value</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isReactive</span>(s)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">traverse</span>(s);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isFunction</span>(s)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">callWithErrorHandling</span>(s, instance, <span class="title class_">ErrorCodes</span>.<span class="property">WATCH_GETTER</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        __DEV__ &amp;&amp; <span class="title function_">warnInvalidSource</span>(s);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isFunction</span>(source)) &#123;</span><br><span class="line">  <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">    <span class="comment">// getter with cb</span></span><br><span class="line">    getter = <span class="function">() =&gt;</span></span><br><span class="line">      <span class="title function_">callWithErrorHandling</span>(source, instance, <span class="title class_">ErrorCodes</span>.<span class="property">WATCH_GETTER</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// no cb -&gt; simple effect</span></span><br><span class="line">    getter = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (instance &amp;&amp; instance.<span class="property">isUnmounted</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (cleanup) &#123;</span><br><span class="line">        <span class="title function_">cleanup</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">callWithAsyncErrorHandling</span>(</span><br><span class="line">        source,</span><br><span class="line">        instance,</span><br><span class="line">        <span class="title class_">ErrorCodes</span>.<span class="property">WATCH_CALLBACK</span>,</span><br><span class="line">        [onCleanup]</span><br><span class="line">      );</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  getter = <span class="variable constant_">NOOP</span>;</span><br><span class="line">  __DEV__ &amp;&amp; <span class="title function_">warnInvalidSource</span>(source);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后还顺便兼容了下<code>vue2.x</code>版本的<code>watch</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.x array mutation watch compat</span></span><br><span class="line"><span class="keyword">if</span> (__COMPAT__ &amp;&amp; cb &amp;&amp; !deep) &#123;</span><br><span class="line">  <span class="keyword">const</span> baseGetter = getter;</span><br><span class="line">  getter = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> val = <span class="title function_">baseGetter</span>();</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      <span class="title function_">isArray</span>(val) &amp;&amp;</span><br><span class="line">      <span class="title function_">checkCompatEnabled</span>(<span class="title class_">DeprecationTypes</span>.<span class="property">WATCH_ARRAY</span>, instance)</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="title function_">traverse</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后判断了下<code>deep</code>和<code>cb</code>，在深度侦听且有<code>cb</code>的情况下（说白了就是<code>watch</code>而不是<code>watchEffect</code>等），对<code>getter</code>做个<code>traverse</code>，该函数的作用是对<code>getter</code>的返回值做一个递归遍历，将遍历到的值添加到一个叫做<code>seen</code>的集合中，<code>seen</code>的成员即为当前<code>watch</code>要侦听的那些数据。代码如下（影响主线可先跳过）：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">traverse</span>(<span class="params">value: <span class="built_in">unknown</span>, seen?: <span class="built_in">Set</span>&lt;<span class="built_in">unknown</span>&gt;</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">isObject</span>(value) || (value <span class="keyword">as</span> <span class="built_in">any</span>)[<span class="title class_">ReactiveFlags</span>.<span class="property">SKIP</span>]) &#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">  seen = seen || <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">  <span class="keyword">if</span> (seen.<span class="title function_">has</span>(value)) &#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">  seen.<span class="title function_">add</span>(value);</span><br><span class="line">  <span class="comment">// Ref</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isRef</span>(value)) &#123;</span><br><span class="line">    <span class="title function_">traverse</span>(value.<span class="property">value</span>, seen);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isArray</span>(value)) &#123;</span><br><span class="line">    <span class="comment">// 数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; value.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="title function_">traverse</span>(value[i], seen);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isSet</span>(value) || <span class="title function_">isMap</span>(value)) &#123;</span><br><span class="line">    <span class="comment">// 集合与映射</span></span><br><span class="line">    value.<span class="title function_">forEach</span>(<span class="function">(<span class="params">v: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">traverse</span>(v, seen);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isPlainObject</span>(value)) &#123;</span><br><span class="line">    <span class="comment">// 普通对象</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> value) &#123;</span><br><span class="line">      <span class="title function_">traverse</span>((value <span class="keyword">as</span> <span class="built_in">any</span>)[key], seen);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，<code>getter</code>就设置好了。之后声明了<code>cleanup</code>和<code>onCleanup</code>，用于清除副作用。以及<code>SSR</code>检测。虽然不是本文的重点，但还是贴一下源码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">cleanup</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">onCleanup</span>: <span class="title class_">OnCleanup</span> = <span class="function">(<span class="params">fn: () =&gt; <span class="built_in">void</span></span>) =&gt;</span> &#123;</span><br><span class="line">  cleanup = effect.<span class="property">onStop</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">callWithErrorHandling</span>(fn, instance, <span class="title class_">ErrorCodes</span>.<span class="property">WATCH_CLEANUP</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in SSR there is no need to setup an actual effect, and it should be noop</span></span><br><span class="line"><span class="comment">// unless it&#x27;s eager</span></span><br><span class="line"><span class="keyword">if</span> (__SSR__ &amp;&amp; isInSSRComponentSetup) &#123;</span><br><span class="line">  <span class="comment">// we will also not call the invalidate callback (+ runner is not set up)</span></span><br><span class="line">  onCleanup = <span class="variable constant_">NOOP</span>;</span><br><span class="line">  <span class="keyword">if</span> (!cb) &#123;</span><br><span class="line">    <span class="title function_">getter</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">    <span class="title function_">callWithAsyncErrorHandling</span>(cb, instance, <span class="title class_">ErrorCodes</span>.<span class="property">WATCH_CALLBACK</span>, [</span><br><span class="line">      <span class="title function_">getter</span>(),</span><br><span class="line">      isMultiSource ? [] : <span class="literal">undefined</span>,</span><br><span class="line">      onCleanup,</span><br><span class="line">    ]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable constant_">NOOP</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后就是重头戏了，拿到<code>oldValue</code>，以及在<code>job</code>函数中取得<code>newValue</code>，这不就是我们在使用<code>watch</code>的时候的熟悉套路嘛。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> oldValue = isMultiSource ? [] : <span class="variable constant_">INITIAL_WATCHER_VALUE</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// job为当前watch要做的工作，后续通过调度器来处理</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">job</span>: <span class="title class_">SchedulerJob</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 当前effect不在active状态，说明没有触发该effect的响应式变化，直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (!effect.<span class="property">active</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// cb存在，说明是watch，而不是watchEffect</span></span><br><span class="line">  <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">    <span class="comment">// watch(source, cb)</span></span><br><span class="line">    <span class="comment">// 调用 effect.run 得到新的值 newValue</span></span><br><span class="line">    <span class="keyword">const</span> newValue = effect.<span class="title function_">run</span>();</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      deep ||</span><br><span class="line">      forceTrigger ||</span><br><span class="line">      <span class="comment">// 取到的新值和旧值是否相同，如果有变化则进入分支</span></span><br><span class="line">      (isMultiSource</span><br><span class="line">        ? (newValue <span class="keyword">as</span> <span class="built_in">any</span>[]).<span class="title function_">some</span>(<span class="function">(<span class="params">v, i</span>) =&gt;</span></span><br><span class="line">            <span class="title function_">hasChanged</span>(v, (oldValue <span class="keyword">as</span> <span class="built_in">any</span>[])[i])</span><br><span class="line">          )</span><br><span class="line">        : <span class="title function_">hasChanged</span>(newValue, oldValue)) ||</span><br><span class="line">      <span class="comment">// 兼容2.x</span></span><br><span class="line">      (__COMPAT__ &amp;&amp;</span><br><span class="line">        <span class="title function_">isArray</span>(newValue) &amp;&amp;</span><br><span class="line">        <span class="title function_">isCompatEnabled</span>(<span class="title class_">DeprecationTypes</span>.<span class="property">WATCH_ARRAY</span>, instance))</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// cleanup before running cb again</span></span><br><span class="line">      <span class="keyword">if</span> (cleanup) &#123;</span><br><span class="line">        <span class="title function_">cleanup</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 用异步异常处理程序包裹了一层来调用cb</span></span><br><span class="line">      <span class="title function_">callWithAsyncErrorHandling</span>(cb, instance, <span class="title class_">ErrorCodes</span>.<span class="property">WATCH_CALLBACK</span>, [</span><br><span class="line">        newValue,</span><br><span class="line">        <span class="comment">// pass undefined as the old value when it&#x27;s changed for the first time</span></span><br><span class="line">        oldValue === <span class="variable constant_">INITIAL_WATCHER_VALUE</span> ? <span class="literal">undefined</span> : oldValue,</span><br><span class="line">        onCleanup,</span><br><span class="line">      ]);</span><br><span class="line">      <span class="comment">// cb执行完成，当前的新值就变成了旧值</span></span><br><span class="line">      oldValue = newValue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// cb不存在，则是watchEffect</span></span><br><span class="line">    <span class="comment">// watchEffect</span></span><br><span class="line">    effect.<span class="title function_">run</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置allowRecurse，让调度器知道它可以自己触发</span></span><br><span class="line">job.<span class="property">allowRecurse</span> = !!cb;</span><br></pre></td></tr></table></figure><p>一看<code>job</code>里，在<code>watch</code>的分支出现了<code>effect</code>，但是这个分支并没有<code>effect</code>呀，再往下看，噢，原来是由之前取得的<code>getter</code>来创建的<code>effect</code>。在这之前，还定义了调度器，调度器<code>scheduler</code>被糅合进了<code>effect</code>里，影响了<code>newValue</code>的获取，从而影响<code>cb</code>的调用时机：</p><ul><li><code>sync</code>：同步执行，也就是回调<code>cb</code>直接执行；</li><li><code>pre</code>：默认值是<code>pre</code>，表示组件更新前执行；</li><li><code>post</code>：组件更新后执行。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">scheduler</span>: <span class="title class_">EffectScheduler</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据flush的值来创建不同的调度器</span></span><br><span class="line"><span class="keyword">if</span> (flush === <span class="string">&quot;sync&quot;</span>) &#123;</span><br><span class="line">  scheduler = job <span class="keyword">as</span> <span class="built_in">any</span>; <span class="comment">// the scheduler function gets called directly</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (flush === <span class="string">&quot;post&quot;</span>) &#123;</span><br><span class="line">  scheduler = <span class="function">() =&gt;</span> <span class="title function_">queuePostRenderEffect</span>(job, instance &amp;&amp; instance.<span class="property">suspense</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// default: &#x27;pre&#x27;</span></span><br><span class="line">  scheduler = <span class="function">() =&gt;</span> <span class="title function_">queuePreFlushCb</span>(job);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为 watch 创建 effect ，watchEffect就不必了，因为自带的有</span></span><br><span class="line"><span class="keyword">const</span> effect = <span class="keyword">new</span> <span class="title class_">ReactiveEffect</span>(getter, scheduler);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主要是调试用的onTrack和onTrigger，当收集依赖和触发更新时做一些操作</span></span><br><span class="line"><span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">  effect.<span class="property">onTrack</span> = onTrack;</span><br><span class="line">  effect.<span class="property">onTrigger</span> = onTrigger;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在来到了<code>doWatch</code>最后的环节了：侦听器的初始化。</p><ul><li><code>immediate</code>：如果为真值。将直接调用一次<code>job</code>，上文我们知道，<code>job</code>是包裹了一层错误处理程序来调用<code>cb</code>，所以我们现在终于亲眼看到了为什么<code>immediate</code>能让<code>cb</code>立即触发一次。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// initial run</span></span><br><span class="line"><span class="comment">// 有cb，是 watch</span></span><br><span class="line"><span class="keyword">if</span> (cb) &#123;</span><br><span class="line">  <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">    <span class="title function_">job</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 获取一下当前的值作为旧值</span></span><br><span class="line">    oldValue = effect.<span class="title function_">run</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (flush === <span class="string">&quot;post&quot;</span>) &#123;</span><br><span class="line">  <span class="comment">// 没有cb，是watchEffect，副作用的时机在组件更新之后，用queuePostRenderEffect包裹一层来调整时机</span></span><br><span class="line">  <span class="title function_">queuePostRenderEffect</span>(effect.<span class="property">run</span>.<span class="title function_">bind</span>(effect), instance &amp;&amp; instance.<span class="property">suspense</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// watchEffect，副作用的时机在组件更新之前，直接执行一次effect.run</span></span><br><span class="line">  effect.<span class="title function_">run</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个WatchStopHandle，内部执行 effect.stop来达到停止侦听的作用</span></span><br><span class="line"><span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  effect.<span class="title function_">stop</span>();</span><br><span class="line">  <span class="comment">// 移除当前实例作用域下的当前effect</span></span><br><span class="line">  <span class="keyword">if</span> (instance &amp;&amp; instance.<span class="property">scope</span>) &#123;</span><br><span class="line">    <span class="title function_">remove</span>(instance.<span class="property">scope</span>.<span class="property">effects</span>!, effect);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>到这里，<code>watch</code>的源码算是差不多结束了。小结一下核心流程：</p><ul><li><code>watch</code>：判断若没有<code>cb</code>则告警；</li><li><code>watch</code>：尾调用<code>doWatch</code>，之后的操作都在<code>doWatch</code>里进行；</li><li><code>doWatch</code>：判断没有<code>cb</code>时若设置了<code>deep</code>或<code>immediate</code>则告警；</li><li><code>doWatch</code>：根据<code>source</code>的类型得到<code>getter</code>；</li><li><code>doWatch</code>：如果<code>cb</code>存在且<code>deep</code>为真则对<code>getter()</code>进行递归遍历；</li><li><code>doWatch</code>：获取<code>oldValue</code>，声明<code>job</code>函数，在<code>job</code>内部获取<code>newValue</code>并使用<code>callWithAsyncErrorHandling</code>来调用<code>cb</code>。</li><li><code>doWatch</code>：根据<code>post</code>的值定义的调度器<code>scheduler</code>；</li><li><code>doWatch</code>：根据<code>getter</code>和<code>scheduler</code>创建<code>effect</code>；</li><li><code>doWatch</code>：初始化侦听器，如果有<code>cb</code>且<code>immediate</code>为真值，则立即调用<code>job</code>函数，相当于调用我们写的<code>cb</code>；如果<code>immediate</code>为假值，则只调用<code>effect.run()</code>来初始化<code>oldValue</code>；</li><li><code>doWatch</code>：返回一个<code>WatchStopHandle</code>，内部通过<code>effect.stop()</code>来实现停止侦听。</li><li><code>watch</code>：接收到<code>doWatch</code>返回的<code>WatchStopHandle</code>，并返回给外部使用。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前 端 </tag>
            
            <tag> Vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js温故(四)：Ajax—XHR、fetch、websocket</title>
      <link href="/articals/90f04b7f/"/>
      <url>/articals/90f04b7f/</url>
      
        <content type="html"><![CDATA[<h2 id="一、XMLHttpRequest-对象"><a href="#一、XMLHttpRequest-对象" class="headerlink" title="一、XMLHttpRequest 对象"></a>一、<code>XMLHttpRequest</code> 对象</h2><p>所有现代浏览器都支持通过<code>XMLHttpRequest</code>构造函数来原生支持<code>XHR</code>对象：<code>const xhr = new XMLHttpRequest()</code>。</p><h3 id="1-使用XHR"><a href="#1-使用XHR" class="headerlink" title="1. 使用XHR"></a>1. 使用<code>XHR</code></h3><p>使用<code>XHR</code>第一步便是调用<code>open()</code>方法，其接收三个参数：请求的类型(如<code>get</code>)，<code>url</code>，以及一个布尔值表示请求是否为异步。例如，<code>xhr.open(&#39;get&#39;, &#39;www.baidu.com&#39;, false)</code> 表示将要向<code>www.baidu.com</code>发送一个同步的<code>get</code>请求。有两点需要注意：</p><ul><li>这里得第二个参数<code>url</code>一般是相对于当前页面的，不过也可以使用绝对<code>URL</code>；</li><li>调用<code>open()</code>方法只是进行初始化，并不会立即发送请求，而是为发送请求做准备，真正开始发送请求还需要调用<code>send()</code>方法。</li></ul><p><code>send()</code>方法接收一个参数，表示作为请求体发送的数据。<code>xhr.send(&#123;username: &#39;cc&#39;, pwd: &#39;lovecake&#39;&#125;)</code>。如果不需要请求体，则必须传入<code>null</code>：<code>xhr.send(null)</code>。调用<code>send()</code>方法后，请求就会发送到服务器。由于在<code>open()</code>方法里将这个请求设置为同步的，因此在调用<code>send()</code>方法后，后续的<code>js</code>代码会暂停执行，等到服务器响应后方才恢复执行。当收到相应后，<code>xhr</code>对象的一些属性会被填充上响应数据：</p><ul><li><code>responseText</code>：作为相应体返回的文本；</li><li><code>responseXML</code>：如果响应的内容类型是<code>text/xml</code>或<code>application/xml</code>，则此属性为包含响应数据的<code>XML DOM</code>文档；</li><li><code>status</code>：响应的<code>HTTP</code>状态；</li><li><code>statusText</code>：响应的<code>HTTP</code>状态描述。</li></ul><p>当收到响应后，首先应该检查状态码<code>status</code>来判断响应是否成功返回。一般来说，<strong>状态码为<code>2xx</code></strong>则表示成功。此外，<strong>状态码为<code>304</code></strong>，表示服务器资源未修改，直接用缓存中的资源，这也意味着响应有效。其它状态码则表示请求失败。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"><span class="keyword">let</span> url = <span class="string">&quot;www.baidu.com&quot;</span>;</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;get&quot;</span>, url, <span class="literal">false</span>);</span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查status</span></span><br><span class="line"><span class="keyword">if</span> ((xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>) || xhr.<span class="property">status</span> === <span class="number">304</span>) &#123;</span><br><span class="line">  <span class="comment">// 请求成功</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;request success!!&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 请求失败</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;request failed：&quot;</span> + xhr.<span class="property">status</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管<code>statusText</code>中也包含状态描述信息，但是它在跨浏览器时并不可靠，因此还是应该用<code>status</code>来检查。对于不同的响应类型，<strong><code>responseText</code>始终保存响应体的内容，而<code>responseXML</code>只在相应类型为<code>XML</code>数据时为有效数据，否则其值为<code>null</code>。</strong></p><p>由于设置为同步请求，会阻塞之后的<code>js</code>代码，因此，最好使用异步请求。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"><span class="keyword">let</span> url = <span class="string">&quot;www.baidu.com&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三个参数设置为true，即异步请求</span></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;get&quot;</span>, url, <span class="literal">true</span>);</span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>异步请求需要用到<code>xhr</code>的<code>readyState</code>属性，该属性表示当前请求处于哪个阶段，其可能的值如下：</p><ul><li>0 ：未初始化，即尚未调用<code>open()</code>方法；</li><li>1 ：已打开。即调用了<code>open()</code>方法，但还未调用<code>send()</code>；</li><li>2 ：已发送。已经调用<code>send()</code>方法，但还未接收到响应；</li><li>3 ：接收中，即已接受到部分响应；</li><li>4 ：完成，即已接收到所有数据，可以使用。</li></ul><p>可以看到，我们最需要的就是<code>readyState</code>的值为 4。<code>readyState</code>的值每次变化时，都会触发<code>readystatechange</code>事件，因此，只需要监听<code>xhr</code>对象的<code>readystatechange</code>事件，该事件没有<code>event</code>对象，因此我们判断<code>readyState</code>值为 4 时，即请求完成，可进行后续操作。 为保证跨浏览器兼容，<strong>对<code>readystatechange</code>事件的监听应在<code>open()</code>方法调用之前进行。</strong> 对于不想继续的请求，可以<strong>使用<code>abort()</code>方法取消，并断开对<code>xhr</code>对象的引用</strong>。由于内存问题，<strong>不推荐复用<code>xhr</code>对象</strong>，最好每个请求都重新创建一个。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"><span class="keyword">let</span> url = <span class="string">&quot;www.baidu.com&quot;</span>;</span><br><span class="line"><span class="comment">// 监听readystatechange事件，应在open()方法调用之前</span></span><br><span class="line"><span class="comment">// 不推荐使用this来指代xhr对象，在某些浏览器中在这里使用this可能会导致错误</span></span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 请求完成</span></span><br><span class="line">  <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="comment">// 检查status</span></span><br><span class="line">    <span class="keyword">if</span> ((xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>) || xhr.<span class="property">status</span> === <span class="number">304</span>) &#123;</span><br><span class="line">      <span class="comment">// 请求成功</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;request success!!&quot;</span>);</span><br><span class="line">      <span class="comment">// 执行其它操作</span></span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 请求失败</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;request failed：&quot;</span> + xhr.<span class="property">status</span>);</span><br><span class="line">      <span class="comment">// 处理失败</span></span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;get&quot;</span>, url, <span class="literal">true</span>);</span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于某些原因可能想取消该请求</span></span><br><span class="line">xhr.<span class="title function_">abort</span>();</span><br><span class="line">xhr = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h3 id="2-HTTP头部"><a href="#2-HTTP头部" class="headerlink" title="2. HTTP头部"></a>2. <code>HTTP</code>头部</h3><p>每个<code>HTTP</code>请求和响应都携带有一些头部信息。<code>XHR</code>对象通过一些方法暴露请求和响应相关的头部字段。</p><p>默认情况下，<code>XHR</code>请求会发送一些头部字段：</p><ul><li><code>Accept</code>：浏览器能够处理的内容类型；</li><li><code>Accept-Charset</code>：浏览器能够显示的字符集；</li><li><code>Accept-Encoding</code>：浏览器能够处理的压缩编码类型；</li><li><code>Accept-Language</code>：浏览器使用的语言；</li><li><code>Connection</code>：浏览器与服务器的连接类型；</li><li><code>Cookie</code>：页面中设置的 Cookie；</li><li><code>Host</code>：发送请求的页面所在的域；</li><li><code>Referer</code>：发送请求的页面的<code>URL</code>（这个字段本应是<code>Referrer</code>，但是在<code>HTTP</code>规范中就拼错了，因此将错就错）；</li><li><code>User-Agent</code>：浏览器的用户代理字符串。</li></ul><p>如果需要发送额外的头部字段，可以使用<code>setRequestHeader()</code>方法，这个方法应该在<code>open()</code>方法之后、<code>send()</code>方法之前调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建xhr对象</span></span><br><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"><span class="comment">// 监听readystatechange事件</span></span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 请求完成</span></span><br><span class="line">  <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="comment">// 检查status</span></span><br><span class="line">    <span class="keyword">if</span> ((xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>) || xhr.<span class="property">status</span> === <span class="number">304</span>) &#123;</span><br><span class="line">      <span class="comment">// 请求成功</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;request success!!&quot;</span>);</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 请求失败</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;request failed：&quot;</span> + xhr.<span class="property">status</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化请求</span></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;www.baidu.com&quot;</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加额外的头部字段，最好区别于默认头部字段</span></span><br><span class="line">xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;custom-header-field&quot;</span>, <span class="string">&quot;custom-value&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送请求</span></span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>要读取相应头的信息，可以使用<code>getResponseHeader()</code>方法，另外，也可以使用<code>getAllResponseHeaders()</code>方法来获取所有的响应头，其值为包含所有响应头部的字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myHeader = xhr.<span class="title function_">getResponseHeader</span>(<span class="string">&quot;my-header&quot;</span>),</span><br><span class="line">  allHeaders = xhr.<span class="title function_">getAllResponseHeaders</span>();</span><br><span class="line"><span class="comment">// getAllResponseHeaders()一般返回如下多行字符串</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(allHeaders);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Date: Sun, 14 Nov 2004 18:04:03 GMT</span></span><br><span class="line"><span class="comment">Server: Apache/1.3.29 (Unix)</span></span><br><span class="line"><span class="comment">Vary: Accept</span></span><br><span class="line"><span class="comment">X-Powered-By: PHP/4.3.8</span></span><br><span class="line"><span class="comment">Connection: close</span></span><br><span class="line"><span class="comment">Content-Type: text/html; charset=iso-8859-1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="3-GET请求"><a href="#3-GET请求" class="headerlink" title="3. GET请求"></a>3. <code>GET</code>请求</h3><p><code>GET</code>请求的查询参数一般都拼接在<code>URL</code>后面。对于<code>XHR</code>而言，拼接的参数应该经过<code>encodeURLComponent()</code>方法来正确编码并添加到<code>URL</code>后面，然后传给<code>open()</code>方法。如下函数可以将查询字符串参数添加到<code>URL</code>后面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">appendURLParams</span>(<span class="params">url, name, value</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> symbol = url.<span class="title function_">indexOf</span>(<span class="string">&quot;?&quot;</span>) !== -<span class="number">1</span> ? <span class="string">&quot;?&quot;</span> : <span class="string">&quot;&amp;&quot;</span>,</span><br><span class="line">    addedContent = <span class="string">`<span class="subst">$&#123;encodeURLComponent(name)&#125;</span>=<span class="subst">$&#123;encodeURLComponent(value)&#125;</span>`</span>;</span><br><span class="line">  <span class="keyword">return</span> url + symbol + addedContent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-POST请求"><a href="#4-POST请求" class="headerlink" title="4. POST请求"></a>4. <code>POST</code>请求</h3><p><code>POST</code>请求在请求体中携带数据。<code>XHR</code>最初主要设计用来发送<code>XML</code>数据的，也可以发送字符串。对于服务器而言， <code>POST</code>请求与表单提交是不一样的。可以将请求头中的<code>Content-Type</code>设置为与表单提交一致，即<code>application/x-www-formurlencoded</code>，并且创建对应格式的字符串，来模拟表单提交。</p><h3 id="5-XMLHTTPRequest-Level-2"><a href="#5-XMLHTTPRequest-Level-2" class="headerlink" title="5. XMLHTTPRequest Level 2"></a>5. <code>XMLHTTPRequest</code> Level 2</h3><p><code>XMLHTTPRequest</code> Level 2 进一步发展了<code>XHR</code>。</p><h4 id="1-FormData-类型"><a href="#1-FormData-类型" class="headerlink" title="(1) FormData 类型"></a>(1) <code>FormData</code> 类型</h4><p><code>XMLHTTPRequest</code> Level 2 中新增了<code>FormData</code>类型，以便对表单数据进行序列化，或创建与表单类似格式的数据然后通过<code>XHR</code>发送。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fd = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span><br><span class="line"><span class="comment">// 添加数据</span></span><br><span class="line">fd.<span class="title function_">append</span>(<span class="string">&quot;uname&quot;</span>, <span class="string">&quot;cc&quot;</span>);</span><br></pre></td></tr></table></figure><p>使用<code>append()</code>方法来添加数据（键可以重复），<code>delete()</code>方法来删除所有对应键的数据，<code>set()</code>来设置不重复的键，<code>get()</code>方法来获取该键的第一条数据，<code>getAll()</code>方法得到包含该键对应的所有数据的数组。</p><h4 id="2-超时"><a href="#2-超时" class="headerlink" title="(2) 超时"></a>(2) 超时</h4><p>给<code>XHR</code>对象的<code>timeout</code>属性设置一个时间（毫秒），如果超过该时间还未收到响应，则<code>XHR</code>对象会触发<code>timeout</code>事件，并调用<code>ontimeout</code>处理程序。触发<code>timeout</code>事件后，<code>readyState</code>的值也会变成 4，但是此时访问<code>xhr.status</code>会出错。因此，<strong>检查<code>status</code>的语句应该放在<code>try/catch</code>语句中，当捕获到错误则说明请求超时</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建xhr对象</span></span><br><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"><span class="comment">// 监听readystatechange事件</span></span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 请求完成</span></span><br><span class="line">    <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span><br><span class="line">      <span class="comment">// 检查status</span></span><br><span class="line">      <span class="keyword">if</span> ((xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>) || xhr.<span class="property">status</span> === <span class="number">304</span>) &#123;</span><br><span class="line">        <span class="comment">// 请求成功</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;request success!!&quot;</span>);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 请求失败</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;request failed：&quot;</span> + xhr.<span class="property">status</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// 超时，一般由ontimeout来处理</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化请求</span></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;www.baidu.com&quot;</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 超时处理</span></span><br><span class="line">xhr.<span class="property">timeout</span> = <span class="number">2000</span>; <span class="comment">// 设置超时时间2秒钟</span></span><br><span class="line">xhr.<span class="property">ontimeout</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;request timeout!!&quot;</span>);</span><br><span class="line">  <span class="comment">// 其它处理</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加额外的头部字段，最好区别于默认头部字段</span></span><br><span class="line">xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;custom-header-field&quot;</span>, <span class="string">&quot;custom-value&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送请求</span></span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><h4 id="3-overrideMimeType-方法"><a href="#3-overrideMimeType-方法" class="headerlink" title="(3) overrideMimeType()方法"></a>(3) <code>overrideMimeType()</code>方法</h4><p><code>overrideMimeType()</code>方法用于重写<code>XHR</code>响应的<code>MIME</code>类型。响应返回的<code>MIME</code>类型决定了<code>XHR</code>对象如何处理响应。例如，如果服务器实际上发送了<code>XML</code>数据，但是响应头设置的<code>MIME</code>类型是<code>text/plain</code>，则<code>XHR</code>对象不会将其当作<code>XML</code>类型来处理，导致<code>xhr.responseXML</code>的值为<code>null</code>。此时调用<code>overrideMimeType()</code>方法可以强制将响应当成<code>XML</code>来处理当然，这个方法应该在调用<code>send()</code>方法之前调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;www.baidu.com&quot;</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将响应头的MIME类型设置为XML</span></span><br><span class="line">xhr.<span class="title function_">overrideMimeType</span>(<span class="string">&quot;text/xml&quot;</span>);</span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><h2 id="二、进度事件-progress"><a href="#二、进度事件-progress" class="headerlink" title="二、进度事件 progress"></a>二、进度事件 <code>progress</code></h2><p>进度事件一开始只针对于<code>XHR</code>，后来也推广到了其它类似<code>API</code>。一般来说，有如下 6 个进度相关的事件：</p><ul><li><code>loadstart</code>：在接收到第一个响应字节时触发；</li><li><code>progress</code>：在接收响应期间反复出发；</li><li><code>error</code>：在请求出错时触发；</li><li><code>abort</code>：在请求终止连接时触发；</li><li><code>load</code>：在成功接收完响应时触发；</li><li><code>loadend</code>：在通信完成时，且在<code>error</code>、<code>abort</code>、<code>load</code>之后触发。</li></ul><p>这些事件都比较容易理解，主要说明一下<code>load</code>和<code>progress</code>：</p><h3 id="1-load事件"><a href="#1-load事件" class="headerlink" title="1. load事件"></a>1. <code>load</code>事件</h3><p><code>onload</code>事件处理程序相当于之前的<code>readyState</code>的值为 4，简化了操作。它接收一个<code>event</code>对象，其<code>target</code>为对应的<code>xhr</code>对象，但是不是所有浏览器都实现了这个事件的<code>event</code>对象，因此，考虑到兼容性，还是应该像之前一样使用<code>xhr</code>，而不是<code>event.target</code>。当然，只要接收到完响应，就会触发<code>load</code>事件，这不受状态码<code>status</code>的影响。因此，我们仍然需要检查<code>status</code>。</p><h3 id="2-progress事件"><a href="#2-progress事件" class="headerlink" title="2. progress事件"></a>2. <code>progress</code>事件</h3><p>在浏览器接收数据期间，<code>progress</code>事件会反复触发。每次触发，<code>onprogress</code>事件处理程序都会接收一个<code>event</code>对象，它的<code>target</code>属性是<code>xhr</code>对象，且拥有额外的三个属性：<code>lengthComputable</code>、<code>position</code>、<code>totalSize</code> 。其中，<code>lengthComputable</code>是一个布尔值，表示进度信息是否可用；<code>position</code>表示当前接收到的字节数；<code>totalSize</code>表示总字节数。用这些信息就可以展示进度条了。另外，<strong><code>onprogress</code>事件处理程序应该在<code>open()</code>事件之前添加</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> ((xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>) || xhr.<span class="property">status</span> == <span class="number">304</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">responseText</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Request failed: &quot;</span> + xhr.<span class="property">status</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 监控进度</span></span><br><span class="line">xhr.<span class="property">onprogress</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> divProgress = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;progress&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (event.<span class="property">lengthComputable</span>) &#123;</span><br><span class="line">    divProgress.<span class="property">innerHTML</span> =</span><br><span class="line">      <span class="string">&quot;请求完成: &quot;</span> +</span><br><span class="line">      ((event.<span class="property">position</span> / event.<span class="property">totalSize</span>) * <span class="number">100</span>).<span class="title function_">toFixed</span>(<span class="number">2</span>) +</span><br><span class="line">      <span class="string">&quot;%&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;www.baidu.com&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><h2 id="三、-跨域资源共享"><a href="#三、-跨域资源共享" class="headerlink" title="三、 跨域资源共享"></a>三、 跨域资源共享</h2><p>由于<code>XHR</code>受跨域安全策略限制，默认情况下，<code>XHR</code>只能访问与发起请求的页面同在一个域内的资源。跨域资源共享(<code>CORS</code>)定义了浏览器与服务器如何进行跨源通信。<code>CORS</code>背后的基本思路是使用自定义的<code>HTTP</code>头部，允许浏览器与服务器相互了解，来确定请求应该成功或失败。</p><p>对于<code>GET</code>、<code>POST</code>这些简单的请求，没有请求头，且请求体为<code>text/plain</code>类型，这样的请求在发送时会额外有一个头部，叫做<code>Origin</code>，它包含发送请求的页面的源（协议、域名、端口），从而让服务器确定是否为其提供响应。如果服务器决定响应，就会发送 <code>Access-Control-Allow-Origin</code>头部，包含相同的源（协议、域名、端口），或者为<code>*</code>，表示资源是公开的。</p><p>如果没有这个头部，或者有但是源不匹配，则表示不会响应浏览器请求。无论请求还是响应，都没有<code>Cookie</code>信息。跨域<code>XHR</code>对象允许访问<code>status</code>和<code>responseText</code>，也允许同步请求，但是处于安全考虑也做了一些限制：</p><ul><li>不允许使用<code>setRequestHeader()</code>来设置自定义头部；</li><li>不能接收与发送<code>cookie</code>;</li><li><code>getAllResponseHeaders()</code>始终返回空字符串；</li></ul><h3 id="1-预检请求"><a href="#1-预检请求" class="headerlink" title="1. 预检请求"></a>1. 预检请求</h3><p><code>CORS</code>通过预检请求的服务器验证机制，允许使用自定义头部、除<code>GET</code>、<code>POST</code>以外的方法、以及不同请求体的内容类型。在发送这些里面的某种高级选项的请求时，会先向服务器发送一个预检请求，该请求使用<code>OPTIONS</code>方法发送并包含如下头部：</p><ul><li><code>Origin</code>：与简单请求相同，为发送请求的页面的源；</li><li><code>Access-Control-Request-Method</code>：请求希望使用的方法；</li><li><code>Access-Control-Request-Headers</code>：用逗号分隔的请求头部列表(可选)。</li></ul><p>例如，假设一个<code>POST</code>请求的预检请求的头部如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Origin: http://www.baidu.com</span><br><span class="line">Access-Control-Request-Method: POST</span><br><span class="line">Access-Control-Request-Headers: custom-header</span><br></pre></td></tr></table></figure><p>在该请求发送后，服务器判断是否允许这种类型的请求，并在响应中包含如下头部，来与浏览器沟通这些信息：</p><ul><li><code>Access-Control-Allow-Origin</code>：与简单请求相同，允许访问的源，或者<code>*</code>表示资源公开；</li><li><code>Access-Control-Allow-Methods</code>：允许访问的方法，以逗号分隔的列表；</li><li><code>Access-Control-Allow-Headers</code>：服务器允许的头部，以逗号分隔的列表；</li><li><code>Access-Control-Max-Age</code>：缓存预检请求的秒数。预检请求响应后，其结果会按照这个秒数被缓存一段时间，期间再次发送这种类型的请求无需再发送预检请求。</li></ul><h3 id="2-凭据请求"><a href="#2-凭据请求" class="headerlink" title="2. 凭据请求"></a>2. 凭据请求</h3><p>默认情况下，跨源请求不提供凭据（<code>cookie</code>、<code>HTTP</code>认证、客户端<code>SSL</code>证书等）。可以将<code>withCredentials</code>设置为<code>true</code>来表明请求会发送凭据。如果服务器允许带凭据的请求，则可以在响应头中包含如下<code>HTTP</code>头部：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Credentials: true</span><br></pre></td></tr></table></figure><p>如果发送了凭据请求，但是服务器的响应中没有这个头部，则浏览器不会把响应的内容交给<code>JavaScript</code>。当然，服务器也可以在预检请求的响应中包含这个头部，来表明这个源允许发送凭据请求。</p><h2 id="四、-替代性跨源技术"><a href="#四、-替代性跨源技术" class="headerlink" title="四、 替代性跨源技术"></a>四、 替代性跨源技术</h2><h3 id="1-图片探测"><a href="#1-图片探测" class="headerlink" title="1. 图片探测"></a>1. 图片探测</h3><p>图片探测是与服务器之间简单、跨域、单向的通信，只能通过设置<code>src</code>属性来发送<code>GET</code>请求，且无法获取服务器返回的数据。通过动态创建图片，监听它们的<code>onload</code>和<code>onerror</code>事件处理程序来得知何时收到响应。数据可以通过查询字符串来发送，响应可以随意设置，毕竟浏览器无法得到任何数据，只能通过<code>onload</code>和<code>onerror</code>来获悉什么时候接收到响应。</p><h3 id="2-JSONP"><a href="#2-JSONP" class="headerlink" title="2. JSONP"></a>2. <code>JSONP</code></h3><p><code>JSONP</code>看起来和<code>JSON</code>一样，但是它被包含在函数里。<code>JSONP</code>格式包含 <strong>回调</strong> 和 <strong>数据</strong> 两部分。回调是在页面接收到响应之后应该调用的函数，回调函数的名称通常是通过请求来动态指定的。而数据就是作为参数传给回调函数的<code>JSON</code>数据。<code>JSONP</code>服务通常支持用查询字符串来指定回调函数的名称。</p><p><code>&lt;script&gt;</code>标签不受跨源安全策略的限制，因此通过动态生成<code>&lt;script&gt;</code>标签并指定其<code>src</code>属性来调用<code>JSONP</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">handleResponse</span>(<span class="params">response</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;script&quot;</span>);</span><br><span class="line"><span class="comment">// 通过查询字符串来指定回调函数名称</span></span><br><span class="line">script.<span class="property">src</span> = <span class="string">&quot;http://www.baidu.com?callback=handleResponse&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">insertBefore</span>(script, <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">firstChild</span>);</span><br></pre></td></tr></table></figure><h2 id="五、-Fetch-API"><a href="#五、-Fetch-API" class="headerlink" title="五、 Fetch API"></a>五、 <code>Fetch API</code></h2><p><code>Fetch API</code>可以执行所有<code>XMLHttpRequest</code>的任务，且更便于使用，接口也更现代化，能够在工作者线程中使用。<code>Fetch API</code>必须是异步的。</p><h3 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1. 基本使用"></a>1. 基本使用</h3><p><code>fetch()</code>方法暴露在全局作用域中，包括主页面线程、模块和工作者线程。</p><h4 id="1-分派请求"><a href="#1-分派请求" class="headerlink" title="(1) 分派请求"></a>(1) 分派请求</h4><p><code>fetch()</code>方法只有一个必需的参数，即获取资源的<code>URL</code>，可以是相对路径或绝对路径。返回一个期约(<code>Promise</code> 实例)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> response = <span class="title function_">fetch</span>(<span class="string">&quot;www.baidu.com&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(response); <span class="comment">// Promise &lt;pending&gt;</span></span><br></pre></td></tr></table></figure><p>当请求完成且资源可用时，该期约会解决为一个<code>Response</code>对象，该对象是<code>API</code>的封装，可以通过它的某些方法来获取相应的资源。</p><h4 id="2-读取响应"><a href="#2-读取响应" class="headerlink" title="(2) 读取响应"></a>(2) 读取响应</h4><p>最快的读取响应的方法是读取纯文本内容，这需要调用<code>Response</code>对象的<code>text()</code>方法，该方法返回一个期约，解决为取得的资源的内容。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&quot;test.txt&quot;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">resp</span>) =&gt;</span> resp.<span class="title function_">text</span>())</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(data));</span><br></pre></td></tr></table></figure><h4 id="3-处理-状态码-和-失败请求"><a href="#3-处理-状态码-和-失败请求" class="headerlink" title="(3) 处理 状态码 和 失败请求"></a>(3) 处理 状态码 和 失败请求</h4><p>可以检查<code>Response</code>对象的<code>status</code>和<code>statusText</code>来确定相应状态。成功获取响应的请求一般会得到值为 200 的状态码；请求不存在的资源一般会得到值为 404 的状态码；服务器错误一般是值为 500 的状态码；可以显示地定义<code>fetch()</code>遇到重定向时的行为，但是默认行为是跟随重定向，此时响应对象的<code>redirected</code>属性会被设置为<code>true</code>，而状态码仍然是 200。</p><p>哪怕请求看起来失败了（如<code>status</code>值为 500），期约也会被解决，我们需要判断状态码来确定请求是否成功。而当请求超时时，期约才会执行拒绝程序。此外，无网络连接、违反<code>CORS</code>、<code>HTTPS</code>错配等也会导致期约被拒绝。</p><p>通过<code>Response</code>对象的<code>url</code>属性可以检查发起请求的完整<code>URL</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&quot;/test&quot;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">resp</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(resp.<span class="property">url</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// https://www.baidu.com/test</span></span><br></pre></td></tr></table></figure><h4 id="4-自定义选项"><a href="#4-自定义选项" class="headerlink" title="(4) 自定义选项"></a>(4) 自定义选项</h4><p>只使用<code>URL</code>参数时，<code>fetch()</code>默认为<code>GET</code>请求，且只使用最低限度的请求头。如果徐奥进一步配置，比如使用<code>POST</code>方法、自定义请求头等操作时，就需要传入可选的第二个参数：<code>init</code>对象。下面列举一些常用的配置：</p><ul><li><p><code>body</code>：请求体的内容，必须是<code>Blob</code>，<code>BufferSource</code>、<code>FormData</code>、<code>URLSearchParams</code>、<code>ReadableStream</code>或<code>String</code>的实例；</p></li><li><p><code>cache</code>：用于控制浏览器与<code>HTTP</code>缓存的交互。如需跟踪缓存的重定向，则请求的<code>redirect</code>属性应为<code>follow</code>，且不能违反<code>CORS</code>。<code>cache</code>的值应为以下之一：</p><ul><li><code>Default</code>：默认值。命中有效的缓存，则<code>fetch()</code>返回该缓存，不发送请求；命中无效的缓存，则发送条件式请求，若响应已经改变，则更新缓存的值，且<code>fetch()</code>返回新的缓存值；若没有命中缓存，则发送请求并缓存响应，然后<code>fetch()</code>返回响应。</li><li><code>no-store</code>：浏览器不检查缓存，直接发送请求；不缓存响应，直接<code>fetch()</code>返回；</li><li><code>reload</code>：浏览器不检查缓存，直接发起请求；之后缓存响应并<code>fetch()</code>返回响应；</li><li><code>no-cache</code>：未命中缓存则发送请求，并缓存响应，然后<code>fetch()</code>返回响应；否则发送条件式请求，若响应已经改变，则更新缓存值然后<code>fetch()</code>返回缓存的值；</li><li><code>force-cache</code>：未命中缓存则发起请求，缓存响应并<code>fetch()</code>返回响应；否则，无论命中有效缓存还是无效缓存，都直接返回缓存的值，不发起请求；</li><li><code>only-if-cached</code>：只有请求模式为<code>same-origin</code>时使用缓存；无论命中有效缓存还是无效缓存时，都返回缓存的值，不发送请求；没有命中缓存则返回状态码为 504 (网关超时) 的响应。</li></ul></li></ul><!----><ul><li><p><code>credentials</code>：用于指定在外派请求时如何包含<code>cookie</code>，和<code>XMLHttpRequest</code>的<code>withCredentials</code>标签类似。值为以下字符串之一：</p><ul><li><code>omit</code>：不发送<code>cookie</code>；</li><li><code>same-origin</code>：默认值。只在同源请求时发送<code>cookie</code>；</li><li><code>include</code>：无论同源还是跨源请求，都发送<code>cookie</code>。</li></ul></li></ul><!----><ul><li><code>headers</code>：用于指定请求头部，必须是<code>Headers</code>实例或包含字符串格式的键值对对象。默认为空的<code>Headers</code>实例，但是这不意味着不发送请求头，浏览器仍然会跟随请求发送一些头部信息，但是这些请求头对<code>JavaScript</code>不可见，但浏览器的网络检查器可以检查到。</li></ul><!----><ul><li><p><code>keepalive</code>：指示浏览器是否允许在页面卸载后请求仍然存在，适合向服务器发送报告事件与分析。值为布尔值，默认为<code>false</code>。</p></li><li><p><code>method</code>：指定请求的方法，值为以下字符串之一：</p><ul><li><code>GET</code>，默认值；</li><li><code>POST</code>;</li><li><code>PUT</code>;</li><li><code>PATCH</code>;</li><li><code>DELETE</code>;</li><li><code>HEAD</code>;</li><li><code>OPTIONS</code>;</li><li><code>CONNECT</code>;</li><li><code>TARCE</code>。</li></ul></li></ul><!----><ul><li><p><code>mode</code>：指定请求模式，决定来自跨源请求的响应是否有效。必须是以下字符串之一：</p><ul><li><code>cors</code>：通过构造函数手动创建<code>Request</code>实例时默认值为此，允许遵守<code>CORS</code>跨源请求；</li><li><code>no-cors</code>：其它情况默认值为此，允许不需要发送预检请求的跨源请求，如<code>HEAD</code>、<code>GET</code>和只带有满足<code>CORS</code>请求头部的<code>POST</code>请求；响应类型是<code>opaque</code>，意思是能读取响应内容；</li><li><code>same-origin</code>：只允许同源请求；</li><li><code>navigate</code>：用于支持<code>HTML</code>导航，一般用不到。</li></ul></li></ul><!----><ul><li><p><code>redirect</code>：用于指定如何处理重定向响应。</p><ul><li><code>follow</code>：默认值，跟踪重定向请求，以最终非重定向的<code>URL</code>的响应作为最终响应；</li><li><code>error</code>：遇到重定向时抛出错误；</li><li><code>manual</code>：不跟踪重定向，但是返回<code>opaqueredirect</code>类型的响应，并暴露期望重定向的<code>URL</code>。允许以手动方式跟踪重定向。</li></ul></li></ul><!----><ul><li><p><code>referrer</code>：用于指定<code>HTTP</code>的<code>Referer</code>头部的内容，值为以下字符串之一：</p><ul><li><code>no-referrer</code>：以<code>no-referrer</code>作为值；</li><li><code>client/about:client</code>：以当前<code>URL</code>或<code>no-referrer</code>作为值；</li><li><code>&lt;URL&gt;</code>：以伪造的<code>URL</code>作为值。伪造<code>URL</code>的源必须与执行脚本的源匹配。</li></ul></li></ul><h3 id="2-常见的Fetch请求模式"><a href="#2-常见的Fetch请求模式" class="headerlink" title="2. 常见的Fetch请求模式"></a>2. 常见的<code>Fetch</code>请求模式</h3><p>与<code>XMLHttpRequest</code>类似，<code>Fetch</code>既能够接收数据，也能够发送数据。</p><h4 id="1-发送JSON数据"><a href="#1-发送JSON数据" class="headerlink" title="(1) 发送JSON数据"></a>(1) 发送<code>JSON</code>数据</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;</span><br><span class="line">  <span class="attr">uname</span>: <span class="string">&quot;cc&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 初始化请求头</span></span><br><span class="line"><span class="keyword">let</span> jsonHeaders = <span class="keyword">new</span> <span class="title class_">Headers</span>(&#123;</span><br><span class="line">  <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/json&quot;</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&quot;/send-json-data&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">  <span class="attr">header</span>: jsonHeaders,</span><br><span class="line">  <span class="attr">body</span>: data,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="2-在请求体中发送参数"><a href="#2-在请求体中发送参数" class="headerlink" title="(2) 在请求体中发送参数"></a>(2) 在请求体中发送参数</h4><p>请求体可以是<code>String</code>实例，这意味着它可以是任意字符串，可以用来发送请求参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> params = <span class="string">&quot;uname=cc&amp;age=18&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> paramHeaders = <span class="keyword">new</span> <span class="title class_">Headers</span>(&#123;</span><br><span class="line">  <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/x-www-form-urlencoded; charset=UTF-8&quot;</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&quot;/send-params&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">  <span class="attr">header</span>: paramHeaders,</span><br><span class="line">  <span class="attr">body</span>: params,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="3-发送文件"><a href="#3-发送文件" class="headerlink" title="(3) 发送文件"></a>(3) 发送文件</h4><p>请求体可以是<code>FormData</code>实例，因此<code>fetch()</code>可以序列化并发送文件字段中的文件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化一个FormData实例</span></span><br><span class="line"><span class="keyword">let</span> formdata = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span><br><span class="line"><span class="comment">// 选择单文件输入器(假设已经选择了文件)</span></span><br><span class="line"><span class="keyword">let</span> fileInput = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;input[type=&quot;file&quot;]&#x27;</span>);</span><br><span class="line"><span class="comment">// 给formdata添加一个文件</span></span><br><span class="line">formdata.<span class="title function_">append</span>(<span class="string">&quot;file1&quot;</span>, fileInput.<span class="property">files</span>[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送文件</span></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&quot;/send-file&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">  <span class="attr">body</span>: formdata,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当然，也可以给<code>FormData</code>实例添加多个文件，然后通过<code>fetch()</code>发送多个文件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化一个FormData实例</span></span><br><span class="line"><span class="keyword">let</span> formdata = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span><br><span class="line"><span class="comment">// 选择多文件输入器(假设已经选择了文件)</span></span><br><span class="line"><span class="keyword">let</span> fileInput = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;input[type=&quot;file&quot;][multiple]&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给formdata添加多个文件</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; fileInput.<span class="property">files</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  formdata.<span class="title function_">append</span>(<span class="string">`file<span class="subst">$&#123;i + <span class="number">1</span>&#125;</span>`</span>, fileInput.<span class="property">files</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送文件</span></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&quot;send-files&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">  <span class="attr">body</span>: formdata,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="4-加载Blob文件"><a href="#4-加载Blob文件" class="headerlink" title="(4) 加载Blob文件"></a>(4) 加载<code>Blob</code>文件</h4><p><code>Fetch API</code>可以提供<code>Blob</code>类型的响应，而<code>Blob</code>类型又兼容多种浏览器<code>API</code>。以图片为例，可以将图片文件加载到内存，然后将其添加到<code>HTML</code>元素上。我们可以使用<code>Response</code>对象上的<code>blob()</code>方法，该方法返回一个期约，解决为一个<code>Blob</code>实例。将这个<code>Blob</code>实例传给<code>URL.createObjectUrl()</code>方法，可以生成添加给图片元素<code>src</code>属性的值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> img = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;img&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&quot;/cc.jpg&quot;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">resp</span>) =&gt;</span> resp.<span class="title function_">blob</span>())</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">blob</span>) =&gt;</span> &#123;</span><br><span class="line">    img.<span class="property">src</span> = <span class="variable constant_">URL</span>.<span class="title function_">createObjectUrl</span>(blob);</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appenChild</span>(img);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h4 id="5-发送跨源请求"><a href="#5-发送跨源请求" class="headerlink" title="(5) 发送跨源请求"></a>(5) 发送跨源请求</h4><p>发送跨源请求，响应头需要包含<code>CORS</code>头部才能保证浏览器收到响应。若没有这些头部，则跨源请求会失败并抛出错误。如果不需要访问响应，也可以发送<code>no-cors</code>请求，此时响应的类型为<code>opaque</code>，意思是无法读取响应，这种请求适合作为探测请求。</p><h4 id="6-中断请求"><a href="#6-中断请求" class="headerlink" title="(6) 中断请求"></a>(6) 中断请求</h4><p><code>Fetch API</code>可以通过 <code>AbortController/AbortSignal</code> 对来中断请求。调用<code>AbortController.abort()</code>方法会中断所有网络传输，尤其适合传输大型负载的情况 (如长视频) 。中断的<code>fetch()</code>请求会导致包含错误的拒绝。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> abortController = <span class="keyword">new</span> <span class="title class_">AbortController</span>();</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&quot;/cc-play-game.mp4&quot;</span>, &#123; <span class="attr">signal</span>: abortController.<span class="property">signal</span> &#125;).<span class="title function_">catch</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;请求已中断！&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 50毫秒后中断请求</span></span><br><span class="line"><span class="built_in">setTimeout</span>(abortController.<span class="property">abort</span>, <span class="number">50</span>);</span><br><span class="line"><span class="comment">// 请求已中断！</span></span><br></pre></td></tr></table></figure><h3 id="3-Headers对象"><a href="#3-Headers对象" class="headerlink" title="3. Headers对象"></a>3. <code>Headers</code>对象</h3><p><code>Headers</code>是所有请求和响应的头部的容器。每个外派的<code>Request</code>请求和入站的<code>Response</code>对象都有一个<code>Headers</code>实例，可以通过<code>Request.prototype.header</code>和<code>Response.prototype.header</code>来访问。这两个属性都可以修改，此外，也可以通过<code>new Headers()</code>来创建一个<code>Headers</code>实例。</p><h4 id="1-Headers-与-Map"><a href="#1-Headers-与-Map" class="headerlink" title="(1) Headers 与 Map"></a>(1) <code>Headers</code> 与 <code>Map</code></h4><p>这两者极其相似，都有<code>get()</code>，<code>set()</code>，<code>delete()</code>，<code>has()</code>等方法。都可以使用一个可迭代对象来初始化。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> seed = [[<span class="string">&quot;name&quot;</span>, <span class="string">&quot;cc&quot;</span>]];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> header = <span class="keyword">new</span> <span class="title class_">Headers</span>(seed);</span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>(seed);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(header.<span class="title function_">get</span>(<span class="string">&quot;name&quot;</span>)); <span class="comment">// cc</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="title function_">get</span>(<span class="string">&quot;name&quot;</span>)); <span class="comment">// cc</span></span><br></pre></td></tr></table></figure><p>都有相同的<code>keys()</code>，<code>values()</code>，<code>entries()</code> 迭代器接口。</p><h4 id="2-Headers独有的特性"><a href="#2-Headers独有的特性" class="headerlink" title="(2) Headers独有的特性"></a>(2) <code>Headers</code>独有的特性</h4><p><code>Headers</code>在初始化时，也可以使用键值对的形式，而<code>Map</code>不可以。<code>Headers</code>实例的一个字段，可以通过<code>append()</code>方法添加多个值，后续的值会以逗号分隔，拼接在原来的值后面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以键值对形式初始化</span></span><br><span class="line"><span class="keyword">const</span> header = <span class="keyword">new</span> <span class="title class_">Headers</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;cc&quot;</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(header.<span class="title function_">get</span>(<span class="string">&quot;name&quot;</span>)); <span class="comment">// cc</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给同一个字段追加值</span></span><br><span class="line">header.<span class="title function_">append</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;yy&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(header.<span class="title function_">get</span>(<span class="string">&quot;name&quot;</span>)); <span class="comment">// cc,yy</span></span><br></pre></td></tr></table></figure><h4 id="3-头部护卫"><a href="#3-头部护卫" class="headerlink" title="(3) 头部护卫"></a>(3) 头部护卫</h4><p>头部护卫根据<code>Request</code>对象的来源不同而不同，它能保护相关头部字段不被修改，违反护卫限制则会抛出<code>TypeError</code>。护卫只能是以下几种之一：</p><ul><li><code>none</code>：在通过构造函数创建<code>Headers</code>实例时激活，不会限制字段的修改；</li><li><code>request</code>：在通过构造函数初始化<code>Headers</code>实例，且<code>mode</code>值不为<code>no-cors</code>时激活，不允许修改禁止修改的请求头部；</li><li><code>request-no-cors</code>：在通过构造函数初始化<code>Headers</code>实例，且<code>mode</code>值为<code>no-cors</code>时激活，不允许修改非简单头部；</li><li><code>response</code>：在通过构造函数初始化<code>Response</code>对象时激活，不允许修改禁止修改的响应头部；</li><li><code>immutable</code>：在通过<code>error()</code>或<code>redirect()</code>静态方法初始化<code>Response</code>对象时激活，不允许修改任何头部。</li></ul><h3 id="4-Request对象"><a href="#4-Request对象" class="headerlink" title="4. Request对象"></a>4. <code>Request</code>对象</h3><h4 id="1-创建Request对象"><a href="#1-创建Request对象" class="headerlink" title="(1) 创建Request对象"></a>(1) 创建<code>Request</code>对象</h4><p>可以通过构造函数来创建，需要传入一个<code>input</code>参数，一般是<code>URL</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> req = <span class="keyword">new</span> <span class="title class_">Request</span>(<span class="string">&quot;https://www.baidu.com&quot;</span>);</span><br></pre></td></tr></table></figure><p>也接收第二个参数，一个<code>init</code>对象。与<code>fetch()</code>接收的参数一样，不在赘述。</p><h4 id="2-克隆Request对象"><a href="#2-克隆Request对象" class="headerlink" title="(2) 克隆Request对象"></a>(2) 克隆<code>Request</code>对象</h4><ul><li>使用构造函数来克隆；</li><li>使用<code>clone()</code>方法来克隆。</li></ul><p>将一个<code>Request</code>实例传给构造函数，可以得到该请求对象的一个副本。如果同时传入了<code>init</code>对象，则<code>init</code>对象的值会覆盖原来的同名字段。使用这种方法克隆请求对象之后，源请求对象会被标记为 <strong>已使用</strong> ，即其<code>bodyUsed</code>属性会变为<code>true</code>。如果源对象与新对象不同源，则新对象的<code>referrer</code>属性会被清除。此外，如果源对象的<code>mode</code>属性为<code>navigate</code>，则新对象的<code>mode</code>属性会被转换为<code>same-origin</code>。</p><p>第二中克隆方式是使用<code>clone()</code>方法，这个方法会得到一模一样的实例。且不会把任何请求的请求体标记为<strong>已使用</strong>。</p><p>需要注意的是，不论使用哪种方式，只有<code>bodyUsed</code>为<code>false</code>的请求对象才可以被克隆，否则会抛出<code>TypeError</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> req1 = <span class="keyword">new</span> <span class="title class_">Request</span>(<span class="string">&quot;https://www.baidu.com&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> req11 = req1.<span class="title function_">clone</span>(req1);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Request</span>(req1);</span><br><span class="line"><span class="comment">// 没有错误</span></span><br><span class="line"></span><br><span class="line">req1.<span class="title function_">text</span>(); <span class="comment">// 使用req1，会将其bodyUsed标记为true</span></span><br><span class="line"></span><br><span class="line">req1.<span class="title function_">clone</span>(); <span class="comment">// TypeError</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Request</span>(req1); <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><h4 id="3-在fetch-中使用Request对象"><a href="#3-在fetch-中使用Request对象" class="headerlink" title="(3) 在fetch()中使用Request对象"></a>(3) 在<code>fetch()</code>中使用<code>Request</code>对象</h4><p><strong>给<code>fetch()</code>传入<code>Request</code>实例，相当于在<code>fetch()</code>内部使用<code>Request</code>构造函数克隆了一份传入的<code>Request</code>实例</strong>。同样的，给<code>fetch()</code>对象传入的第二个参数<code>init</code>的值会覆盖<code>Request</code>实例上的同名字段；请求体被标记为已使用的<code>Request</code>实例传给<code>fetch()</code>也会抛出<code>TypeError</code>；被<code>fetch()</code>使用过的请求对象，其请求体会被标记为已使用，无法再次传给<code>fetch()</code>使用，当然，没有请求体的<code>Request</code>实例不受此限制，因此，如要复用<code>Request</code>实例，则每次传给<code>fetch()</code>的应该是使用<code>clone()</code>方法克隆出来的实例副本。</p><h3 id="5-Response对象"><a href="#5-Response对象" class="headerlink" title="5. Response对象"></a>5. <code>Response</code>对象</h3><h4 id="1-创建Response对象"><a href="#1-创建Response对象" class="headerlink" title="(1) 创建Response对象"></a>(1) 创建<code>Response</code>对象</h4><p>可以通过构造函数创建<code>Response</code>对象，且无需任何参数。此时创建的实例各属性均为默认值，因为它并不代表实际的<code>HTTP</code>响应。</p><h4 id="2-克隆-Response对象"><a href="#2-克隆-Response对象" class="headerlink" title="(2) 克隆 Response对象"></a>(2) 克隆 <code>Response</code>对象</h4><p>主要使用<code>clone()</code>方法，创建一个一模一样的实例副本，且不会将<code>bodyUsed</code>属性标记为<code>true</code>。</p><h3 id="6-Request、Response、Body混入"><a href="#6-Request、Response、Body混入" class="headerlink" title="6. Request、Response、Body混入"></a>6. <code>Request</code>、<code>Response</code>、<code>Body</code>混入</h3><p><code>Request</code>和<code>Response</code>对象都使用了<code>Fetch API</code>的<code>Body</code>混入，这个混入为两种类型提供了只读的<code>body</code>属性 (实现为<code>ReadableStream</code>) 、<code>bodyUsed</code> (标记 body 流是否已读)，以及一组方法，用于读取<code>body</code>流的内容并转换为某种类型的<code>JavaScript</code>对象类型。</p><p><code>Body</code>混入提供了 5 种方法，用于读取流内容并转换为对应的<code>JavaScript</code>对象类型。</p><h4 id="1-Body-text"><a href="#1-Body-text" class="headerlink" title="(1) Body.text()"></a>(1) <code>Body.text()</code></h4><p>返回一个期约，解决为<code>utf-8</code>格式的字符串。如下例演示了在<code>Response</code>对象上使用<code>text()</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&quot;/cc-intro.com&quot;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">resp</span>) =&gt;</span> resp.<span class="title function_">text</span>())</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">txt</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(txt));</span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;</span></span><br><span class="line"><span class="comment">//   &lt;head&gt;</span></span><br><span class="line"><span class="comment">//     &lt;meta charset=&quot;utf-8&quot;&gt;</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h4 id="2-Body-json"><a href="#2-Body-json" class="headerlink" title="(2) Body.json()"></a>(2) <code>Body.json()</code></h4><p>返回一个期约，解决为<code>JSON</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&quot;/cc-intro.json&quot;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">resp</span>) =&gt;</span> resp.<span class="title function_">json</span>())</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">json</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(json));</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;name: &quot;cc&quot;, age: 18&#125;</span></span><br></pre></td></tr></table></figure><h4 id="3-Body-formdata"><a href="#3-Body-formdata" class="headerlink" title="(3) Body.formdata()"></a>(3) <code>Body.formdata()</code></h4><p>返回一个期约，解决为<code>FormData</code>实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://cc.com/form-data&#x27;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> response.<span class="title function_">formData</span>())</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">formData</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(formData.<span class="title function_">get</span>(<span class="string">&#x27;name&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// cc</span></span><br></pre></td></tr></table></figure><h4 id="4-Body-arrayBuffer"><a href="#4-Body-arrayBuffer" class="headerlink" title="(4) Body.arrayBuffer()"></a>(4) <code>Body.arrayBuffer()</code></h4><p>返回期约，解决为<code>ArrayBuffer</code>实例。</p><h4 id="5-Body-blob"><a href="#5-Body-blob" class="headerlink" title="(5) Body.blob()"></a>(5) <code>Body.blob()</code></h4><p>返回期约，解决为<code>Blob</code>实例。</p><h4 id="6-一次性流"><a href="#6-一次性流" class="headerlink" title="(6) 一次性流"></a>(6) 一次性流</h4><p><code>Body</code>混入是建立在<code>ReadableStream</code>的基础之上的，因此主体流只能使用一次，这意味着以上五种方法只能选择其中的一种调用一次，再次调用以上任何方法则会报错。</p><h4 id="7-使用ReadableStream主体"><a href="#7-使用ReadableStream主体" class="headerlink" title="(7) 使用ReadableStream主体"></a>(7) 使用<code>ReadableStream</code>主体</h4><p>由于对流的理解尚为浅薄，此处暂时就不班门弄斧来介绍相关要点了。</p><h2 id="六、-Beacon-API"><a href="#六、-Beacon-API" class="headerlink" title="六、 Beacon API"></a>六、 <code>Beacon API</code></h2><p>在页面关闭(<code>unload</code>)事件触发时，分析工具应停止收集信息，并将收集到的信息发送给服务器。异步<code>XMLHttpRequest</code>或<code>fetch()</code>都不太适合这个任务，因为浏览器会将<code>unload</code>事件处理程序中的网络请求取消，毕竟对浏览器而言，没有任何理由需要在页面关闭后还继续发送请求。虽然同步<code>XMLHttpRequest</code>可以完成这个任务，但是会造成用户关闭浏览器的延迟，影响用户体验。(实际上，设置<code>fetch()</code>中的<code>init</code>参数对象的<code>keepalive</code>为<code>true</code>，也可以允许在页面关闭后维持请求的生命周期。)</p><p>为此，<code>W3C</code>引入了<code>Beacon API</code>来解决这个问题。这个<code>API</code>给<code>navigator</code>对象增加了一个<code>sendBeacon()</code>方法，发送一个<code>POST</code>请求。此处不作详细介绍。</p><h2 id="七、-Web-Socket"><a href="#七、-Web-Socket" class="headerlink" title="七、 Web Socket"></a>七、 <code>Web Socket</code></h2><p><code>Web Socket</code>（套接字）的目标是通过一个长时连接实现与服务器全双工、双向的通信。使用自定义协议：<code>ws://</code>、<code>wss://</code>，前者是非安全连接，后者是安全连接，而不再使用<code>http://</code>、<code>https://</code>。使用自定义协议，允许客户端和服务器之间发送非常少的数据，不会给<code>HTTP</code>造成任何负担。</p><h3 id="1-API"><a href="#1-API" class="headerlink" title="1. API"></a>1. <code>API</code></h3><p>要创建一个新的<code>Web Socket</code>，就要提供一个<strong>绝对<code>URL</code>链接</strong>来实例化一个<code>WebSocket</code>对象。浏览器同源策略不适用于<code>Web Socket</code>，因此传入的<code>URL</code>可以是打开到任意站点的链接。而是否与特定源的页面通信，就完全取决于服务器了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&quot;ws://baidu.com&quot;</span>);</span><br></pre></td></tr></table></figure><p>浏览器在初始化<code>Web Socket</code>后会立即简历连接。与<code>XHR</code>类似，<code>Web Socket</code>也有一个<code>readyState</code>属性表示连接状态，但是其取值与<code>XHR</code>不一样。</p><ul><li><code>WebSocket.OPENING(0)</code>：正在连接；</li><li><code>WebSocket.OPEN</code>(1)：连接已经建立；</li><li><code>WebSocket.CLOSING(2)</code>：正在关闭连接；</li><li><code>WebSocket.CLOSE(3)</code>：连接已关闭。</li></ul><p><code>WebSocket</code>对象没有<code>readystatechange</code>事件，不过有与各个状态的其它事件。<code>readyState</code>的值从 0 开始。</p><p>任何时候都可以调用<code>close()</code>方法来关闭连接：<code>ws.close()</code>。调用关闭方法之后，<code>readyState</code>的值立即变为 2，并在关闭完成之后变为 3。</p><h3 id="2-发送-与-接收数据"><a href="#2-发送-与-接收数据" class="headerlink" title="2. 发送 与 接收数据"></a>2. 发送 与 接收数据</h3><p>要向服务器发送数据，可以使用<code>send()</code>方法，传入一个字符串、<code>ArrayBuffer</code> 或者 <code>Blob</code> 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&quot;wss://www.baidu.com&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> strData = <span class="string">&quot;I am cc&quot;</span>,</span><br><span class="line">  arrayBuffer = int8Array.<span class="title function_">from</span>([<span class="string">&quot;f&quot;</span>, <span class="string">&quot;o&quot;</span>, <span class="string">&quot;o&quot;</span>]),</span><br><span class="line">  blobData = <span class="keyword">new</span> <span class="title class_">Blob</span>([<span class="string">&quot;c&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="number">18</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送字符串数据</span></span><br><span class="line">ws.<span class="title function_">send</span>(strData);</span><br><span class="line"><span class="comment">// 发送ArrayBuffer数据</span></span><br><span class="line">ws.<span class="title function_">send</span>(arrayBuffer);</span><br><span class="line"><span class="comment">// 发送Blob数据</span></span><br><span class="line">ws.<span class="title function_">send</span>(blobData);</span><br></pre></td></tr></table></figure><p>当服务器向客户端发送消息时，<code>WebSocket</code>对象会触发<code>message</code>事件，可以在<code>onmessage</code>事件处理程序中进行处理。该事件与其它消息协议类似，接收一个<code>event</code>事件对象，且可以通过<code>event.data</code>来访问到有效载荷：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ws.<span class="property">onmessage</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">data</span>);</span><br><span class="line">  <span class="comment">// 其它处理</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>与<code>send()</code>方法相似，接收到的<code>event.data</code>也可能是<code>ArrayBuffer</code>或<code>Blob</code>。这由<code>WebSocket</code>对象的<code>binaryType</code>决定，该属性可能是<code>blob</code>或<code>arraybuffer</code>。</p><h3 id="3-其它事件"><a href="#3-其它事件" class="headerlink" title="3. 其它事件"></a>3. 其它事件</h3><p>在<code>WebSocket</code>的连接生命周期中，有可能会触发其它三个事件：</p><ul><li><code>open</code>：在成功建立连接时触发；</li><li><code>error</code>：在发生错误时触发，触发后连接无法存续；</li><li><code>close</code>：在成功关闭连接时触发。</li></ul><p><code>WebSocket</code>事件不支持<code>DOM LEVEL 2</code>事件监听（即<code>addEventListener()</code>方式），因此需要使用<code>DOM LEVEL 0</code>风格的事件处理程序来监听：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&quot;wss://www.baidu.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">ws.<span class="property">onopen</span> = <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;连接成功！&quot;</span>);</span><br><span class="line"></span><br><span class="line">ws.<span class="property">onclose</span> = <span class="function">(<span class="params">e</span>) =&gt;</span> conssole.<span class="title function_">log</span>(<span class="string">&quot;连接已断开！&quot;</span>);</span><br><span class="line"></span><br><span class="line">ws.<span class="property">onerror</span> = <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;连接发生错误！！&quot;</span>);</span><br></pre></td></tr></table></figure><p>这三个事件中，只有<code>close</code>事件的<code>event</code>对象上有额外信息。该对象上有 3 个额外属性：</p><ul><li><code>wasClean</code>：布尔值，表示连接是否干净地关闭；</li><li><code>code</code>：来自服务器的数值状态码；</li><li><code>reason</code>：字符串，包含服务器发来的消息。</li></ul><p>可以将这些信息显示给用户，或者记录到日志里。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前 端 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js温故(三)：ES5 的对象与继承</title>
      <link href="/articals/ee9e9f63/"/>
      <url>/articals/ee9e9f63/</url>
      
        <content type="html"><![CDATA[<p><code>ES6</code>新增了<code>class</code>来替代之前的构造函数，并且通过<code>extends</code>关键字可以轻易实现继承。不过<code>ES</code>的概念中，暂时还没有<code>class</code>这一类型，不管从哪方面来看，<code>class</code>都是对之前的继承方案的封装，其本质上是函数(<code>Function</code>的实例) 。了解一下<code>ES6</code>之前的各种继承方案，有助于加深对<code>class</code>继承的理解。</p><h2 id="一、创建对象"><a href="#一、创建对象" class="headerlink" title="一、创建对象"></a>一、创建对象</h2><h3 id="1-工厂模式"><a href="#1-工厂模式" class="headerlink" title="1. 工厂模式"></a>1. 工厂模式</h3><p>当需要创建多个对象实例，且他们的属性高度重复时，无论是通过对象字面量来创建，还是使用<code>new Object</code>来创建，都非常麻烦。采用工厂模式，可以很方便地批量创建多个具有相同属性的对象实例，为此，需要定义一个工厂函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个工厂函数，用于创建对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createPerson</span>(<span class="params">name, age, gender, ...rest</span>) &#123;</span><br><span class="line">  <span class="comment">// 创建一个空对象person</span></span><br><span class="line">  <span class="keyword">const</span> person = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 将参数上的属性添加到person上(增强对象)</span></span><br><span class="line">  person.<span class="property">name</span> = name;</span><br><span class="line">  person.<span class="property">age</span> = age;</span><br><span class="line">  person.<span class="property">gender</span> = gender;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 返回该对象person</span></span><br><span class="line">  <span class="keyword">return</span> person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂函数定义好了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后可以使用该函数来批量生产对象</span></span><br><span class="line"><span class="keyword">const</span> cc = <span class="title function_">createPerson</span>(<span class="string">&quot;cc&quot;</span>, <span class="number">18</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line"><span class="comment">// 没有传入gender参数，则对应yy.gender的值为undefined</span></span><br><span class="line"><span class="keyword">const</span> yy = <span class="title function_">createPerson</span>(<span class="string">&quot;yy&quot;</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有对象标识，instanceof操作符只能检测出来cc和yy是Object</span></span><br></pre></td></tr></table></figure><p>可见，工厂函数就是一个普通函数，创建空对象、增强对象、返回对象 三步走，它可以解决批量创建相似对象的问题，但是创建出来的对象没有标识，我们难以区分他们是什么类型。</p><h3 id="2-构造函数模式"><a href="#2-构造函数模式" class="headerlink" title="2. 构造函数模式"></a>2. 构造函数模式</h3><p>构造函数模式在工厂模式的基础上加以改进。无需显示地创建空对象，且把属性赋值给<code>this</code>，也不需要显示<code>return</code>，使用<code>new</code>操作符来创建实例对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义构造函数，函数名首字母大写，以区分于普通函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, gender, ...rest</span>) &#123;</span><br><span class="line">  <span class="comment">// 没有也不需要显示创建对象</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 属性赋值给this</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">gender</span> = gender;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">playGame</span> = <span class="function">(<span class="params">gameName</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;gameName&#125;</span> start!!`</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 没有也不需要return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用new操作符来创建对象</span></span><br><span class="line"><span class="keyword">const</span> cc = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;cc&quot;</span>, <span class="number">18</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line"><span class="comment">// 没有传入gender参数，对应yy.gender为undefined</span></span><br><span class="line"><span class="keyword">const</span> yy = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;yy&quot;</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例对象的constructor属性，指向构造函数Person</span></span><br><span class="line"><span class="comment">// 事实上这个属性存在于原型上</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cc.<span class="property">constructor</span> === <span class="title class_">Person</span>); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// // 有对象标识，instanceof操作符可以检测出cc和yy是Person类型</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cc <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(yy <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>构造函数模式不仅代码上看更加简洁（不需要显示创建对象以及<code>return</code>），而且通过<code>new</code>操作符来创建的实例对象，具有对象标识，可以轻松地使用<code>instanceof</code>操作符来检测它们是否属于某一类型。</p><p>此外，构造函数也是函数，除了与<code>new</code>操作符搭配使用以外，也可以当作普通函数来直接调用。此时，如果没有使用<code>call/apply</code>等方式来改变<code>this</code>指向，则<code>this</code>会指向<code>Global</code>对象，在浏览器中即<code>window</code>对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不改变this指向，则this指向window，即把相应的属性都添加到window上</span></span><br><span class="line"><span class="title class_">Person</span>(<span class="string">&quot;ww&quot;</span>, <span class="number">20</span>);</span><br><span class="line"><span class="comment">// window.name, window.age</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name, age); <span class="comment">// &#x27;ww&#x27; 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用call改变this指向</span></span><br><span class="line"><span class="keyword">const</span> boy = &#123;&#125;;</span><br><span class="line"><span class="title class_">Person</span>.<span class="title function_">call</span>(boy, <span class="string">&quot;cc&quot;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(boy); <span class="comment">// &#123;name: &#x27;cc&#x27;, age: 18, gender: undefined, playGame: f&#125;</span></span><br></pre></td></tr></table></figure><p>对象函数模式的问题，在于其定义的方法会在每个实例上都创建一边。如上栗子中，<code>cc</code>和<code>yy</code>都有<code>playGame()</code>方法，但是他们的方法并不是引用的同一个，而是各自单独的实例，即<code>cc.playGame === yy.playGame</code>会得到<code>false</code>。这显然会造成不必要的浪费。我们可以把函数定义转移到构造函数外部，来解决这个问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义构造函数，函数名首字母大写，以区分于普通函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, gender, ...rest</span>) &#123;</span><br><span class="line">  <span class="comment">// 属性赋值给this</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">gender</span> = gender;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 引用定义在构造函数外部的同一个方法playGame</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">playGame</span> = playGame;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">playGame</span>(<span class="params">gameName</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;gameName&#125;</span> start!!`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cc = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;cc&quot;</span>),</span><br><span class="line">  yy = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;yy&quot;</span>);</span><br><span class="line"><span class="comment">// 此时各个实例的playGame方法就都是同一个</span></span><br><span class="line">cc.<span class="property">playGame</span> === yy.<span class="property">playGame</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如此这般，虽然可以解决实例对象共享方法的问题，但是由于方法定义在构造函数外部，导致全局可调用该函数，而且一旦共享的方法多了，就需要在外部定义很多函数，不方便管理与维护。</p><h3 id="3-原型模式"><a href="#3-原型模式" class="headerlink" title="3. 原型模式"></a>3. 原型模式</h3><p>关于原型在此不过多赘述，每个函数都会创建一个<code>prototype</code>属性，即函数的原型对象，包含其实例对象所共享的方法和属性。因此，在构造函数中把值赋给原型对象，则可以让其实例对象共享这些值/方法。这里主要有两种方式，一种是给已有的原型对象添加新的属性和方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给已有的原型添加新的属性/方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ptototype为Person.prototype的引用</span></span><br><span class="line">  <span class="keyword">const</span> prototype = <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">  <span class="comment">// 往Person.prototype上添加属性和方法</span></span><br><span class="line">  prototype.<span class="property">name</span> = <span class="string">&quot;cc&quot;</span>;</span><br><span class="line">  prototype.<span class="property">age</span> = <span class="number">18</span>;</span><br><span class="line">  prototype.<span class="property">playGame</span> = <span class="function">(<span class="params">game</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;game&#125;</span> start!!`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cc = <span class="keyword">new</span> <span class="title class_">Person</span>(),</span><br><span class="line">  yy = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="comment">// cc和yy本身是空对象，但是可以访问原型上的属性和方法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cc.<span class="property">name</span>); <span class="comment">// cc</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(yy.<span class="property">name</span>); <span class="comment">// yy</span></span><br></pre></td></tr></table></figure><p>另一种是把需要添加的属性/方法集中在一个对象中，然后赋给原型对象。这会导致构造函数的原型被重写，与之前已有的原型不再有关联，也得手动让<code>constructor</code>属性重新指向构造函数本身。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重写原型</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 将要添加的属性集中到一个对象上</span></span><br><span class="line">  <span class="keyword">const</span> prototype = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;cc&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="title function_">playGame</span>(<span class="params">game</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;game&#125;</span> start!!`</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 注意重新调整constructor指向</span></span><br><span class="line">    <span class="attr">constructor</span>: <span class="title class_">Person</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 赋给Person.prototype</span></span><br><span class="line">  <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = prototype;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于重写原型会使构造函数的原型指向一个新的对象，这会导致在执行重写原型的操作前后实例化的对象具有不同的原型，这点尤为值得注意。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 什么都不做</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给原型添加属性</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&quot;cc&quot;</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">playGame</span> = <span class="function">(<span class="params">game</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;game&#125;</span> start!!`</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时尚未重写原型</span></span><br><span class="line"><span class="keyword">const</span> cc = <span class="keyword">new</span> <span class="title class_">Person</span>(); <span class="comment">// 不传参时可以省略括号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写Person的原型</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;yy&quot;</span>,</span><br><span class="line">  <span class="title function_">playGame</span>(<span class="params">game</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;You are not allowed to play game !!&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">constructor</span>: <span class="title class_">Person</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> yy = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cc.<span class="property">name</span>); <span class="comment">// cc</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(yy.<span class="property">name</span>); <span class="comment">// yy</span></span><br><span class="line"></span><br><span class="line">cc.<span class="title function_">playGame</span>(<span class="string">&quot;Don&#x27;t Starve Together&quot;</span>); <span class="comment">// Don&#x27;t Starve Together start!!</span></span><br><span class="line">yy.<span class="title function_">playGame</span>(<span class="string">&quot;Don&#x27;t Starve Together&quot;</span>); <span class="comment">// You are not allowed to play game !!</span></span><br></pre></td></tr></table></figure><p>原型模式弱化了向构造函数传参来自定义属性值的能力，且通过原型共享的引用类型也会在各个实例之间相互影响，因此，原型模式基本不会单独应用。往往是将构造函数模式和原型模式进行结合。</p><h2 id="二、继承"><a href="#二、继承" class="headerlink" title="二、继承"></a>二、继承</h2><h3 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1. 原型链继承"></a>1. 原型链继承</h3><p>原型链的概念在此不做赘述。将一个构造函数 A 的原型，重写为另一个构造函数 B 的一个实例对象，由于该实例对象可以访问构造函数 B 的原型上的属性和方法，当成为构造函数 A 的原型时，则构造函数 A 的实例对象也可以访问构造函数 B 的原型上的属性/方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">B</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = <span class="number">18</span>;</span><br><span class="line">  B.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">  b.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">playGame</span> = <span class="keyword">function</span> (<span class="params">game</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;game&#125;</span> start!!`</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A通过原型链继承构造函数B</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// prototype上有个age属性，值为18，也会被继承下去</span></span><br><span class="line">  <span class="keyword">const</span> prototype = <span class="keyword">new</span> <span class="title function_">B</span>();</span><br><span class="line">  A.<span class="property"><span class="keyword">prototype</span></span> = prototype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时A的实例对象也可以访问B的原型上的属性/方法</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line">a.<span class="property">name</span>; <span class="comment">// &#x27;b&#x27;</span></span><br><span class="line">a.<span class="title function_">playGame</span>(<span class="string">&quot;Don&#x27;t Starve Together&quot;</span>); <span class="comment">// Don&#x27;t Starve Together start!!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 原先构造函数B的实例属性age也会变成A的原型属性</span></span><br><span class="line">a.<span class="property">age</span>; <span class="comment">// 18</span></span><br></pre></td></tr></table></figure><p>通过原型链继承，弱化了向构造函数传参的能力，且父类构造函数的实例属性/方法也会成为子类构造函数的原型属性/方法，这在某些时候会导致问题。</p><h3 id="2-经典继承：盗用构造函数"><a href="#2-经典继承：盗用构造函数" class="headerlink" title="2. 经典继承：盗用构造函数"></a>2. 经典继承：盗用构造函数</h3><p>通过原型链继承，父类的实例属性/方法会变成子类的原型属性/方法，且难以通过向构造函数传参来自定义属性值，这显然不是我们想要的。通过<code>call</code>/<code>apply</code>在子类构造函数中来盗用父类构造函数，可以让父类构造函数的实例属性/方法在子类中也同样赋值操作一遍，子类即可获得父类的实例属性/方法，但是并没有继承父类的原型属性/方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">B</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  B.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">playGame</span> = <span class="keyword">function</span> (<span class="params">game</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;game&#125;</span> start!!`</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在构造函数A中盗用构造函数B</span></span><br><span class="line"><span class="comment">// 使用了call来改变this指向</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  B.<span class="title function_">call</span>(<span class="variable language_">this</span>, name, age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title function_">A</span>(<span class="string">&quot;a&quot;</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="title function_">B</span>(<span class="string">&quot;b&quot;</span>, <span class="number">10</span>);</span><br><span class="line">a.<span class="property">name</span>; <span class="comment">// &#x27;a&#x27;</span></span><br><span class="line">a.<span class="property">age</span>; <span class="comment">// 5</span></span><br><span class="line">b.<span class="property">name</span>; <span class="comment">// &#x27;b&#x27;</span></span><br><span class="line">b.<span class="property">age</span>; <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">b.<span class="title function_">playGame</span>(<span class="string">&quot;Don&#x27;t Starve Together&quot;</span>); <span class="comment">// Don&#x27;t Starve Together start!!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有继承构造函数B的原型方法</span></span><br><span class="line"><span class="comment">// 报错：a.playGame is not a function</span></span><br><span class="line">a.<span class="title function_">playGame</span>(<span class="string">&quot;Don&#x27;t Starve Together&quot;</span>);</span><br></pre></td></tr></table></figure><p>盗用构造函数的方式无法继承原型上的内容，这一点可以通过原型链继承来弥补。因此将二者组合，便可以实现一个完整的继承。</p><h3 id="3-组合继承"><a href="#3-组合继承" class="headerlink" title="3. 组合继承"></a>3. 组合继承</h3><p>组合继承是将原型链继承和盗用构造函数继承结合起来。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义父类构造函数Person</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = <span class="number">20</span>;</span><br><span class="line">  <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">playGame</span> = <span class="keyword">function</span> (<span class="params">game</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;game&#125;</span> start!!`</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义子类构造函数Student</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">name, age, school</span>) &#123;</span><br><span class="line">  <span class="comment">// 盗用Person构造函数，来继承name，age属性</span></span><br><span class="line">  <span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name, age);</span><br><span class="line">  <span class="comment">// 添加自己的school属性</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">school</span> = school;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型链继承</span></span><br><span class="line"><span class="keyword">const</span> prototype = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">prototype.<span class="property">constructor</span> = <span class="title class_">Student</span>;</span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span> = prototype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cc = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;cc&quot;</span>, <span class="number">18</span>, <span class="string">&quot;cc-school&quot;</span>);</span><br><span class="line"><span class="comment">// 访问Student的实例属性</span></span><br><span class="line"><span class="comment">// 这里访问到的属性是属于cc本身的实例属性</span></span><br><span class="line">cc.<span class="property">name</span>; <span class="comment">// &#x27;cc&#x27;</span></span><br><span class="line">cc.<span class="property">age</span>; <span class="comment">// 18</span></span><br><span class="line">cc.<span class="property">school</span>; <span class="comment">// &#x27;cc-school&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 而playGame()方法继承自原型链</span></span><br><span class="line">cc.<span class="title function_">playGame</span>(<span class="string">&quot;Don&#x27;t Starve Together&quot;</span>); <span class="comment">// Don&#x27;t Starve Together start!!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 事实上，Student的原型上也会有原型属性 name 和 age，这是在原型链继承时，</span></span><br><span class="line"><span class="comment">// 从Person的一个实例对象用作Student的原型时得到的，根据实例化时是否传参，其值可能是undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型上有该属性，但是其值为undefined</span></span><br><span class="line">cc.<span class="property">__proto__</span>.<span class="property">name</span>; <span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// 原型上有该属性，且其值为20</span></span><br><span class="line">cc.<span class="property">__proto__</span>.<span class="property">age</span>; <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于cc本身的 name 和 age 属性遮盖了其原型上的 name 和 age 属性，</span></span><br><span class="line"><span class="comment">// 因此通过cc访问到的 name 和 age 是其本身的属性</span></span><br><span class="line">cc.<span class="property">name</span>; <span class="comment">// &#x27;cc&#x27;</span></span><br><span class="line">cc.<span class="property">age</span>; <span class="comment">// 18</span></span><br></pre></td></tr></table></figure><p>上面的栗子中，可以看到，在继承的实现过程中，父类构造函数调用了两次：一次是盗用父类构造函数，通过<code>call</code>调用，另一次是原型链继承时，通过<code>new</code>操作符调用。父类构造函数的实例属性/方法，既通过盗用构造函数继承为子类的实例属性/方法，又通过原型链继承成为子类的原型属性/方法。这在实现了完整的继承的同时，也造成了不必要的浪费。</p><h3 id="4-寄生式继承"><a href="#4-寄生式继承" class="headerlink" title="4. 寄生式继承"></a>4. 寄生式继承</h3><p>组合继承的缺陷主要来自其中的原型链继承，会把父类的实例属性/对象也变为子类的原型属性/对象，而我们只希望在原型链中继承父类的原型链，而不希望父类的实例属性/方法也成为子类的原型链的一部分。寄生式继承为解决这个问题提供了思路。</p><p>寄生式继承主要分三步：创建对象、增强对象、返回对象。主要用于无需创建构造函数，而是基于一个对象<code>obj</code>，创建另一个增强版的对象<code>obj2</code>，来实现对<code>obj</code>的继承。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">create</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="comment">// 以传入的参数 obj 作为原型创建一个新对象</span></span><br><span class="line">  <span class="keyword">const</span> newObj = <span class="title class_">Object</span>.<span class="title function_">create</span>(obj);</span><br><span class="line">  <span class="comment">// 增强该对象</span></span><br><span class="line">  newObj.<span class="property">name</span> = <span class="string">&quot;new-obj&quot;</span>;</span><br><span class="line">  <span class="comment">// 返回该对象</span></span><br><span class="line">  <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;person&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="title function_">playGame</span>(<span class="params">game</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;game&#125;</span> start!!`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="title function_">create</span>(person);</span><br><span class="line">p2.<span class="property">name</span>; <span class="comment">// &#x27;new-obj&#x27;</span></span><br><span class="line">p2.<span class="property">age</span>; <span class="comment">// 18</span></span><br><span class="line">p2.<span class="title function_">playGame</span>(<span class="string">&quot;Don&#x27;t Starve Together&quot;</span>); <span class="comment">// Don&#x27;t Starve Together start!!</span></span><br></pre></td></tr></table></figure><p>这里使用了<code>Object.create()</code>方法，在只传一个对象作为参数时，这个方法会返回一个以该对象为原型的空对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">obj_create</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">Fun</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="title class_">Fun</span>.<span class="property"><span class="keyword">prototype</span></span> = obj;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就能避免组合继承中通过原型链继承带来的问题，且父类构造函数不再需要调用两次。</p><h3 id="5-最佳模式：寄生式组合继承"><a href="#5-最佳模式：寄生式组合继承" class="headerlink" title="5. 最佳模式：寄生式组合继承"></a>5. 最佳模式：寄生式组合继承</h3><p>将寄生式继承的思路引入到组合继承中，成为<code>ES5</code>引用类型的<strong>最佳继承模式</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 封装一个函数通过寄生式继承思想，来继承原型属性/方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">newPrototype</span>(<span class="params">SuperType, SubType</span>)&#123;</span><br><span class="line">  <span class="comment">// 以父类的原型作为原型，创建一个干干净净的空对象prototype</span></span><br><span class="line">  <span class="keyword">const</span> prototype = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line">  <span class="comment">// 更改constructor属性，当然，这里最好使用Object.definedProperty，并使其不可被修改</span></span><br><span class="line">  prototype.<span class="property">constructor</span> = <span class="title class_">SubType</span></span><br><span class="line">  <span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span> = prototype</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义父类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">playGame</span> = <span class="function">(<span class="params">game</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;game&#125;</span> start!!`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义子类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">name, age, school</span>)&#123;</span><br><span class="line">  <span class="comment">// 继承实例属性/方法</span></span><br><span class="line">  <span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name, age)</span><br><span class="line">  <span class="comment">// 添加自己的实例属性/方法</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">school</span> = school</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承原型属性/方法</span></span><br><span class="line"><span class="title function_">newPrototype</span>(<span class="title class_">Person</span>, <span class="title class_">Student</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cc = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&#x27;cc&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;cc-school&#x27;</span>)</span><br><span class="line">cc.<span class="property">name</span><span class="comment">// &#x27;cc&#x27;</span></span><br><span class="line">cc.<span class="property">age</span><span class="comment">// 18</span></span><br><span class="line">cc.<span class="property">school</span><span class="comment">// &#x27;cc-school&#x27;</span></span><br><span class="line"></span><br><span class="line">cc..<span class="title function_">playGame</span>(<span class="string">&quot;Don&#x27;t Starve Together&quot;</span>)<span class="comment">// Don&#x27;t Starve Together start!!</span></span><br></pre></td></tr></table></figure><p><code>ES5</code>及其之前的对象创建与继承基本都回顾了一遍，有空再整理下<code>ES6</code>的<code>class</code>及其与构造函数的对比。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前 端 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js温故(二)：symbol</title>
      <link href="/articals/227b619f/"/>
      <url>/articals/227b619f/</url>
      
        <content type="html"><![CDATA[<p>自<code>ES6</code>中<code>symbol</code>问世以来，个人在项目中并没有太多机会使用到，小公司业务项目没有给<code>symbol</code>太多的登场机会。因此之前也只稍微知晓了概念，没有详细了解。如今重温<code>js</code>，自然要重新认识一下这独一无二的<code>symbol</code>。如你所知，<code>symbol</code>是原始值(基本数据类型)，其每个实例是独一无二且不可变的，一般作为对象属性使用，确保对象属性独一无二，避免属性冲突。</p><p>[toc]</p><h2 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1. 基本用法"></a>1. 基本用法</h2><p>符号只能通过函数来创建实例。最基本的就是<strong><code>Symbol()</code></strong>函数：可以使用<code>Symbol()</code>函数来创建一个符号实例。有以下几点需要注意：</p><ul><li><p><code>Symbol()</code>函数<strong>不与<code>new</code>操作符搭配</strong>，即<code>new Symbol()</code>是不合法的。这是为了防止创建<code>Symbol</code>包装对象；</p></li><li><p><code>Symbol()</code>函数可以传入字符串作为键（也可以不传），此时<strong>传入的字符串键只起到描述的作用，并不影响<code>symbol</code>实例的值</strong>。因此，传入相同的字符串键的<code>symbol</code>实例，其值也不相等而且相互之间也没啥关联。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> symbol1 = <span class="title class_">Symbol</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> symbol2 = <span class="title class_">Symbol</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line">symbol1 === symbol2;</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-全局符号注册表"><a href="#2-全局符号注册表" class="headerlink" title="2. 全局符号注册表"></a>2. 全局符号注册表</h2><p>如果运行时不同部分的代码需要共享和重用符号实例，则可以用一个字符串作为键，使用 <strong><code>Symbol.for()</code></strong> 方法在全局符号注册表中创建并注册符号。与<code>Symbol()</code>函数不同，此时，<strong>传入的字符串键会影响符号实例的值</strong>，一个字符串对应一个独一无二的符号实例。在全局符号注册表中使用同一个字符串键来注册的符号实例之间完全等价，即是同一个符号实例，从而实现共享和重用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> symbol3 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> symbol4 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">symbol3 === symbol4;</span><br></pre></td></tr></table></figure><p>如果全局符号表中定义的符号没有传入字符串键，则相当于传入了<code>undefined</code>作为键。因此，所有没有传入字符串键的全局符号完全等价，是同一个符号实例。而由于全局注册表中的符号必须用字符串键来创建，因此传入的任何值都会被转换为字符串，<code>undefined</code>也会被转换为字符串<code>“undefined”</code>。如下栗子中的所有<code>symbol</code>实例的描述都是<code>Symbol(undefined)</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> symbol5 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>();</span><br><span class="line"><span class="keyword">const</span> symbol6 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>();</span><br><span class="line"><span class="keyword">const</span> symbol7 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="literal">undefined</span>);</span><br><span class="line"><span class="keyword">const</span> symbol8 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;undefined&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">symbol5 === symbol6;</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">symbol6 === symbol7;</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">symbol7 === symbol8;</span><br></pre></td></tr></table></figure><p>通过<strong>全局注册表来实现符号共享与重用的原理</strong>是，当第一次用某个字符串键在全局注册表中创建<code>symbol</code>实例时，见到到注册表中没有该字符串键对应的符号实例，则使用该字符串键创建一个符号实例，并在注册表中保存；当后续试图使用同样的字符串键来在注册表中创建符号实例时，检测到注册表中已经有了对应的符号实例，因此直接返回该符号实例，而不是重新创建，从而实现符号实例的共享与重用。这个过程完全可以用对象或者字典来模拟：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局作用域中创建一个空的注册表</span></span><br><span class="line"><span class="keyword">const</span> symbol_regedit = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用与注册符号实例的函数</span></span><br><span class="line"><span class="title class_">Symbol</span>.<span class="property">custom_for</span> = <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 如果接收的参数不是字符串，则转换为字符串</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> str !== <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">    str = <span class="title class_">String</span>(str);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 注册表中已经存在该键对应的符号实例，则直接返回该实例</span></span><br><span class="line">  <span class="keyword">if</span> (symbol_regedit.<span class="title function_">hasOwnProperty</span>(str)) &#123;</span><br><span class="line">    <span class="keyword">return</span> symbol_regedit[str];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 不存在则创建并注册</span></span><br><span class="line">  <span class="comment">// 创建symbol实例</span></span><br><span class="line">  <span class="keyword">const</span> symbol = <span class="title class_">Symbol</span>(str);</span><br><span class="line">  <span class="comment">// 添加到注册表中</span></span><br><span class="line">  symbol_regedit[str] = symbol;</span><br><span class="line">  <span class="comment">// 返回实例</span></span><br><span class="line">  <span class="keyword">return</span> symbol;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用<strong><code>Symbol.keyFor()</code></strong>我们也可以<strong>通过符号实例来查询注册表中对应的字符串键</strong>，该方法接收一个符号实例，返回其对应的字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> symbol9 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;symbol 9 号&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> key = <span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(symbol9); <span class="comment">// &#x27;symbol 9 号&#x27;</span></span><br></pre></td></tr></table></figure><p>同样的，在模拟了<code>Symbol.for()</code>的基础上，我们也可以模拟<code>Symbol.keyFor()</code>方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Symbol</span>.<span class="property">custom_keyFor</span> = <span class="function">(<span class="params">symbol</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 入参安全检测</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> symbol !== <span class="string">&quot;symbol&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> type = <span class="keyword">typeof</span> symbol;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;TypeError: Expect a symbol，but got a &quot;</span> + type);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 查找对应的字符串键并返回</span></span><br><span class="line">  <span class="keyword">const</span> strKey = <span class="title class_">Object</span>.<span class="title function_">keys</span>(symbol_regedit).<span class="title function_">find</span>(</span><br><span class="line">    <span class="function">(<span class="params">key</span>) =&gt;</span> symbol_regedit[key] === symbol</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> strKey;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可见，符号实例仍是唯一的，所谓全局注册表，不过是一个对象/字典实例而已。</p><h2 id="3-使用符号作为属性"><a href="#3-使用符号作为属性" class="headerlink" title="3. 使用符号作为属性"></a>3. 使用符号作为属性</h2><p>我们指知道，使用符号作为属性，能避免属性重名引起的冲突。凡是可以使用字符串或数值作为属性的地方，也都可以使用符号来作为属性，包括了 <strong>对象字面量属性</strong> ，<strong><code>Object.defineProperty()</code></strong> 以及 <strong><code>Object.defineProperties</code></strong> 定义的属性。</p><p>当符号用在对象字面量属性中时，只能使用计算属性语法，即中括号语法 <code>obj[symbol]</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="title class_">Symbol</span>(<span class="string">&quot;s&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="title class_">Symbol</span>(<span class="string">&quot;s&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">  [s1]: <span class="string">&quot;symbol property 1&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样也ok</span></span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;&#125;;</span><br><span class="line">obj2[s2] = <span class="string">&quot;symbol property 2&quot;</span>;</span><br></pre></td></tr></table></figure><p>而在<strong><code>Object.defineProperty()</code></strong> 以及 <strong><code>Object.defineProperties</code></strong> 中使用符号时， 不使用计算属性语法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// s1不使用计算属性语法</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj1, s1, &#123; <span class="attr">value</span>: <span class="string">&quot;symbol property 1 呀&quot;</span> &#125;);</span><br><span class="line"><span class="comment">// s2使用计算属性语法，因为出现在对象字面量属性中</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(obj2, &#123;</span><br><span class="line">  [s2]: <span class="string">&quot;symbol property 2 呀&quot;</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们通常用<code>Object.getOwnPropertyNames()</code>来获取对象的常规属性数组；类似的，使用<code>Object.getOwnPropertySymbols()</code>可以获取对象的符号属性数组；使用<code>Reflect.ownKeys()</code>可以得到两种类型的属性数组；此外，<code>Object.getOwnPropertyDescriptors()</code>可以得到包含常规和符号属性描述符的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s1 = <span class="title class_">Symbol</span>(<span class="string">&quot;s1&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> s2 = <span class="title class_">Symbol</span>(<span class="string">&quot;s2&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  [s1]: <span class="string">&quot;symbol 1&quot;</span>,</span><br><span class="line">  [s2]: <span class="string">&quot;symbol 2&quot;</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. Object.getOwnPropertyNames()</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(obj); <span class="comment">// [&#x27;name&#x27;, &#x27;age&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Object.getOwnPropertySymbols()</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>(obj); <span class="comment">// [ Symbol(s1), Symbol(s2) ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. Reflect.ownKeys()，常规属性始终先出现</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(obj); <span class="comment">// [ &#x27;name&#x27;, &#x27;age&#x27;, Symbol(s1), Symbol(s2) ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. Object.getOwnPropertyDescriptors()</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(obj);</span><br><span class="line"><span class="comment">/*这里符号属性没有以计算属性语法出现，是因为这是控制台打印的值，而不是我们声明符号属性对象。</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">name: &#123;...&#125;,</span></span><br><span class="line"><span class="comment">age: &#123;...&#125;,</span></span><br><span class="line"><span class="comment">Symbol(s1): &#123;...&#125;,</span></span><br><span class="line"><span class="comment">Symbol(s2): &#123;...&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="4-常用内置符号"><a href="#4-常用内置符号" class="headerlink" title="4. 常用内置符号"></a>4. 常用内置符号</h2><p><code>ES6</code>引入了一批常用的内置符号，供开发者访问、重写等。通过重新定义内置符号，可以改变原生结构的行为。例如，<code>for-of</code>循环会在相关对象上使用<code>Symbol.iterator</code>属性，如果我们在自定义对象上重新定义<code>Symbol.iterator</code>属性，就可以改变<code>for-of</code>在遍历该对象时的行为。<strong>内置符号只是全局函数<code>Symbol</code>的字符串属性而已，各自指向一个符号实例。所有的内置符号属性都是不可改写、不可枚举、不可配置的。</strong>符号在<code>ES</code>规范中的名称，一般是由前缀<code>@@</code>加上字符串属性，如<code>@@iterator</code>指<code>Symbol.iterator</code>。</p><h3 id="（1）Symbol-asyncIterator"><a href="#（1）Symbol-asyncIterator" class="headerlink" title="（1）Symbol.asyncIterator"></a>（1）<code>Symbol.asyncIterator</code></h3><p>这个符号表示实现异步迭代器<code>for-await-of</code>的函数。异步循环时，会调用以<code>Symbol.asyncIterator</code>为键的函数，并期望这个函数返回一个实现迭代器<code>API</code>的对象。很多时候，返回的对象是实现该<code>API</code>的异步生成器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">length, initIndex</span>) &#123;</span><br><span class="line">    <span class="comment">// 初始化长度和初始索引</span></span><br><span class="line">    <span class="variable language_">this</span>[length] = length;</span><br><span class="line">    <span class="variable language_">this</span>[index] = initIndex;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 声明一个以[Symbol.iterator]为键的实例方法，这里是一个异步生成器</span></span><br><span class="line">  <span class="comment">// 当对类的实例使用 for await of 循环时，会调用这个方法得到返回的对象</span></span><br><span class="line">  <span class="comment">// 从技术上讲，此函数返回的对象应该通过next()方法陆续返回Promise实例。可以使用next()隐式返回</span></span><br><span class="line">  <span class="comment">// 也可以通过异步生成器函数返回</span></span><br><span class="line">  <span class="keyword">async</span> *[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="variable language_">this</span>[index] &lt; <span class="variable language_">this</span>[length]) &#123;</span><br><span class="line">      <span class="keyword">yield</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 将当前索引作为值传递出去，也可以写复杂点，此处不作例举</span></span><br><span class="line">        <span class="title function_">resolve</span>(<span class="variable language_">this</span>[index]++);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在异步函数中对 MyClass 实例使用 for await of 循环，则会依次得到以上的index</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getIndex</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="title class_">MyClass</span>(<span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> index <span class="keyword">of</span> instance) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(index);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用函数</span></span><br><span class="line"><span class="title function_">getIndex</span>();</span><br><span class="line"><span class="comment">// 依次打印: 0 1 2 3 4</span></span><br></pre></td></tr></table></figure><h3 id="（2）Symbol-hasInstance"><a href="#（2）Symbol-hasInstance" class="headerlink" title="（2）Symbol.hasInstance"></a>（2）<code>Symbol.hasInstance</code></h3><p>该符号属性表示一个方法，用以判断 构造函数/类 是否认可一个对象是其实例，这个方法定义在<code>Function</code>的原型即<code>Function.prototype</code>上。在使用 <code>instanceof</code>操作符时，会调用该函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr <span class="keyword">instanceof</span> <span class="title class_">Array</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改Array的[Symbol.hasInstance]方法，则再次使用instanceof会优先调用Array本身的方法，</span></span><br><span class="line"><span class="comment">// 而不是Function的原型上的方法</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Array</span>, <span class="title class_">Symbol</span>.<span class="property">hasInstance</span>, &#123;</span><br><span class="line">  <span class="comment">// 例如，将其值改为返回false的函数，则Array不再认可任何值为其实例</span></span><br><span class="line">  <span class="attr">value</span>: <span class="function">() =&gt;</span> <span class="literal">false</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr <span class="keyword">instanceof</span> <span class="title class_">Array</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="（3）Symbol-isConcatSpreadable"><a href="#（3）Symbol-isConcatSpreadable" class="headerlink" title="（3）Symbol.isConcatSpreadable"></a>（3）<code>Symbol.isConcatSpreadable</code></h3><p>根据<code>ES</code>规范，这个符号作为一个属性，表示一个布尔值，定义在具体的对象上，用以根据<strong>对象的类型</strong>决定对象是否应该用<code>Array.prototype.concat</code>来打平其数组元素：若该值为<code>true</code>，则会将类数组对象的数组元素打平之后再进行数组拼接操作；否则将类数组对象作为一个整体与数组进行拼接。</p><p>数组对象默认会打平到已有的数组中；类数组对象由该值决定是否打平到已有数组中；其它不是类数组对象的对象，该值会被忽略。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类数组对象</span></span><br><span class="line"><span class="keyword">let</span> likeArr = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&quot;name&quot;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">&quot;age&quot;</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">&quot;gender&quot;</span>,</span><br><span class="line">  <span class="attr">length</span>: <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// 当类数组对象likeArr的[Symbol.isConcatSpreadable]属性不为true时：</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(likeArr[<span class="title class_">Symbol</span>.<span class="property">isConcatSpreadable</span>]); <span class="comment">// undefined</span></span><br><span class="line">arr1.<span class="title function_">concat</span>(likeArr); <span class="comment">// [1, 2, 3, &#123;0: &#x27;name&#x27;, ...&#125;]</span></span><br><span class="line"><span class="comment">// 定义该属性为true：</span></span><br><span class="line">likeArr[<span class="title class_">Symbol</span>.<span class="property">isConcatSpreadable</span>] = <span class="literal">true</span>;</span><br><span class="line">arr2.<span class="title function_">concat</span>(likeArr); <span class="comment">// [1, 2, 3, &#x27;name&#x27;, &#x27;age&#x27;, &#x27;gender&#x27;]</span></span><br></pre></td></tr></table></figure><h3 id="（4）Symbol-iterater"><a href="#（4）Symbol-iterater" class="headerlink" title="（4）Symbol.iterater"></a>（4）<code>Symbol.iterater</code></h3><p>该符号作为一个属性，表示一个方法，供<code>for-of</code>语句使用，返回对象默认的迭代器。简而言之，该符号属性表示实现迭代器<code>API</code>的函数。</p><p><code>for-of</code>语句循环时，会调用以<code>Symbol.iterater</code>为键的函数，并默认该函数会返回一个实现迭代器<code>API</code>的对象。很多时候，返回的对象是实现该<code>API</code>的<code>Generator</code>。技术上来说，返回的对象应该调用其<code>next()</code>方法陆续返回值。可以显示地调用<code>next()</code>方法返回，也可以通过生成器函数返回。</p><p>在执行<code>for-of</code>循环时，会沿着原型链查找以<code>Symbol.iterator</code>为键的方法。下面的示例改写了<code>Array</code>的原型上的<code>Symbol.iterator</code>方法，仅供理解与娱乐。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认情况下的for-of循环</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="string">&quot;猜&quot;</span>, <span class="string">&quot;猜&quot;</span>, <span class="string">&quot;我&quot;</span>, <span class="string">&quot;是&quot;</span>, <span class="string">&quot;谁&quot;</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 依次打印： 猜 猜 我 是 谁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法改写</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="title class_">Symbol</span>.<span class="property">iterator</span>, &#123;</span><br><span class="line">  <span class="comment">// 改写生成器函数</span></span><br><span class="line">  <span class="attr">value</span>: <span class="keyword">function</span>* () &#123;</span><br><span class="line">    <span class="keyword">const</span> container = [<span class="string">&quot;你&quot;</span>, <span class="string">&quot;是&quot;</span>, <span class="string">&quot;大&quot;</span>, <span class="string">&quot;帅&quot;</span>, <span class="string">&quot;比&quot;</span>];</span><br><span class="line">    <span class="keyword">while</span> (container.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="keyword">yield</span> container.<span class="title function_">shift</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// for-of循环行为被改写</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 依次打印：你 是 大 帅 比</span></span><br></pre></td></tr></table></figure><h3 id="（5）Symbol-match"><a href="#（5）Symbol-match" class="headerlink" title="（5）Symbol.match"></a>（5）<code>Symbol.match</code></h3><p>表示一个方法，用正则表达式去匹配字符串，由<code>String.prototype.match()</code>方法使用。正则表达式的原型上默认有这个方法的定义。可以改写该方法以改变默认对正则表达式求值的行为。</p><h3 id="（6）Symbol-replace"><a href="#（6）Symbol-replace" class="headerlink" title="（6）Symbol.replace"></a>（6）<code>Symbol.replace</code></h3><p>表示一个正则表达式方法，替换一个字符串中匹配的子串，由<code>String.prototype.replace()</code>使用。正则表达式的原型上默认有该方法的定义。默认情况下，传入一个非正则表达式的值，会将该值转化为正则表达式。可以通过改写以<code>Symbol.replace</code>为键的方法来改变默认行为，使该方法可以直接使用参数，而不必先将参数转化为正则表达式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FooReplacer</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> [<span class="title class_">Symbol</span>.<span class="property">replace</span>](target, replacement) &#123;</span><br><span class="line">    <span class="keyword">return</span> target.<span class="title function_">split</span>(<span class="string">&quot;foo&quot;</span>).<span class="title function_">join</span>(replacement);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;barfoobaz&quot;</span>.<span class="title function_">replace</span>(<span class="title class_">FooReplacer</span>, <span class="string">&quot;qux&quot;</span>));</span><br><span class="line"><span class="comment">// &quot;barquxbaz&quot;</span></span><br></pre></td></tr></table></figure><h3 id="（7）Symbol-search"><a href="#（7）Symbol-search" class="headerlink" title="（7）Symbol.search"></a>（7）<code>Symbol.search</code></h3><p>表示一个正则表达式方法，返回字符串中匹配正则表达式的索引。由<code>String.prototype.search()</code>方法使用。当然，也可以重写该方法，以改变默认行为。</p><h3 id="（8）Symbol-species"><a href="#（8）Symbol-species" class="headerlink" title="（8）Symbol.species"></a>（8）<code>Symbol.species</code></h3><p>表示 i 一个函数，作为创建派生对象构造函数。在<strong>内置类型中最为常用</strong>，用于对内置类型实例方法的返回值暴露实例化派生对象的方法。用<code>Symbol.species</code>定义静态的获取器方法(getter)，可覆盖创建实例的<strong>原型定义</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承Array</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NotArray</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Array</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> get [<span class="title class_">Symbol</span>.<span class="property">species</span>]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Array</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> notarr = <span class="keyword">new</span> <span class="title class_">NotArray</span>();</span><br><span class="line"><span class="comment">// 由于继承关系,notarr既属于NotArray又属于Array</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(notarr <span class="keyword">instanceof</span> <span class="title class_">NotArray</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(notarr <span class="keyword">instanceof</span> <span class="title class_">Array</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">notarr = notarr.<span class="title function_">concat</span>(<span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(notarr <span class="keyword">instanceof</span> <span class="title class_">NotArray</span>); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(notarr <span class="keyword">instanceof</span> <span class="title class_">Array</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="（9）Symbol-split"><a href="#（9）Symbol-split" class="headerlink" title="（9）Symbol.split"></a>（9）<code>Symbol.split</code></h3><p>表示一个正则表达式方法，该方法在匹配正则表达式的索引位置拆分字符串，由<code>String.prototype.split()</code>方法使用。正则表达式的原型上默认有这个方法的定义。给这个方法传入的非正则表达式的值，会先被转换为正则表达式。通过重新定义<code>Symbol.split()</code>方法，可以改变该行为。</p><h3 id="（10）Symbol-toPromitive"><a href="#（10）Symbol-toPromitive" class="headerlink" title="（10）Symbol.toPromitive"></a>（10）<code>Symbol.toPromitive</code></h3><p>该符号属性表示一个方法，将对象转换为对应的原始值，由<code>ToPrimitive</code>抽象操作使用。许多内置操作都会尝试将对象转换为原始值。可以通过提供给该函数的参数来控制返回的原始值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>[<span class="title class_">Symbol</span>.<span class="property">toPrimitive</span>] = <span class="keyword">function</span> (<span class="params">hint</span>) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (hint) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;number&quot;</span>:</span><br><span class="line">          <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;string&quot;</span>:</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&quot;string bar&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;default&quot;</span>:</span><br><span class="line">        <span class="attr">default</span>:</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&quot;default bar&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">new</span> <span class="title class_">Bar</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span> + bar); <span class="comment">// &quot;3default bar&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span> - bar); <span class="comment">// 0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>(bar)); <span class="comment">// &quot;string bar&quot;</span></span><br></pre></td></tr></table></figure><h3 id="（11）Symbol-toStringTag"><a href="#（11）Symbol-toStringTag" class="headerlink" title="（11）Symbol.toStringTag"></a>（11）<code>Symbol.toStringTag</code></h3><p>根据<code>ES</code>规范，该符号属性表示一个字符串，用于创建对象的默认字符串描述。由内置方法<code>Object.prototype.toString()</code>使用。</p><p>通过<code>toString()</code>方法获取对象标识时，会检索由<code>Symbol.toStringTag</code>指定的实例标识符，默认为<code>Object</code>，<code>JS</code>内置类型都已经指定了该值，但自定义类实例还需要明确定义，否则该属性为<code>undefined</code>，<code>toString()</code>方法得到默认的<code>Object</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内置类型已指定</span></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set.<span class="title function_">toString</span>()); <span class="comment">// [Oject Set]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set[<span class="title class_">Symbol</span>.<span class="property">toStringTag</span>]); <span class="comment">// Set</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义类实例，不指定该符号属性</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  num = <span class="number">18</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> myclass = <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myclass.<span class="title function_">toString</span>()); <span class="comment">// [Object Object]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myclass[<span class="title class_">Symbol</span>.<span class="property">toStringTag</span>]); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义实例，指定该符号属性</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UrClass</span> &#123;</span><br><span class="line">  num = ((<span class="number">16</span>)[<span class="title class_">Symbol</span>.<span class="property">toStringTag</span>] = <span class="string">&quot;UrClass&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> urclass = <span class="keyword">new</span> <span class="title class_">UrClass</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(urclass.<span class="title function_">toString</span>()); <span class="comment">// [Object UrClass]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(urclass[<span class="title class_">Symbol</span>.<span class="property">toStringTag</span>]); <span class="comment">// UrClass</span></span><br></pre></td></tr></table></figure><h3 id="（12）Symbol-unscopables"><a href="#（12）Symbol-unscopables" class="headerlink" title="（12）Symbol.unscopables"></a>（12）<code>Symbol.unscopables</code></h3><p>该符号作为一个属性，表示一个对象，对象所有的以及继承而来的属性，都会从关联对象的<code>with</code>环境中排除。给具体的对象设置该符号属性，并将对应的键映射为<code>true</code>，则会阻止对象的该属性出现在<code>with</code>环境绑定中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">name</span>: <span class="string">&quot;cc&quot;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;;</span><br><span class="line"><span class="keyword">with</span> (obj) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(name, age);</span><br><span class="line">  <span class="comment">// &#x27;cc&#x27; 18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置该符号属性并将&#x27;name&#x27;映射为true，则对象obj的name属性不会在with环境绑定中出现</span></span><br><span class="line">obj[<span class="title class_">Symbol</span>.<span class="property">unscopables</span>] = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> (obj) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(age);</span><br><span class="line">  <span class="comment">// 18</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(name);</span><br><span class="line">  <span class="comment">// 报错：ReferenceError</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上我们并不推荐使用<code>with</code>，因此，该符号属性<code>Symbol.unScopables</code>也不推荐使用。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前 端 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 温故(一)：script 标签</title>
      <link href="/articals/7a292634/"/>
      <url>/articals/7a292634/</url>
      
        <content type="html"><![CDATA[<p>一个月前，更新了<code>TS</code>系列。本来要继续其它内容，奈何公司项目开始了，忙到现在，总算能缓一缓。也准备趁机开始源码系列。但是在此之前，我想先温习一下<code>JS</code>系列，查漏补缺，内容主要基于<code>《JS高级程序设计》</code></p><h3 id="1-script标签的-8-个属性"><a href="#1-script标签的-8-个属性" class="headerlink" title="1. script标签的 8 个属性"></a>1. <code>script</code>标签的 8 个属性</h3><ul><li><strong><code>async</code>:</strong> 立即下载，但不阻止其它页面动作，如下载资源或等待其它脚本加载；仅对外部脚本文件有效（即<code>src</code>指定路径的文件），保证脚本在页面的<code>load</code>事件之前执行，但<strong>不保证脚本执行的顺序</strong>。</li><li><strong><code>charset</code>：</strong> 使用<code>src</code>属性指定的字符集，这个属性基本不会用到。</li><li><strong><code>crossorigin</code>：</strong> 配置相关请求的<code>CORS</code>设置。默认不使用<code>CORS</code>。</li><li><strong><code>defer</code>：</strong> 使脚本延迟到页面内容解析之后再执行，<strong><code>html5</code>规范要求脚本按照出现的顺序依次执行</strong>，只对外部文件有效，但<code>IE7</code>及更早版本对行内脚本也有效。</li><li><strong><code>intergrity</code>：</strong> 允许验证子资源的完整性，一般情况下不会用到。</li><li><strong><code>language</code>：</strong> 已废弃。</li><li><strong><code>type</code>：</strong> 设置为<code>type=&quot;module&quot;</code>才能允许其中的代码被当成<code>ES6</code>模块，从而允许使用<code>import</code>，<code>export</code>等关键字。</li><li><strong><code>src</code>：</strong> 表示包含指定的要执行的外部文件，此时该<code>script</code>标签内不应该再有行内代码，即使有也不会被浏览器执行。</li></ul><h3 id="2-script标签的位置"><a href="#2-script标签的位置" class="headerlink" title="2. script标签的位置"></a>2. <code>script</code>标签的位置</h3><p>以往，所有的<code>script</code>标签都放在<code>&lt;head&gt;</code>里，这意味着要等所有的<code>js</code>代码都下载、解析、解释完成后，才会开始页面渲染，因此尽可能把脚本放在<code>&lt;body&gt;</code>元素的页面内容之后，可在视觉上加快页面渲染。如果不考虑某些浏览器的古董版本，则添加<code>defer</code>属性也会有同样的效果。</p><h3 id="3-动态加载脚本"><a href="#3-动态加载脚本" class="headerlink" title="3. 动态加载脚本"></a>3. 动态加载脚本</h3><p>通过手动创建<code>&lt;script&gt;</code>标签并指定<code>src</code>属性来动态加载脚本，此时创建的<code>&lt;script&gt;</code>标签默认开启了<code>async</code>属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">script.<span class="property">src</span> = <span class="string">&quot;gibberish.js&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">appendChild</span>(script);</span><br></pre></td></tr></table></figure><p>某些旧版本浏览器不支持<code>async</code>属性，因此如果要统一脚本行为，可将<code>async</code>属性指定为<code>false</code>，使其具有同步加载行为。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">script.<span class="property">async</span> = <span class="literal">false</span>;</span><br><span class="line">script.<span class="property">src</span> = <span class="string">&quot;gibberish.js&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">appendChild</span>(script);</span><br></pre></td></tr></table></figure><h3 id="4-lt-noscript-gt-标签"><a href="#4-lt-noscript-gt-标签" class="headerlink" title="4.&lt;noscript&gt;标签"></a>4.<code>&lt;noscript&gt;</code>标签</h3><p>当 <strong>浏览器不支持<code>js</code>脚本</strong> 或 <strong>浏览器对脚本的支持被关闭</strong>，则包含在<code>noscript</code>标签中的内容才会被渲染出来。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前 端 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS笔记：函数式编程</title>
      <link href="/articals/7fdf3fd8/"/>
      <url>/articals/7fdf3fd8/</url>
      
        <content type="html"><![CDATA[<h2 id="一、函数式编程的出现"><a href="#一、函数式编程的出现" class="headerlink" title="一、函数式编程的出现"></a>一、函数式编程的出现</h2><ul><li>发展史：命令（脚本）式 -&gt; 面向对象 -&gt; 函数式编程</li></ul><h3 id="1-从实际问题开始"><a href="#1-从实际问题开始" class="headerlink" title="1. 从实际问题开始"></a>1. 从实际问题开始</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.数组在 `url` 中展示形式</span></span><br><span class="line">location.<span class="property">search</span> =&gt; <span class="string">&#x27;?name[]=progressive$%coding&amp;name[]=objective$%coding&amp;name[]=functional$%coding&#x27;</span></span><br><span class="line"><span class="comment">// 2.参数提取拼接成数组</span></span><br><span class="line">[<span class="string">&#x27;progressive$%coding&#x27;</span>, <span class="string">&#x27;objective$%coding&#x27;</span>, <span class="string">&#x27;functional$%coding&#x27;</span>]</span><br><span class="line"><span class="comment">// 3. 手写方法，转换成数组对象</span></span><br><span class="line"><span class="comment">// [&#123;name: &#x27;Progressive Coding&#x27;&#125;, &#123;name: &#x27;Objective Coding&#x27;&#125;, &#123;name: &#x27;Functional Coding&#x27;&#125;]</span></span><br><span class="line"><span class="keyword">const</span> _array = [<span class="string">&#x27;progressive$%coding&#x27;</span>, <span class="string">&#x27;objective$%coding&#x27;</span>, <span class="string">&#x27;functional$%coding&#x27;</span>]</span><br><span class="line"><span class="keyword">const</span> _objArr = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">nameParser</span>(<span class="params">array, objArr</span>)&#123;</span><br><span class="line">  array.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> names = item.<span class="title function_">split</span>(<span class="string">&#x27;$%&#x27;</span>)</span><br><span class="line">    <span class="keyword">let</span> newName = []</span><br><span class="line"></span><br><span class="line">    names.<span class="title function_">forEach</span>(<span class="function"><span class="params">name</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">let</span> nameItem = name[<span class="number">0</span>].<span class="title function_">toUpperCase</span>() + name.<span class="title function_">slice</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">      newName.<span class="title function_">push</span>(nameItem)</span><br><span class="line">    &#125;)</span><br><span class="line">    objArr.<span class="title function_">push</span>(&#123;</span><br><span class="line">      <span class="attr">name</span>: newName.<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> objArr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">nameParser</span>(_array, _objArr))</span><br></pre></td></tr></table></figure><h3 id="2-存在的问题："><a href="#2-存在的问题：" class="headerlink" title="2. 存在的问题："></a>2. 存在的问题：</h3><ul><li>过程中存在逻辑包裹 -&gt; 看完整段代码，才能明白逻辑</li></ul><!----><ul><li>存在临时变量，且首尾封闭 -&gt; 迭代难度高</li></ul><h3 id="3-解决方案：函数式编程"><a href="#3-解决方案：函数式编程" class="headerlink" title="3. 解决方案：函数式编程"></a>3. 解决方案：函数式编程</h3><ul><li>需求分析：数组 =&gt; 数组对象 =&gt; [ 字符串 =&gt; 对象 ]，即 <code>nameParser =&gt; [objHelper : string =&gt; object]</code></li><li>模块功能明确：<code>objHelper</code> =&gt; <code>formatName</code> + <code>assembleObj</code></li><li>功能拆分： <code>objHelper</code> = <code>[(split + captialize + join) + assembleObj]</code></li><li>代码实现：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _array = [</span><br><span class="line">  <span class="string">&quot;progressive$%coding&quot;</span>,</span><br><span class="line">  <span class="string">&quot;objective$%coding&quot;</span>,</span><br><span class="line">  <span class="string">&quot;functional$%coding&quot;</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原子操作</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">assembleObj</span> = (<span class="params">key, x</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">  obj[key] = x;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">capitalize</span> = (<span class="params">name</span>) =&gt; name[<span class="number">0</span>].<span class="title function_">toUpperCase</span>() + name.<span class="title function_">slice</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组装描述，组装合并函数为compose，下文中提到</span></span><br><span class="line"><span class="keyword">const</span> formatName = 组装合并(<span class="title function_">join</span>(<span class="string">&quot; &quot;</span>), <span class="title function_">map</span>(capitalize), <span class="title function_">split</span>(<span class="string">&quot;$%&quot;</span>));</span><br><span class="line"><span class="keyword">const</span> objHelper = 组装合并(<span class="title function_">assembleObj</span>(<span class="string">&quot;name&quot;</span>), formatName);</span><br><span class="line"><span class="keyword">const</span> nameParser = <span class="title function_">map</span>(objHelper);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="title function_">nameParser</span>(_array);</span><br></pre></td></tr></table></figure><h3 id="4-拓展：数组的遍历方法的比较"><a href="#4-拓展：数组的遍历方法的比较" class="headerlink" title="4. 拓展：数组的遍历方法的比较"></a>4. 拓展：数组的遍历方法的比较</h3><p><strong>本质作用：</strong></p><ul><li><code>forEach</code>注重逻辑处理；</li><li><code>map</code>用于生成处理后的数组；</li><li><code>filter</code>用于生成过滤后的数组；</li><li><code>sort</code>用于生成排序后的数组；</li></ul><h2 id="二、函数式编程的原理与特点"><a href="#二、函数式编程的原理与特点" class="headerlink" title="二、函数式编程的原理与特点"></a>二、函数式编程的原理与特点</h2><h3 id="1-函数式编程的原理"><a href="#1-函数式编程的原理" class="headerlink" title="1. 函数式编程的原理"></a>1. 函数式编程的原理</h3><ul><li>加法结合律 | 因式分解 | 完全平方公式</li></ul><h3 id="2-理论思想"><a href="#2-理论思想" class="headerlink" title="2. 理论思想"></a>2. 理论思想</h3><h4 id="a-函数是一等公民"><a href="#a-函数是一等公民" class="headerlink" title="a. 函数是一等公民"></a>a. 函数是一等公民</h4><ul><li>函数是逻辑功能的落脚点</li></ul><!----><ul><li>(实现 + 拼接) 函数</li></ul><h4 id="b-声明式编程"><a href="#b-声明式编程" class="headerlink" title="b. 声明式编程"></a>b. 声明式编程</h4><p>函数式编程通过声明式编程来实现。声明需求 =&gt; 语义化。</p><h4 id="c-惰性执行-无缝连接、性能节约"><a href="#c-惰性执行-无缝连接、性能节约" class="headerlink" title="c. 惰性执行 - 无缝连接、性能节约"></a>c. 惰性执行 - 无缝连接、性能节约</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 惰性函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">program</span> = (<span class="params">name</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> nameList = [<span class="string">&quot;progressive&quot;</span>, <span class="string">&quot;objective&quot;</span>, <span class="string">&quot;functional&quot;</span>];</span><br><span class="line">  <span class="keyword">if</span> (nameList.<span class="title function_">indexOf</span>(name) !== -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (program = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(name);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">program</span>(<span class="string">&quot;progressive&quot;</span>)();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;lazy&quot;</span>);</span><br><span class="line"><span class="title function_">program</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依次打印 &#x27;progressive&#x27; &#x27;lazy&#x27; &#x27;progressive&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="3-无状态与无副作用"><a href="#3-无状态与无副作用" class="headerlink" title="3. 无状态与无副作用"></a>3. 无状态与无副作用</h4><ul><li>无状态 - 幂等</li><li>无副作用 - 不对外部数据做操作，只对传入的参数做处理，必要时需要深拷贝</li></ul><h2 id="三、实际开发"><a href="#三、实际开发" class="headerlink" title="三、实际开发"></a>三、实际开发</h2><h3 id="1-纯函数的改造"><a href="#1-纯函数的改造" class="headerlink" title="1. 纯函数的改造"></a>1. 纯函数的改造</h3><p>纯函数：无状态、无副作用的函数。</p><h3 id="2-流水线组装-—-加工-amp-组装"><a href="#2-流水线组装-—-加工-amp-组装" class="headerlink" title="2. 流水线组装 — 加工 &amp; 组装"></a>2. 流水线组装 — 加工 &amp; 组装</h3><ul><li><strong>加工 - 柯里化</strong>：传入一 个参数，返回一个函数接收剩下的参数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">sum</span> = (<span class="params">x, y</span>) =&gt; x + y;</span><br><span class="line"><span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 函数柯里化</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params">x</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">y</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">add</span>(<span class="number">1</span>)(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 体系 = 加工 + 组装， 单个加工输入输出应单值化 -&gt; 需求</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>函数组装</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">compose</span> = (<span class="params">f, g</span>) =&gt; <span class="title function_">f</span>(<span class="title function_">g</span>(x));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">sum1</span> = (<span class="params">x</span>) =&gt; x + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">sum2</span> = (<span class="params">x</span>) =&gt; x + <span class="number">2</span>;</span><br><span class="line"><span class="title function_">compose</span>(sum1, sum2);</span><br></pre></td></tr></table></figure></li></ul><!----><ul><li><strong>编程思想比较</strong>：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 命令式</span></span><br><span class="line"><span class="title function_">trim</span>(<span class="title function_">reverse</span>(<span class="title function_">toUpperCase</span>(<span class="title function_">map</span>(arr))));</span><br><span class="line"><span class="comment">// 面向对象</span></span><br><span class="line">arr.<span class="title function_">map</span>().<span class="title function_">toUpperCase</span>().<span class="title function_">reverse</span>().<span class="title function_">trim</span>();</span><br><span class="line"><span class="comment">// 函数式: 从右往左执行</span></span><br><span class="line"><span class="keyword">const</span> result = <span class="title function_">compose</span>(trim, reverse, toUpperCase, map);</span><br></pre></td></tr></table></figure><h2 id="四、BOX-与-函子"><a href="#四、BOX-与-函子" class="headerlink" title="四、BOX 与 函子"></a>四、BOX 与 函子</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一封信</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mail</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">content</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">content</span> = content;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">map</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Mail</span>(<span class="title function_">fn</span>(<span class="variable language_">this</span>.<span class="property">content</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.拆开信</span></span><br><span class="line"><span class="keyword">let</span> mail1 = <span class="keyword">new</span> <span class="title class_">Mail</span>(<span class="string">&quot;love&quot;</span>);</span><br><span class="line"><span class="comment">// 2.阅读信</span></span><br><span class="line"><span class="keyword">let</span> mail2 = mail1.<span class="title function_">map</span>(<span class="function">(<span class="params">mail</span>) =&gt;</span> <span class="title function_">read</span>(mail));</span><br><span class="line"><span class="comment">// 3.烧掉信</span></span><br><span class="line"><span class="keyword">let</span> mail3 = mail1.<span class="title function_">map</span>(<span class="function">(<span class="params">mail</span>) =&gt;</span> <span class="title function_">burn</span>(mail));</span><br><span class="line"><span class="comment">// 4.老师检查，没有发现</span></span><br><span class="line">mail3.<span class="title function_">map</span>(<span class="function">(<span class="params">mail</span>) =&gt;</span> <span class="title function_">check</span>(mail));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Mail</span>(<span class="string">&quot;love&quot;</span>).<span class="title function_">read</span>().<span class="title function_">burn</span>().<span class="title function_">check</span>();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前 端 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript系列  进阶篇(八)  TS模块进阶</title>
      <link href="/articals/2ebbd151/"/>
      <url>/articals/2ebbd151/</url>
      
        <content type="html"><![CDATA[<p>模块有自己的作用域，除非进行某种形式的导出，否则，其中的变量，函数，类等都是对外不可见的。相应的，如果要在模块外使用其导出的成员，则需要进行相应的导入。模块的相互导入需要使用 <strong>模块加载器</strong> ，模块加载器在执行模块之前，会先定位并执行该模块的依赖项。<code>JS</code>中主要使用<code>Node.js</code>的<code>CommonJs</code>模块加载器和<code>Web</code>应用程序中的<code>AMD</code>模块的<code>RequireJs</code>加载器。TS 延用了<code>ES2015</code>模块化方案，任何包含了顶层的<code>import</code>或<code>export</code>语句的文件，便是一个模块；相反，没有在顶层包含这些语句的则是脚本，其内容在全局作用域中可见。</p><p>[toc]</p><h2 id="一、导出"><a href="#一、导出" class="headerlink" title="一、导出"></a>一、导出</h2><h3 id="1-导出一个声明"><a href="#1-导出一个声明" class="headerlink" title="1. 导出一个声明"></a>1. 导出一个声明</h3><p>任何声明 (变量、函数、类、类型等) 都可以使用<code>export</code>关键字来导出。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> b = &#123; <span class="attr">a</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">cc</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">CC</span> &#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> A = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> Z &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 导出命名空间</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">namespace</span> N &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">const</span> b = &#123; <span class="attr">a</span>: <span class="string">&quot;namespace&quot;</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 导出枚举</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">enum</span> E &#123;</span><br><span class="line">  a,</span><br><span class="line">  b,</span><br><span class="line">  c,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-导出语句"><a href="#2-导出语句" class="headerlink" title="2. 导出语句"></a>2. 导出语句</h3><p>注意导出语句和导出一个声明的区别。导出声明是某个值、类型或命名空间在声明的时候被导出，导出语句是在其声明之后才导出。导出语句中可以使用<code>as</code>进行重命名，以方便使用。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">cc</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;cc&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> &#123; cc &#125;;</span><br><span class="line"><span class="keyword">export</span> &#123; <span class="title class_">Person</span> <span class="keyword">as</span> P &#125;;</span><br></pre></td></tr></table></figure><h3 id="3-重导出"><a href="#3-重导出" class="headerlink" title="3. 重导出"></a>3. 重导出</h3><p>一个模块可以在其它的模块文件中进行重导出。模块常常会对其它的模块进行拓展，并暴露部分其它模块的特性。重导出并不用在本地导入其它模块，也不用引入局部变量。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// moduleA.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;cc&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> age = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以同目录下的moduleB.ts为例：</span></span><br><span class="line"><span class="keyword">export</span> &#123; A &#125; <span class="keyword">from</span> <span class="string">&quot;./moduleA&quot;</span>; <span class="comment">// 在moduleB中重导出moduleA中的A</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&quot;./moduleA&quot;</span>; <span class="comment">// 在moduleB中重导出moduleA中所有的成员</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">as</span> B <span class="keyword">from</span> <span class="string">&quot;./moduleA&quot;</span>; <span class="comment">// 在moduleB中重导出moduleA的所有成员，并重命名为N</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 演示app.ts对应的导入方式</span></span><br><span class="line"><span class="comment">// 可以从moduleA中导入</span></span><br><span class="line"><span class="keyword">import</span> &#123; A &#125; <span class="keyword">from</span> <span class="string">&quot;./moduleA&quot;</span>;</span><br><span class="line"><span class="comment">// 可以从moduleB中导入，且分别对应以上重导出方式</span></span><br><span class="line"><span class="keyword">import</span> &#123; A &#125; <span class="keyword">from</span> <span class="string">&quot;./moduleB&quot;</span>; <span class="comment">// 只能导入A，因为只重导出了A</span></span><br><span class="line"><span class="keyword">import</span> &#123; A, age &#125; <span class="keyword">from</span> <span class="string">&quot;./moduleB&quot;</span>; <span class="comment">// 可以从moduleB中导入moduleA的所有成员，因为导出了*</span></span><br><span class="line"><span class="keyword">import</span> &#123; N &#125; <span class="keyword">from</span> <span class="string">&quot;./moduleB&quot;</span>; <span class="comment">// 重导出时，重命名为N，因此只能导入N，通过N.A和N.age来访问</span></span><br></pre></td></tr></table></figure><p>也可以通过以上语法来在一个模块中重导出多个其它模块，从某种意义上来说，就是把多个模块的内容整合到这个模块中。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// moduleC.ts</span></span><br><span class="line"><span class="keyword">export</span> &#123; A &#125; <span class="keyword">from</span> <span class="string">&quot;./moduleA&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">as</span> B <span class="keyword">from</span> <span class="string">&quot;./moduleB&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&quot;./moduleD&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; D <span class="keyword">as</span> C &#125; <span class="keyword">from</span> <span class="string">&quot;./moduleD&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="4-默认导出"><a href="#4-默认导出" class="headerlink" title="4. 默认导出"></a>4. 默认导出</h3><p>每个模块都可以选择性地导出一个默认项，可以是值、类型或者命名空间，当然，每个模块也只能有一个默认导出项。默认导出项会被<code>default</code>关键字标记，相应的，使用一种不同的导入形式。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Module.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// app.ts</span></span><br><span class="line"><span class="keyword">import</span> <span class="built_in">number</span> <span class="keyword">from</span> <span class="string">&quot;Module&quot;</span>;</span><br><span class="line"><span class="built_in">number</span>; <span class="comment">// 123</span></span><br></pre></td></tr></table></figure><p><strong>函数和类可以在声明时直接导出为默认项</strong>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Func.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Class.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;cc&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相应地，在app.ts中导入</span></span><br><span class="line"><span class="comment">// 导入时名字可以随意取</span></span><br><span class="line"><span class="keyword">import</span> getName <span class="keyword">from</span> <span class="string">&quot;Func&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> P <span class="keyword">from</span> <span class="string">&quot;Class&quot;</span>;</span><br><span class="line"><span class="title function_">getName</span>();</span><br><span class="line"><span class="keyword">const</span> cc = <span class="keyword">new</span> <span class="title function_">P</span>();</span><br></pre></td></tr></table></figure><p>也可以不通过名字而直接导出值：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="string">&quot;cc&quot;</span>;</span><br></pre></td></tr></table></figure><h2 id="二、导入"><a href="#二、导入" class="headerlink" title="二、导入"></a>二、导入</h2><h3 id="1-导入单个-从模块导出的成员"><a href="#1-导入单个-从模块导出的成员" class="headerlink" title="1. 导入单个 从模块导出的成员"></a>1. 导入单个 从模块导出的成员</h3><p>十分简单：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; N &#125; <span class="keyword">from</span> <span class="string">&quot;./moduleB&quot;</span>;</span><br></pre></td></tr></table></figure><p>可以使用<code>as</code>来重命名：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; D <span class="keyword">as</span> C &#125; <span class="keyword">from</span> <span class="string">&quot;./moduleD&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="2-导入整个模块，并存储到一个变量中，并通过该变量来访问"><a href="#2-导入整个模块，并存储到一个变量中，并通过该变量来访问" class="headerlink" title="2. 导入整个模块，并存储到一个变量中，并通过该变量来访问"></a>2. 导入整个模块，并存储到一个变量中，并通过该变量来访问</h3><p>使用<code>import * as m from &quot;Module&quot;</code>语法，来导入整个<code>Module</code>，并存储到变量<code>m</code>中，之后可通过<code>m</code>来访问模块内容。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> m <span class="keyword">from</span> <span class="string">&quot;Module&quot;</span>;</span><br><span class="line"><span class="comment">// 访问Module中导出的setName函数</span></span><br><span class="line">m.<span class="title function_">setName</span>(<span class="string">&quot;cc&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="3-导入副作用模块"><a href="#3-导入副作用模块" class="headerlink" title="3. 导入副作用模块"></a>3. 导入副作用模块</h3><p>副作用模块，往往会设置一些全局变量，无需导出，即可供其它模块使用。一般不会用到其导出成员，因此导出空对象<code>export &#123; &#125;</code>即可。副作用模块中的代码，在导入的地方执行。一般来说，<strong>不推荐使用副作用模块</strong>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;side-effect-module&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="4-导入类型"><a href="#4-导入类型" class="headerlink" title="4. 导入类型"></a>4. 导入类型</h3><p>在 TS 3.8 版本以前，只能通过<code>import</code>来导入类型。但是在此之后，可以通过<code>import type</code>来明确导入类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">PropType</span> &#125; <span class="keyword">from</span> <span class="string">&quot;Types&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; <span class="title class_">PersonType</span>, <span class="title class_">FoodType</span> &#125; <span class="keyword">from</span> <span class="string">&quot;Interfaces&quot;</span>;</span><br></pre></td></tr></table></figure><p>也可以和值或者命名空间混合导入。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; names, <span class="keyword">type</span> <span class="title class_">Names</span> &#125; <span class="keyword">from</span> <span class="string">&quot;moduleName&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="5-export-xxx和import-xx-require"><a href="#5-export-xxx和import-xx-require" class="headerlink" title="5. export = xxx和import xx = require()"></a>5. <code>export = xxx</code>和<code>import xx = require()</code></h3><p><code>CommonJs</code>和<code>AMD</code>都有一个<code>exports</code>对象，其包含了一个模块的所有导出项，也支持使用一个自定义的单个对象来替换导出对象。默认导出旨在替代此行为。然而不幸的是，<code>CommonJs</code>和<code>AMD</code>两者在这方面不兼容。TS 支持<strong>使用<code>export =</code></strong>来兼容二者，该语法从模块中导出一个单个对象，可以是类，函数，命名空间，枚举，接口等。相应地，<strong>需要使用<code>import xx = require()</code>来导入</strong>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Person.ts</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;cc&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> = <span class="title class_">Person</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// app.ts</span></span><br><span class="line"><span class="keyword">const</span> cc = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">cc.<span class="property">name</span>; <span class="comment">// &quot;cc&quot;</span></span><br></pre></td></tr></table></figure><h2 id="三、模块代码生成"><a href="#三、模块代码生成" class="headerlink" title="三、模块代码生成"></a>三、模块代码生成</h2><p>在编译时，TS 编译器会根据确定的模块的种类来生成<code>ES6</code>，<code>CommonJs</code>，<code>SystemJs</code>，<code>AMD</code>，<code>UMD</code>等对应的模块代码。如下通过官方的示例，演示 TS 模块中导入和导出被编译成各种模块化方案时对应的代码。如果想进一步了解 <code>define</code>, <code>require</code> 和 <code>register</code>等函数，可以去查阅各个模块化方案的文档。</p><p><strong><code>simpleModule.ts</code></strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> m = <span class="built_in">require</span>(<span class="string">&quot;mod&quot;</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> t = m.<span class="property">something</span> + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><strong><code>AMD / RequireJS SimpleModule.js</code></strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">define</span>([<span class="string">&quot;require&quot;</span>, <span class="string">&quot;exports&quot;</span>, <span class="string">&quot;./mod&quot;</span>], <span class="keyword">function</span> (<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, mod_1</span>) &#123;</span><br><span class="line">  <span class="built_in">exports</span>.<span class="property">t</span> = mod_1.<span class="property">something</span> + <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong><code>CommonJS / Node SimpleModule.js</code></strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mod_1 = <span class="built_in">require</span>(<span class="string">&quot;./mod&quot;</span>);</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">t</span> = mod_1.<span class="property">something</span> + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><strong><code>UMD SimpleModule.js</code></strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params">factory</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">module</span> === <span class="string">&quot;object&quot;</span> &amp;&amp; <span class="keyword">typeof</span> <span class="variable language_">module</span>.<span class="property">exports</span> === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> v = <span class="title function_">factory</span>(<span class="built_in">require</span>, <span class="built_in">exports</span>);</span><br><span class="line">    <span class="keyword">if</span> (v !== <span class="literal">undefined</span>) <span class="variable language_">module</span>.<span class="property">exports</span> = v;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">&quot;function&quot;</span> &amp;&amp; define.<span class="property">amd</span>) &#123;</span><br><span class="line">    <span class="title function_">define</span>([<span class="string">&quot;require&quot;</span>, <span class="string">&quot;exports&quot;</span>, <span class="string">&quot;./mod&quot;</span>], factory);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(<span class="keyword">function</span> (<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> mod_1 = <span class="built_in">require</span>(<span class="string">&quot;./mod&quot;</span>);</span><br><span class="line">  <span class="built_in">exports</span>.<span class="property">t</span> = mod_1.<span class="property">something</span> + <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong><code>System SimpleModule.js</code></strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">System</span>.<span class="title function_">register</span>([<span class="string">&quot;./mod&quot;</span>], <span class="keyword">function</span> (<span class="params">exports_1</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> mod_1;</span><br><span class="line">  <span class="keyword">var</span> t;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">setters</span>: [</span><br><span class="line">      <span class="keyword">function</span> (<span class="params">mod_1_1</span>) &#123;</span><br><span class="line">        mod_1 = mod_1_1;</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">execute</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      exports_1(<span class="string">&quot;t&quot;</span>, (t = mod_1.<span class="property">something</span> + <span class="number">1</span>));</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong><code>Native ECMAScript 2015 modules SimpleModule.js</code></strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; something &#125; <span class="keyword">from</span> <span class="string">&quot;./mod&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> t = something + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h2 id="四、可选的模块加载-与-高级模块加载场景"><a href="#四、可选的模块加载-与-高级模块加载场景" class="headerlink" title="四、可选的模块加载 与 高级模块加载场景"></a>四、可选的模块加载 与 高级模块加载场景</h2><p>有的情况下，我们只想在特定条件下加载某些模块，即 <strong>动态模块加载</strong> ，这也是一个不错的性能优化。我们可以使用<code>typeof</code>操作符来维护类型安全，在类型上下文中，<code>typeof</code>会得到一个值的类型，在这种情况下，得到的便是模块的类型。</p><p><strong><code>CommonJs</code>的动态模块加载</strong>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">require</span>(<span class="params">moduleName: <span class="built_in">string</span></span>): <span class="built_in">any</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ZipCodeValidator</span> <span class="keyword">as</span> <span class="title class_">Zip</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./ZipCodeValidator&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (needZipValidation) &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="title class_">ZipCodeValidator</span>: <span class="keyword">typeof</span> <span class="title class_">Zip</span> = <span class="built_in">require</span>(<span class="string">&quot;./ZipCodeValidator&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> validator = <span class="keyword">new</span> <span class="title class_">ZipCodeValidator</span>();</span><br><span class="line">  <span class="keyword">if</span> (validator.<span class="title function_">isAcceptable</span>(<span class="string">&quot;...&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>AMD</code>动态模块加载</strong>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">require</span>(<span class="params"></span></span><br><span class="line"><span class="params">  moduleNames: <span class="built_in">string</span>[],</span></span><br><span class="line"><span class="params">  onLoad: (...args: <span class="built_in">any</span>[]) =&gt; <span class="built_in">void</span></span></span><br><span class="line"><span class="params"></span>): <span class="built_in">void</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="title class_">Zip</span> <span class="keyword">from</span> <span class="string">&quot;./ZipCodeValidator&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (needZipValidation) &#123;</span><br><span class="line">  <span class="built_in">require</span>([<span class="string">&quot;./ZipCodeValidator&quot;</span>], <span class="function">(<span class="params">ZipCodeValidator: <span class="keyword">typeof</span> Zip</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> validator = <span class="keyword">new</span> <span class="title class_">ZipCodeValidator</span>.<span class="title class_">ZipCodeValidator</span>();</span><br><span class="line">    <span class="keyword">if</span> (validator.<span class="title function_">isAcceptable</span>(<span class="string">&quot;...&quot;</span>)) &#123;</span><br><span class="line">      <span class="comment">/* ... */</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>SystemJs</code>动态模块加载</strong>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> <span class="title class_">System</span>: <span class="built_in">any</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ZipCodeValidator</span> <span class="keyword">as</span> <span class="title class_">Zip</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./ZipCodeValidator&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (needZipValidation) &#123;</span><br><span class="line">  <span class="title class_">System</span>.<span class="title function_">import</span>(<span class="string">&quot;./ZipCodeValidator&quot;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">ZipCodeValidator: <span class="keyword">typeof</span> Zip</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="keyword">new</span> <span class="title class_">ZipCodeValidator</span>();</span><br><span class="line">    <span class="keyword">if</span> (x.<span class="title function_">isAcceptable</span>(<span class="string">&quot;...&quot;</span>)) &#123;</span><br><span class="line">      <span class="comment">/* ... */</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、在其它JS库中使用模块"><a href="#五、在其它JS库中使用模块" class="headerlink" title="五、在其它JS库中使用模块"></a>五、在其它<code>JS</code>库中使用模块</h2><p>有些不是用 TS 来写的库，我们需要声明它们暴露出来的<code>API</code>来描述库的形状。未定义实现的声明称为环境<code>ambient</code>，通常写在<code>.d.ts</code>文件中。</p><h3 id="1-环境模块"><a href="#1-环境模块" class="headerlink" title="1. 环境模块"></a>1. 环境模块</h3><p>在<code>Node.js</code>中，许多任务都是通过各个模块来完成的，我们可以使用顶层的到处声明在各自的<code>.d.ts</code>文件中定义每个模块，不够，更方便的是将它们都写在一个更大的<code>.d.ts</code>文件里。因此，我们可以使用环境命名空间的构造，但是使用<code>module</code>关键字以及带引号的模块名，这些模块名用于后续的导入。</p><p><strong>简化的<code>node.d.ts</code></strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&quot;url&quot;</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">Url</span> &#123;</span><br><span class="line">    protocol?: <span class="built_in">string</span>;</span><br><span class="line">    hostname?: <span class="built_in">string</span>;</span><br><span class="line">    pathname?: <span class="built_in">string</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">parse</span>(<span class="params"></span></span><br><span class="line"><span class="params">    urlStr: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">    parseQueryString?,</span></span><br><span class="line"><span class="params">    slashesDenoteHost?</span></span><br><span class="line"><span class="params">  </span>): <span class="title class_">Url</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&quot;path&quot;</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">normalize</span>(<span class="params">p: <span class="built_in">string</span></span>): <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">join</span>(<span class="params">...paths: <span class="built_in">any</span>[]</span>): <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">var</span> <span class="attr">sep</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后便可以使用三斜杠指令<code>/// &lt;reference path=&quot;node.d.ts&quot;/&gt;</code>来引入，并使用<code>import url = require(&quot;url&quot;);</code>或<code>import * as URL from &quot;url&quot;</code>来加载相应模块。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path=&quot;node.d.ts&quot;/&gt;</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="variable constant_">URL</span> <span class="keyword">from</span> <span class="string">&quot;url&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> myUrl = <span class="variable constant_">URL</span>.<span class="title function_">parse</span>(<span class="string">&quot;https://www.typescriptlang.org&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="2-环境模块速记"><a href="#2-环境模块速记" class="headerlink" title="2. 环境模块速记"></a>2. 环境模块速记</h3><p>当我们不想在使用新的模块之前花时间去写模块声明时，可以使用速记声明（不推荐），此时，从该模块导入的成员的类型都是<code>any</code>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// decalarations.d.ts</span></span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&quot;hot-new-module&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// app.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; A &#125; <span class="keyword">from</span> <span class="string">&quot;hot-new-module&quot;</span>; <span class="comment">// A 的类型为 any</span></span><br></pre></td></tr></table></figure><h3 id="3-通配符-模块声明"><a href="#3-通配符-模块声明" class="headerlink" title="3. 通配符*模块声明"></a>3. 通配符<code>*</code>模块声明</h3><p><code>SystemJs</code>和<code>AMD</code>等，允许导入非<code>JavaScript</code>的内容。这些内容通常会使用前缀或后缀来表示相关的语义。因此，使用通配符模块声明救你很方便地涵盖这些情况。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&quot;*!text&quot;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">content</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> content;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Some do it the other way around.</span></span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&quot;json!*&quot;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">value</span>: <span class="built_in">any</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的栗子中使用了<code>*!</code>，其中<code>*</code>为通配符，表示任意字符内容，<code>!</code>在此处用来分隔语义。之后，我们可以导入任何匹配<code>*!text</code>或<code>json!*</code>的内容。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fileContent <span class="keyword">from</span> <span class="string">&quot;./xyz.txt!text&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> data <span class="keyword">from</span> <span class="string">&quot;json!http://example.com/data.json&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data, fileContent);</span><br></pre></td></tr></table></figure><h3 id="4-UMD模块"><a href="#4-UMD模块" class="headerlink" title="4. UMD模块"></a>4. <code>UMD</code>模块</h3><p>有些库在设计时兼顾了多种模块加载器，或作为全局变量以在没有模块加载器时使用。这些就是我们熟知的<code>UMD</code>模块。这些库既可以通过某种形式的导入来使用，也可以直接通过其暴露的全局变量来使用。</p><p>如下使用了<code>export as namespace mathLib</code>(该语法可参考 <a href="https://juejin.cn/post/7078219615033098271#heading-26">揭秘<code>.d.ts</code>与<code>declare</code></a>) 来暴露一个全局变量<code>mathLib</code>，<strong>在脚本中（注意，不是模块中）通过该变量可以访问模块成员</strong>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mathLib.d.ts</span></span><br><span class="line"><span class="comment">// 导出一个函数成员</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">isPrime</span>(<span class="params">x: <span class="built_in">number</span></span>): <span class="built_in">boolean</span>;</span><br><span class="line"><span class="comment">// 定义一个全局变量mathLib</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">as</span> <span class="keyword">namespace</span> mathLib;</span><br><span class="line"></span><br><span class="line">// app1.ts</span><br><span class="line">import &#123; isPrime &#125; <span class="keyword">from</span> <span class="string">&quot;math-lib&quot;</span>;</span><br><span class="line"><span class="title function_">isPrime</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// app2.ts</span></span><br><span class="line"><span class="comment">// 不导入，直接通过全局变量mathLib来使用</span></span><br><span class="line">mathLib.<span class="title function_">isPrime</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><h2 id="六、结构化模块指南"><a href="#六、结构化模块指南" class="headerlink" title="六、结构化模块指南"></a>六、结构化模块指南</h2><h3 id="1-导出的内容尽可能地靠近顶层"><a href="#1-导出的内容尽可能地靠近顶层" class="headerlink" title="1. 导出的内容尽可能地靠近顶层"></a>1. 导出的内容尽可能地靠近顶层</h3><p>在组织自己的模块的结构时，应考虑到用户体验。过多的嵌套会使得模块结构笨重。例如，导出命名空间就会使得模块有多层级的嵌套。导出一个含有静态方法的类也是如此，除非能明显地增强类的表现力，否则，我们应该考虑简单地导出一个辅助函数。</p><ul><li><p>如果仅仅导出单个的<code>class</code>或者<code>function</code>时，使用默认导出`export default</p></li><li><p>如果导出多个成员，应尽量将它们放在顶层来导出</p></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">SomeType</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">someFunc</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>导入少量成员时，应显示地列出导入的名称</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">SomeType</span>, someFunc &#125; <span class="keyword">from</span> <span class="string">&quot;./MyThings&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> x = <span class="keyword">new</span> <span class="title class_">SomeType</span>();</span><br><span class="line"><span class="keyword">let</span> y = <span class="title function_">someFunc</span>();</span><br></pre></td></tr></table></figure><ul><li>导入大量成员时，最好使用命名空间导入模式<code>import * as Name from &quot;Module&quot;</code></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// largeModule.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Cat</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Tree</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Flower</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// app.ts</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="variable constant_">LM</span> <span class="keyword">from</span> <span class="string">&quot;largeModule&quot;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Wangcai</span> = <span class="keyword">new</span> <span class="variable constant_">LM</span>.<span class="title class_">Dog</span>()</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Kitty</span> = <span class="keyword">new</span> <span class="variable constant_">LM</span>.<span class="title class_">Cat</span>()</span><br><span class="line"><span class="keyword">const</span> rose = <span class="keyword">new</span> <span class="title class_">Tree</span>()</span><br></pre></td></tr></table></figure><h3 id="2-使用-重导出-来进行模块拓展"><a href="#2-使用-重导出-来进行模块拓展" class="headerlink" title="2. 使用 重导出 来进行模块拓展"></a>2. 使用 重导出 来进行模块拓展</h3><p>有时候我们需要在模块上拓展功能。同名命名空间可以合并，但是模块不会。因此，通常的做法是，不修改模块原有的内容，而是重新导出一个具有新的功能的实体，可以使用<code>as</code>来重命名为原模块名。</p><p>那么，这里再次借用一下官网的栗子（原本是自己写了个示例的，结果看来官网的之后，感觉自己写的太烂了），一个<code>Caculator.ts</code>的计算器模块，导出一个<code>Caculator</code>类以及一个<code>test</code>辅助函数。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> current = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> memory = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">operator</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="comment">// 读取一个输入字符串中的数字</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">processDigit</span>(<span class="params">digit: <span class="built_in">string</span>, currentValue: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (digit &gt;= <span class="string">&quot;0&quot;</span> &amp;&amp; digit &lt;= <span class="string">&quot;9&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> currentValue * <span class="number">10</span> + (digit.<span class="title function_">charCodeAt</span>(<span class="number">0</span>) - <span class="string">&quot;0&quot;</span>.<span class="title function_">charCodeAt</span>(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 读取输入字符串中的一个操作符</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">processOperator</span>(<span class="params">operator: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="string">&quot;+&quot;</span>, <span class="string">&quot;-&quot;</span>, <span class="string">&quot;*&quot;</span>, <span class="string">&quot;/&quot;</span>].<span class="title function_">indexOf</span>(operator) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> operator;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 计算操作</span></span><br><span class="line">  <span class="keyword">protected</span> evaluateOperator(</span><br><span class="line">    <span class="attr">operator</span>: <span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">left</span>: <span class="built_in">number</span>,</span><br><span class="line">    <span class="attr">right</span>: <span class="built_in">number</span></span><br><span class="line">  ): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (<span class="variable language_">this</span>.<span class="property">operator</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> left + right;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> left - right;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> left * right;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> left / right;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 计算</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">evaluate</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">operator</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">memory</span> = <span class="variable language_">this</span>.evaluateOperator(</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">operator</span>,</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">memory</span>,</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">current</span></span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">memory</span> = <span class="variable language_">this</span>.<span class="property">current</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">current</span> = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 处理输入字符串中的单个字符</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">handleChar</span>(<span class="params">char: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="comment">// = 号，则计算</span></span><br><span class="line">    <span class="keyword">if</span> (char === <span class="string">&quot;=&quot;</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.evaluate();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 否则，先当作数字字符处理</span></span><br><span class="line">      <span class="keyword">let</span> value = <span class="variable language_">this</span>.<span class="title function_">processDigit</span>(char, <span class="variable language_">this</span>.<span class="property">current</span>);</span><br><span class="line">      <span class="keyword">if</span> (value !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">current</span> = value;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不是数字字符，当作运算符处理</span></span><br><span class="line">        <span class="keyword">let</span> value = <span class="variable language_">this</span>.<span class="title function_">processOperator</span>(char);</span><br><span class="line">        <span class="keyword">if</span> (value !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">          <span class="variable language_">this</span>.evaluate();</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">operator</span> = value;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 也不是运算符，抛出错误</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`Unsupported input: &#x27;<span class="subst">$&#123;char&#125;</span>&#x27;`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取计算结果</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">getResult</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">memory</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 辅助函数用于测试</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">c: Calculator, input: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; input.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    c.<span class="title function_">handleChar</span>(input[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`result of &#x27;<span class="subst">$&#123;input&#125;</span>&#x27; is &#x27;<span class="subst">$&#123;c.getResult()&#125;</span>&#x27;`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看一下这个<code>Caculator</code>的使用示例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Calculator</span>, test &#125; <span class="keyword">from</span> <span class="string">&quot;./Calculator&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> <span class="title class_">Calculator</span>();</span><br><span class="line"><span class="title function_">test</span>(c, <span class="string">&quot;1+2*33/11=&quot;</span>); <span class="comment">// 控制台打印 9</span></span><br></pre></td></tr></table></figure><p>可以看到，<code>Caculator</code>已经可以使用了。现在，在<code>ProgrammerCalculator.ts</code>对它进行拓展，使其支持十进制以外的其它进制：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ProgrammerCalculator.ts</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 先导入 Caculator</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Calculator</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./Calculator&quot;</span>;</span><br><span class="line"><span class="comment">// 通过extends关键字来实现继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProgrammerCalculator</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Calculator</span> &#123;</span><br><span class="line">  <span class="comment">// 进制数字</span></span><br><span class="line">  <span class="keyword">static</span> digits = [</span><br><span class="line">    <span class="string">&quot;0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;2&quot;</span>,</span><br><span class="line">    <span class="string">&quot;3&quot;</span>,</span><br><span class="line">    <span class="string">&quot;4&quot;</span>,</span><br><span class="line">    <span class="string">&quot;5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;6&quot;</span>,</span><br><span class="line">    <span class="string">&quot;7&quot;</span>,</span><br><span class="line">    <span class="string">&quot;8&quot;</span>,</span><br><span class="line">    <span class="string">&quot;9&quot;</span>,</span><br><span class="line">    <span class="string">&quot;A&quot;</span>,</span><br><span class="line">    <span class="string">&quot;B&quot;</span>,</span><br><span class="line">    <span class="string">&quot;C&quot;</span>,</span><br><span class="line">    <span class="string">&quot;D&quot;</span>,</span><br><span class="line">    <span class="string">&quot;E&quot;</span>,</span><br><span class="line">    <span class="string">&quot;F&quot;</span>,</span><br><span class="line">  ];</span><br><span class="line">  <span class="comment">// public case 为参数属性</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> base: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="keyword">const</span> maxBase = <span class="title class_">ProgrammerCalculator</span>.<span class="property">digits</span>.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">if</span> (base &lt;= <span class="number">0</span> || base &gt; maxBase) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`base has to be within 0 to <span class="subst">$&#123;maxBase&#125;</span> inclusive.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 重写父类处理数字字符的方法</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">processDigit</span>(<span class="params">digit: <span class="built_in">string</span>, currentValue: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">ProgrammerCalculator</span>.<span class="property">digits</span>.<span class="title function_">indexOf</span>(digit) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        currentValue * <span class="variable language_">this</span>.<span class="property">base</span> + <span class="title class_">ProgrammerCalculator</span>.<span class="property">digits</span>.<span class="title function_">indexOf</span>(digit)</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 导出继承后的新的实体类，并重命名为 Caculator</span></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="title class_">ProgrammerCalculator</span> <span class="keyword">as</span> <span class="title class_">Calculator</span> &#125;;</span><br><span class="line"><span class="comment">// 并且 重导出 原来Caculator模块中的辅助函数</span></span><br><span class="line"><span class="keyword">export</span> &#123; test &#125; <span class="keyword">from</span> <span class="string">&quot;./Calculator&quot;</span>;</span><br></pre></td></tr></table></figure><p>接下来测试一下拓展后的<code>Caculator</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Calculator</span>, test &#125; <span class="keyword">from</span> <span class="string">&quot;./ProgrammerCalculator&quot;</span>;</span><br><span class="line"><span class="comment">// 二进制</span></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> <span class="title class_">Calculator</span>(<span class="number">2</span>);</span><br><span class="line"><span class="title function_">test</span>(c, <span class="string">&quot;001+010=&quot;</span>); <span class="comment">// 控制台打印 3</span></span><br></pre></td></tr></table></figure><h3 id="3-不要在模块中使用命名空间"><a href="#3-不要在模块中使用命名空间" class="headerlink" title="3. 不要在模块中使用命名空间"></a>3. 不要在模块中使用命名空间</h3><p>模块有自己的作用域，只有导出的成员才具有对外可见性。我们应该尽量避免在模块中使用命名空间，尤其不要踩以下两条红线：</p><ul><li>模块唯一的顶层导出是命名空间：<code>export namespace Foo &#123; ... &#125;</code>（应该移除<code>Foo</code>，并将其所有成员都上移一层）；</li><li>多个文件导出同名的命名空间：<code>export namespace Foo &#123; ... &#125;</code>，(这些命名空间<code>Foo</code>之间不会合并) 。</li></ul><h2 id="七、模块解析"><a href="#七、模块解析" class="headerlink" title="七、模块解析"></a>七、模块解析</h2><p>学了这么久的模块，也许大家也像我一样，会好奇编译器是如何解析模块的。</p><h3 id="一-模块的-相对导入-VS-非相对导入"><a href="#一-模块的-相对导入-VS-非相对导入" class="headerlink" title="(一) 模块的 相对导入 VS 非相对导入"></a>(一) 模块的 相对导入 VS 非相对导入</h3><p>在我们导入模块时，根据模块路径的书写形式，分为 <strong>相对导入</strong> 和 <strong>非相对导入</strong> 。相对导入，顾名思义，就是使用相对路径来导入模块，包含<code>./</code>，<code>../</code>等表示相对路径的字符，如</p><ul><li><code>import &#123; getName &#125; from &quot;./Person&quot;</code>;</li><li><code>import Person from &quot;./Person&quot;</code>;</li><li><code>import &quot;./mod&quot;</code>;</li></ul><p>非相对导入，便是不包含<code>./</code>，<code>../</code>等表示路径的字符，如：</p><ul><li><code>import &#123; getName &#125; from &quot;Person&quot;</code>；</li><li><code>import Person from &quot;Person&quot;</code>;</li><li><code>import &quot;mod&quot;</code>;</li></ul><p><strong>相对导入是相对于当前文件来解析，且不能解析为环境模块声明</strong>。我们自己的模块，应该使用相对导入。<strong>非相对导入基于<code>baseUrl</code>或者路径映射来解析，可以解析为环境模块声明</strong>。导入外部依赖时，应使用非相对导入。</p><h3 id="二-模块解析策略：Classic-vs-Node"><a href="#二-模块解析策略：Classic-vs-Node" class="headerlink" title="(二) 模块解析策略：Classic vs Node"></a>(二) 模块解析策略：<code>Classic</code> vs <code>Node</code></h3><p>模块解析策略有两种：<code>Classic</code>和<code>Node</code>。可以在<code>tsconfig.json</code>中设置<code>moduleResolution</code>字段来明确使用哪种策略，默认使用<code>Node</code>策略；或者在命令行指定<code>--module commonjs</code>，即为<code>Node</code>策略，如果<code>module</code>设置为其它的（如<code>amd</code>，<code>es2015</code>，<code>system</code>，<code>umd</code>等，则为<code>Classic</code>策略）。其中<code>node</code>策略最为常用，也最为推荐使用。</p><h4 id="1-Classic策略"><a href="#1-Classic策略" class="headerlink" title="1. Classic策略"></a>1. <code>Classic</code>策略</h4><p>现今阶段，<code>Node</code>策略是主流，而<code>Classic</code>策略主要是为了向后兼容而存在的。下面来看看<code>Classic</code>策略是如何解析 <strong>相对导入</strong> 和 <strong>绝对导入</strong> 的。</p><ul><li><p><strong>相对导入</strong></p><p>相对导入是根据导入文件 (不是被导入文件) 来解析的。例如，在文件<code>/root/src/folder/app.ts</code>中进行导入：<code>import &#123; getName &#125; from &quot;./Person&quot;</code>，TS 就会依次查找如下文件作为模块<code>Person</code>的位置：</p><ul><li><code>/root/src/folder/Person.ts</code>;</li><li><code>/root/src/folder/Person.d.ts</code>;</li></ul></li><li><p><strong>非相对导入</strong></p><p>而对于非相对导入，编译器则会从包含该导入文件的目录开始，在目录树中进行查找。例如，在文件<code>/root/src/folder/app.ts</code>中进行导入：<code>import &#123; getName &#125; from &quot;Person&quot;</code>，TS 就会依次查找如下文件来作为模块<code>Person</code>的位置：</p><ul><li><code>/root/src/folder/Person.ts</code>;</li><li><code>/root/src/folder/Person.d.ts</code>;</li><li><code>/root/src/Person.ts</code>;</li><li><code>/root/src/Person.d.ts</code>;</li><li><code>/root/Person.ts</code>;</li><li><code>/root/Person.d.ts</code>;</li><li><code>/Person.ts</code>;</li><li><code>/Person.d.ts</code>;</li></ul></li></ul><p>如果列举出的任何一个文件存在，则编译器能继续正常编译，否则，将会报错提示找不到相关模块。</p><h4 id="2-Node策略"><a href="#2-Node策略" class="headerlink" title="2. Node策略"></a>2. <code>Node</code>策略</h4><p><code>Node</code>策略是在运行时模仿<code>Node.js</code>的模块解析机制，因此叫做<code>Node</code>策略。一般来说，在<code>Node.js</code>中导入模块表现为调用<code>require</code>函数。给<code>require</code>函数传入 <strong>相对路径</strong> 或 <strong>非相对路径</strong> ，决定了导入是 <strong>相对导入</strong> 还是 <strong>非相对导入</strong> 。因此，在了解<code>Node</code>策略之前，我们先来看看<strong><code>Node.js</code>是如何进行模块解析</strong>的，之后再来了解 TS 中的<code>Node</code>策略又是如何解析的。</p><ul><li><p><strong>相对路径解析</strong></p><p>相对路径尤为简单。例如在文件<code>/root/src/app.js</code>中导入：<code>const p = require(&quot;./Person&quot;)</code>，则<code>Node.js</code>会查找如下文件来作为模块<code>Person</code>：</p><ol><li><p>检查<code>/root/src/Person.js</code>是否存在，不存在则进行下一步查找；</p></li><li><p>查找<code>/root/src/Person</code>目录下是否有<code>package.json</code>，如果有，则查看<code>package.json</code>中的<code>main</code>字段对应的模块，在本例中，如果在<code>/root/src/Person/package.json</code>文件中含有<code>&#123; &quot;main&quot;: &quot;lib/mainModule.js&quot; &#125;</code>，则<code>Node.js</code>会将<code>Person</code>指向<code>/root/src/Person/lib/mainModule.js</code>；否则，进行第 3 步；</p></li><li>查找<code>/root/src/Person</code>目录下是否有<code>index.js</code>，如果存在<code>/root/src/Person/index.js</code>，则该文件会隐式地被当作<code>main</code>字段对应的模块。</li></ol></li><li><p><strong>非相对路径解析</strong></p><p>非相对路径则完全不同。对于非相对路径导入，<code>Node.js</code>会在名为<code>node_modules</code>的特殊文件夹下进行查找。该文件夹可以与导入文件处于同一目录级下，也可以存在于更高的目录链中。例如，在文件<code>/root/src/app.js</code>中导入：<code>const p = require(&quot;Person&quot;)</code>，则<code>Node.js</code>会查找如下文件来作为模块<code>Person</code>：</p><ol><li><code>/root/src/node_modules/Person.js</code>;</li><li><code>/root/src/node_modules/Person/package.json</code>中<code>main</code>字段对应的文件，<code>&#123;&quot;main&quot;: &quot;/xx/xxx.js&quot;&#125;</code>，此时，<code>node.js</code>会将<code>Person</code>模块指向<code>/root/src/node_modules/Person/xx/xxx.js</code>;</li><li><code>/root/src/node_modules/Person/index.js</code>;</li><li><code>/root/node_modules/Person.js</code>，<strong>（此步骤更换了查找目录）</strong>；</li><li><code>/root/node_modules/Person/package.json</code>中<code>main</code>字段对应的文件，<code>&#123;&quot;main&quot;: &quot;/xx/xxx.js&quot;&#125;</code>，此时，<code>node.js</code>会将<code>Person</code>模块指向<code>/root/node_modules/Person/xx/xxx.js</code>;</li><li><code>/root/node_modules/Person/index.js</code>;</li><li><code>/node_modules/Person.js</code>，<strong>（此步骤更换了查找目录）</strong>；</li><li><code>/node_modules/Person/package.json</code>中<code>main</code>字段对应的文件，<code>&#123;&quot;main&quot;: &quot;/xx/xxx.js&quot;&#125;</code>，此时，<code>node.js</code>会将<code>Person</code>模块指向<code>/node_modules/Person/xx/xxx.js</code>;</li><li><code>/node_modules/Person/index.js</code>;</li></ol></li></ul><p>以上便是<code>Node.js</code>进行模块解析的简化步骤。下面来看看模仿了<code>Node.js</code>的 TS 的<code>Node</code>策略是如何解析模块的。<code>Node</code>策略会模仿<code>Node.js</code>的逻辑，来在编译时定位<code>TS</code>模块的位置。注意,<strong><code>TS</code>使用<code>Node</code>策略进行模块解析时，支持的文件拓展名有<code>.ts</code>，<code>.tsx</code>，<code>.d.ts</code></strong>。此外，<strong><code>TS</code>在<code>package.json</code>中使用<code>types</code>或<code>typings</code>字段</strong>来替代<code>Node.js</code>中的<code>package.json</code>里的<code>main</code>字段，来指定模块文件的位置。</p><ul><li><p><strong>相对导入</strong></p><p>还是以在<code>/root/src/app.ts</code>中导入：<code>import Person from &quot;./Person&quot;</code>为例，<code>TS</code>会依次尝试查找以下文件作为<code>Person</code>模块：</p><ol><li><code>/root/src/Person.ts</code>;</li><li><code>/root/src/Person.tsx</code>;</li><li><code>/root/src/Person.d.ts</code>;</li><li>查看<code>/root/src/Person/package.json</code>中的<code>types</code>属性对应的模块文件;</li><li><code>/root/src/Person/index.ts</code>;</li><li><code>/root/src/Person/index.tsx</code>;</li><li><code>/root/src/Person/index.d.ts</code>;</li></ol></li></ul><p>注意顺序，依照<code>Node.js</code>的逻辑，是先查找<code>Person.js</code>，然后是<code>Person/package.json</code>，最后才是<code>Person/index.js</code>。</p><ul><li><p><strong>非相对导入</strong></p><p>相似的，非相对导入会遵循<code>Node.js</code>的导入逻辑，若是在<code>/root/src/app.ts</code>中进行非相对导入：<code>import &#123; getName &#125; from &quot;person&quot;</code>，则编译器会依次查找如下文件作为<code>person</code>模块：</p><ul><li><code>/root/src/node_modules/person.ts</code>;</li><li><code>/root/src/node_modules/person.tsx</code>;</li><li><code>/root/src/node_modules/person.d.ts</code>;</li><li><code>/root/src/node_modules/person/package.json</code>中的<code>types</code>字段对应的文件;</li><li><code>/root/src/node_modules/@types/person.d.ts</code>; <strong>注意是<code>@types</code>目录下</strong>；</li><li><code>/root/src/node_modules/person/index.ts</code>;</li><li><code>/root/src/node_modules/person/index.d.ts</code>;</li><li><code>/root/node_modules/person.ts</code>;</li><li><code>/root/node_modules/person.tsx</code>;</li><li><code>/root/node_modules/person.d.ts</code>;</li><li><code>/root/node_modules/person/package.json</code>中的<code>types</code>字段对应的文件;</li><li><code>/root/src/node_modules/@types/person.d.ts</code>; <strong>注意是<code>@types</code>目录下</strong>；</li><li><code>/root/node_modules/person/index.ts</code>;</li><li><code>/root/node_modules/person/index.d.ts</code>;</li><li><code>/node_modules/person.ts</code>;</li><li><code>/node_modules/person.tsx</code>;</li><li><code>/node_modules/person.d.ts</code>;</li><li><code>/node_modules/person/package.json</code>中的<code>types</code>字段对应的文件;</li><li><code>/root/src/node_modules/@types/person.d.ts</code>; <strong>注意是<code>@types</code>目录下</strong>；</li><li><code>/node_modules/person/index.ts</code>;</li><li><code>/node_modules/person/index.d.ts</code>;</li></ul></li></ul><p>被这里列举出的数量吓到了吗？事实上它们是很有规律的哦！而且，上面只列举出来<code>node_modules/@types/xxx.d.ts</code>，但其实，这些还不是全部。编译器不仅仅查找<code>node_modules/@types</code>文件夹下<code>xxx.d.ts</code>文件，如果找不到该文件，依然会查找<code>node_modules/@types/person/package.json</code>中<code>types</code>字段对应的声明文件，以及<code>node_modules/@types/person/index.d.ts</code>。</p><h3 id="三-附加模块解析标志"><a href="#三-附加模块解析标志" class="headerlink" title="(三) 附加模块解析标志"></a>(三) 附加模块解析标志</h3><p>项目源布局有时并不与输出布局相匹配。最终输出结果往往由许多的打包步骤生成，例如将<code>.ts</code>代码编译为<code>.js</code>代码、将不同的源位置的依赖拷贝到相同的单一输出位置。因此，往往会导致模块在运行时具有与定义它们的文件中的不同的名字，且在编译时模块的路径也很可能与它们的源路径不匹配。</p><p>好在，<code>TS</code>有一系列的附加标志，来告知编译器发生在源上的转换以及最终的输出结果。当然，编译器不会执行这些转换，只是利用这些信息来作为指导，从而将模块解析为其源文件。</p><h4 id="1-baseUrl"><a href="#1-baseUrl" class="headerlink" title="1. baseUrl"></a>1. <code>baseUrl</code></h4><p>设置<code>baseUrl</code>从而告知编译器在哪里找到模块。所有非相对导入的模块，都被认为和<code>baseUrl</code>有关。<code>baseUrl</code>的值可以通过命令行来指定。当然，更常见更方便的是在<code>tsconfig.json</code>中设置。如果在<code>tsconfig.json</code>中设置的<code>baseUrl</code>的值是一个相对路径，则该相对路径是相对于<code>tsconfig.json</code>的位置。注意，<strong>相对导入</strong> 的模块，是不受<code>baseUrl</code>的影响的。</p><h4 id="2-paths-路径映射"><a href="#2-paths-路径映射" class="headerlink" title="2. paths 路径映射"></a>2. <code>paths</code> 路径映射</h4><p>有些时候，模块并不直接位于<code>baseUrl</code>下。此时可以使用<code>paths</code>属性来设置这些模块的路径映射。如下以<code>jquery</code>为例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;baseUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;.&quot;</span><span class="punctuation">,</span> <span class="comment">// 当存在paths属性时，必须明确baseUrl</span></span><br><span class="line">    <span class="attr">&quot;paths&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;jquery&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;node_modules/jquery/dist/jquery&quot;</span><span class="punctuation">]</span> <span class="comment">// paths时相对于baseUrl的</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><code>paths</code>属性映射的实际路径是相对于<code>baseUrl</code>的，即实际路径会随着<code>baseUrl</code>改变。在上面的栗子中，<code>baseUrl</code>设置为当前目录<code>.</code>，则<code>jquery</code>的路径为<code>./node_modules/jquery/dist/jquery</code>。注意到<strong><code>paths</code>中每一项的值都可以是数组</strong>，因此可以结合通配符<code>*</code>配置多个路径映射。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;baseUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;.&quot;</span><span class="punctuation">,</span> <span class="comment">// 当存在paths属性时，必须明确baseUrl</span></span><br><span class="line">    <span class="attr">&quot;paths&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;*&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;*&quot;</span><span class="punctuation">,</span> <span class="string">&quot;customModules/*&quot;</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>这里给<code>*</code>配置了两个路径，高速编译器可以在不同的路径下查找模块：</p><ul><li>路径<code>*</code>表示使用原路径，不作任何改变，即在<code>/baseUrl</code>下查找模块；</li><li>路径<code>customModules/*</code>表示在<code>customModules</code>前缀的目录下，即<code>/baseUrl/customModules</code>下查找模块。</li></ul><h4 id="3-rootDirs-虚拟目录"><a href="#3-rootDirs-虚拟目录" class="headerlink" title="3. rootDirs 虚拟目录"></a>3. <code>rootDirs</code> 虚拟目录</h4><p>有的时候，在编译时会将来自多个项目源的组合在一起，生成一个单一的输出目录。可以将此看作一组目录源生成了一个虚拟目录。使用<code>rootDirs</code>来指定一组目录，在运行时将其放在单一的虚拟目录下，从而使得编译器可以解析这个虚拟目录中的模块，就像它们真的被合并到一个目录中一样。例如，对于以下目录结构：</p><p>— <code>src</code></p><pre><code>— `views`    — `view1.ts` (文件内导入了模块：`import &quot;./template1&quot;`)    — `view2.ts`</code></pre><p>— <code>generated</code></p><pre><code>— `templates`    — `views`        — `template1.ts` (文件内导入了模块：`import &quot;./view2&quot;`)</code></pre><p>在以上目录结构中，可以看到<code>view1.ts</code>和<code>template1.ts</code>分别以相对导入的方式，导入了和自己同一目录下的<code>template1.ts</code>和<code>view2.ts</code>，然而，与它们同级的目录下并没有相应的文件。此时，要使得这种路径相对关系成立，则需要配置<code>rootDirs</code>。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;rootDirs&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;src/views&quot;</span><span class="punctuation">,</span> <span class="string">&quot;generated/templates/views&quot;</span><span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>通过以上配置，则多个目录<code>src/views</code>和<code>generated/templates/views</code>会在运行时结合到同一虚拟目录下，从而其相互导入时需要使用同级目录相对路径<code>./</code>。每当编译器看到<code>rootDirs</code>里的某个子文件夹中有相对模块导入，便会在<code>rootDirs</code>下所有的子文件夹中逐个查找被导入的模块。此外，<code>rootDirs</code>中可以包含任意数量的任意目录名称，无论该目录是否存在。</p><h4 id="4-traceResolution-跟踪模块解析"><a href="#4-traceResolution-跟踪模块解析" class="headerlink" title="4. traceResolution 跟踪模块解析"></a>4. <code>traceResolution</code> 跟踪模块解析</h4><p>前面说到，编译器在解析模块时，可以访问到当前文件夹以外的文件。这就导致我们很难判断为什么某个模块未能解析或者未能正确解析。于是，就该<code>traceResolution</code>出场啦。启用<code>traceResolution</code>会使编译器能够跟踪解析过程。在<code>tsconfig.json</code>中配置<code>&#123;&quot;compilerOptions&quot;: &#123;&quot;traceResolution&quot;: true&#125;&#125;</code>即可启用。之后在运行编译石控制台会打印出一系列的编译过程。</p><h4 id="5-使用-noResolve"><a href="#5-使用-noResolve" class="headerlink" title="5. 使用 noResolve"></a>5. 使用 <code>noResolve</code></h4><p>一般不会使用这个标志。一旦启用，则必须明确需要解析的模块，例如在命令行指定：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx tsc app.ts moduleA.ts --noResolve</span><br></pre></td></tr></table></figure><p>则编译器会解析 <code>moduleA</code>，但如果<code>app.ts</code>中还导入了其它模块，如<code>import Person from &quot;modulePerson&quot;</code>，则由于没有在命令行明确指定<code>modulePerson.ts</code>，而引发错误。</p><p>关于<code>TS</code>的模块，就分享到这里啦，至此我的<code>TS</code>进阶系列也进入尾声了，预计再写最终篇 <strong>编译原理</strong> ，之后就开始学习其它的知识啦。学习的时光总是辣么短暂，那么，如果有机会的话，下一篇再见吧。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前 端 </tag>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript 系列 进阶篇 (七) 声明文件 -- 从编写到发布</title>
      <link href="/articals/3c0f6206/"/>
      <url>/articals/3c0f6206/</url>
      
        <content type="html"><![CDATA[<p>在接触 TS 的过程中，时常能看到使用<code>declare</code>关键字来进行声明，而它基本都是出现在<code>.d.ts</code>文件中。你是否好奇过，使用<code>declare</code>关键字到底有什么作用？它与不使用<code>declare</code>关键字的声明又有何不同？本文与你一同探索<code>declare</code>的奥秘，讲述如何写好一个声明文件 (<code>.d.ts</code>文件)，需要小伙伴们拥有一定的<code>typescript</code>基础。如果阅读本文过程中遇到不了解的知识点，可查阅我之前的基础篇的文章。</p><p>[toc]</p><h2 id="一、Declaration-Reference-声明指南"><a href="#一、Declaration-Reference-声明指南" class="headerlink" title="一、Declaration Reference 声明指南"></a>一、Declaration Reference 声明指南</h2><p>我们先来了解到如何<strong>根据<code>API</code>文档和用法示例</strong>来编写相关的声明。这部分内容十分简单，基本看一遍过去就<code>ok</code>了。</p><h3 id="1-对象和属性"><a href="#1-对象和属性" class="headerlink" title="1. 对象和属性"></a>1. 对象和属性</h3><p>我们通常使用命名空间来声明对象。</p><ul><li><p>文档：</p><p>全局变量<code>myLib</code>，它有一个<code>greet</code>方法来创建问候语，一个<code>numberOfGreetings</code>属性来记录创建的问候语的数量。</p></li><li><p>示例：</p></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> greeting = myLib.<span class="title function_">greet</span>(<span class="string">&quot;hello, cc!&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(greeting);</span><br><span class="line"><span class="keyword">let</span> count = myLib.<span class="property">numberOfGreetings</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>声明</strong>：</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> myLib &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">greeting: <span class="built_in">string</span></span>): <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">numberOfGreetings</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-重载函数"><a href="#2-重载函数" class="headerlink" title="2. 重载函数"></a>2. 重载函数</h3><ul><li>文档：函数<code>printName</code>，接收一个字符串并打印该字符串，或者接收一个字符串数组，打印其中所有的字符串，以逗号连接，最终都返回打印的名字的数量；</li><li>示例：</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="title function_">printName</span>(<span class="string">&quot;cc&quot;</span>); <span class="comment">// x=1，控制台输出 &quot;cc&quot;</span></span><br><span class="line"><span class="keyword">let</span> y = <span class="title function_">printName</span>([<span class="string">&quot;cc&quot;</span>, <span class="string">&quot;yy&quot;</span>]); <span class="comment">// y=2，控制台输出 &quot;cc&quot;,&quot;yy&quot;</span></span><br></pre></td></tr></table></figure><ul><li><strong>声明</strong>：</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">printName</span>(<span class="params">name: <span class="built_in">string</span></span>): <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">printName</span>(<span class="params">name: <span class="built_in">string</span>[]</span>): <span class="built_in">number</span>;</span><br></pre></td></tr></table></figure><h3 id="3-类型-接口"><a href="#3-类型-接口" class="headerlink" title="3. 类型 / 接口"></a>3. 类型 / 接口</h3><p>先来看<code>interface</code>的声明。</p><ul><li><p>文档：使用<code>greet</code>函数指定问候语时，需要传递一个<code>Option</code>类型的对象作为参数，其具有以下几个属性：</p><ol><li><code>greeting</code>：问候语的内容，为一个字符串；</li><li><code>color</code>：问候语的颜色，为一个表示颜色的字符串，可选；</li></ol></li><li><p>示例：</p></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// color 可选</span></span><br><span class="line"><span class="title function_">greet</span>(&#123; <span class="attr">greeting</span>: <span class="string">&quot;hello, cc!&quot;</span>, <span class="attr">color</span>: <span class="string">&quot;#ccc&quot;</span> &#125;);</span><br><span class="line"><span class="title function_">greet</span>(&#123; <span class="attr">greeting</span>: <span class="string">&quot;hello, yy!&quot;</span> &#125;);</span><br></pre></td></tr></table></figure><ul><li><strong>声明</strong>：</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Option</span> &#123;</span><br><span class="line">  <span class="attr">greeting</span>: <span class="built_in">string</span>;</span><br><span class="line">  color?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">opt: Option</span>): <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure><p>很简单对不对，类型别名也很几乎一样，就演示了。</p><h3 id="4-类-classes"><a href="#4-类-classes" class="headerlink" title="4. 类 classes"></a>4. 类 <code>classes</code></h3><ul><li>文档：可以创建一个<code>Greeter</code>实例，也可以通过继承来自定义一个类；</li><li>示例：</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myGreeter = <span class="keyword">new</span> <span class="title class_">Greeter</span>(<span class="string">&quot;hello, world&quot;</span>);</span><br><span class="line">myGreeter.<span class="property">greeting</span> = <span class="string">&quot;hello, cc!&quot;</span>;</span><br><span class="line">myGreeter.<span class="title function_">showGreeting</span>();</span><br><span class="line"><span class="comment">// 自定义类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialGreeter</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Greeter</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(<span class="string">&quot;Very special greetings&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>声明</strong>：</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 declare class 来声明</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">class</span> <span class="title class_">Greeter</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">greeting: <span class="built_in">string</span></span>);</span><br><span class="line">  <span class="attr">greeting</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">showGreeting</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-全局变量"><a href="#5-全局变量" class="headerlink" title="5. 全局变量"></a>5. 全局变量</h3><ul><li><p>文档：全局变量<code>foo</code>表示函数的总数量；</p></li><li><p>示例：</p></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`一共有 <span class="subst">$&#123;foo&#125;</span> 个函数。`</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>声明</strong>：</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">var</span> <span class="attr">foo</span>: <span class="built_in">number</span>;</span><br></pre></td></tr></table></figure><h3 id="6-全局函数"><a href="#6-全局函数" class="headerlink" title="6. 全局函数"></a>6. 全局函数</h3><ul><li><p>文档：传入一个字符串来调用<code>greet</code>；</p></li><li><p>示例：</p></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">greet</span>(<span class="string">&quot;hello, cc!&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="二、Library-Structures-库的结构"><a href="#二、Library-Structures-库的结构" class="headerlink" title="二、Library Structures 库的结构"></a>二、Library Structures 库的结构</h2><p>广义而言，声明文件的构建方式取决于库的使用方式。而在<code>JavaScript</code>中，库的使用方式有多种，因此，我们需要鉴别不同的使用方式，并编写匹配的声明文件。</p><h3 id="1-如何识别库的种类"><a href="#1-如何识别库的种类" class="headerlink" title="1. 如何识别库的种类"></a>1. 如何识别库的种类</h3><p>编写声明文件的第一步便是识别库的结构。下面我们来了解一下如何根据库的 <strong>用法</strong> 和 <strong>代码</strong> 来识别库的种类。查看库时主要注意两点：</p><ol><li>如何获取该库？例如，是否只能通过<code>npm</code>或者<code>CDN</code>来获取；</li><li>如何导入该库？该库是否添加了一个全局对象？是否使用<code>require</code>或者<code>import/export</code>语句。</li></ol><p>现代的库基本都属于 <strong>模块</strong>系列。从 <strong>代码</strong> 方面识别，我们可以关注以下的关键字和语句：</p><ul><li>无条件调用<code>require</code>或<code>define</code>；</li><li>声明语句，如<code>import * as x from &quot;ModuleX&quot;</code>或<code>export x</code>；</li><li>赋值给<code>exports</code>或<code>module.exports</code>；</li><li>赋值给全局变量<code>window</code>或<code>global</code>。</li></ul><p>属于模块系列的模板大概有基础模块<code>modue.d.ts</code>，函数模块<code>module-function.d.ts</code>，类模块<code>module-class.d.ts</code>，和插件模块<code>module-plugin.d.ts</code>，这些将在后面的 <strong>声明模板</strong> 小节来介绍。</p><h3 id="2-Global-Libraries-全局库"><a href="#2-Global-Libraries-全局库" class="headerlink" title="2. Global Libraries 全局库"></a>2. Global Libraries 全局库</h3><p>全局库是无需使用<code>import</code>等语句导入，便可以在全局作用域下使用的库。有些库会暴露一个或多个全局变量来供我们使用。例如，用过<code>jQuery</code>的同学应该会知道全局变量<code>$</code>。往常，我们使用这些全局库，可以通过在<code>html</code>文件中使用<code>&lt;script scr=&quot;xxx&quot;&gt;</code>标签来提供相应全局变量。但是现在，许多流行的全局库都是当作通用模块化方案<code>UMD</code>的库来写的，且不容易与<code>UMD</code>区分开来。在编写全局库的声明文件之前，一定要确保它们实际上并不是<code>UMD</code>的库。</p><p>从 <strong>代码</strong> 层面识别全局库：</p><ul><li>全局作用域声明的变量、函数等；</li><li>添加给<code>window</code>，<code>global</code>，<code>globalThis</code>等全局对象的属性，如<code>window.xxx</code>；</li><li>存在于<code>document</code>等全局<code>DOM</code>变量上的属性；</li></ul><h3 id="3-UMD"><a href="#3-UMD" class="headerlink" title="3. UMD"></a>3. <code>UMD</code></h3><p><code>UMD</code>为通用模块化方案，采用该方案的库，既能用作模块（使用导入语句），也可以直接通过暴露的全局变量来使用。<code>UMD</code>模块会检查是否存在模块加载器环境。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params">root, factory</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">&quot;function&quot;</span> &amp;&amp; define.<span class="property">amd</span>) &#123;</span><br><span class="line">        <span class="title function_">define</span>([<span class="string">&quot;libName&quot;</span>], factory);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">module</span> === <span class="string">&quot;object&quot;</span> &amp;&amp; <span class="variable language_">module</span>.<span class="property">exports</span>) &#123;</span><br><span class="line">        <span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">factory</span>(<span class="built_in">require</span>(<span class="string">&quot;libName&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        root.<span class="property">returnExports</span> = <span class="title function_">factory</span>(root.<span class="property">libName</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(<span class="variable language_">this</span>, <span class="keyword">function</span> (<span class="params">b</span>) &#123;</span><br><span class="line">    <span class="comment">// xxx</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>UMD</code>的库往往会在文件的顶层使用<code>typeof define</code>，<code>typeof module</code>，<code>typeof window</code>等来测试运行环境，如果我们看到使用了这些语句的，那么大概率就是<code>UMD</code>的库。文档中一般也会为使用<code>require</code>导入的注明 “Using in <code>Node.js</code>” ，为使用<code>&lt;script&gt;</code>标签来引入的注明”Using in the browser”。</p><h2 id="三、Consuming-Dependencies-依赖处理"><a href="#三、Consuming-Dependencies-依赖处理" class="headerlink" title="三、Consuming Dependencies 依赖处理"></a>三、Consuming Dependencies 依赖处理</h2><p>声明文件中可能需要用到各种相关的依赖，这里介绍如何导入这些依赖。</p><h3 id="1-对全局库的依赖"><a href="#1-对全局库的依赖" class="headerlink" title="1. 对全局库的依赖"></a>1. 对全局库的依赖</h3><p>如果我们的编写的库，依赖于其它的全局库，可以使用 <a href="https://juejin.cn/post/7075243725210779684"><strong>三斜杠指令</strong></a> <code>/// &lt;reference types=&quot;xxx&quot; /&gt;</code>来引入。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference types=&quot;someLib&quot; /&gt;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getThing</span>(<span class="params"></span>): someLib.<span class="property">something</span>;</span><br></pre></td></tr></table></figure><h3 id="2-对模块的依赖"><a href="#2-对模块的依赖" class="headerlink" title="2. 对模块的依赖"></a>2. 对模块的依赖</h3><p>如果我们的库依赖与其它模块，则使用<code>import</code>来导入该模块。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> moment <span class="keyword">from</span> <span class="string">&quot;moment&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getThing</span>(<span class="params"></span>): moment;</span><br></pre></td></tr></table></figure><h3 id="3-对UMD库的依赖"><a href="#3-对UMD库的依赖" class="headerlink" title="3. 对UMD库的依赖"></a>3. 对<code>UMD</code>库的依赖</h3><p>对<code>UMD</code>库的依赖也分为全局库(以<code>UMD</code>方式构建的全局库) 和 <code>UMD</code>库。</p><p>如果我们的库依赖于<code>UMD</code>的全局库 ，也使用<a href="https://juejin.cn/post/7075243725210779684"><strong>三斜杠指令</strong></a> <code>/// &lt;reference types=&quot;xxx&quot; /&gt;</code>来引入。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference types=&quot;moment&quot; /&gt;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getThing</span>(<span class="params"></span>): moment;</span><br></pre></td></tr></table></figure><p>如果依赖于其它的 <strong>模块</strong> 或者严格意义上的<code>UMD</code> <strong>库</strong> ，则使用<code>import</code>来导入。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> someLib <span class="keyword">from</span> <span class="string">&quot;someLib&quot;</span>;</span><br></pre></td></tr></table></figure><p><strong>切勿使用三斜杠指令来引入<code>UMD</code>库</strong>，因此，需要分清到底是使用了<code>UMD</code>方式的全局库，还是实际上的<code>UMD</code>库。</p><h2 id="四、-d-ts-声明文件模板"><a href="#四、-d-ts-声明文件模板" class="headerlink" title="四、.d.ts 声明文件模板"></a>四、<code>.d.ts</code> 声明文件模板</h2><p>这里介绍模块相关的<code>.d.ts</code>文件模板。声明模版是用于为库进行声明的，而不是起实际作用的库，真正起作用的是全局修改模块，而不是声明文件本身。</p><h3 id="一-模块基础声明模板-modules-d-ts"><a href="#一-模块基础声明模板-modules-d-ts" class="headerlink" title="(一) 模块基础声明模板 modules.d.ts"></a>(一) 模块基础声明模板 <code>modules.d.ts</code></h3><h4 id="1-常见的CommonJs模式"><a href="#1-常见的CommonJs模式" class="headerlink" title="1. 常见的CommonJs模式"></a>1. 常见的<code>CommonJs</code>模式</h4><p>直接上简单的栗子，如下导出一个常量和一个函数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> maxInterval = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getArrayLength</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="property">length</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  getArrayLength,</span><br><span class="line">  maxInterval,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>则<code>.d.ts</code>声明文件可以如下编写：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">getArrayLength</span>(<span class="params">arr: <span class="built_in">any</span>[]</span>): <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">maxInterval</span>: <span class="number">12</span>;</span><br></pre></td></tr></table></figure><p>可以看见，在<code>.d.ts</code>文件中导出的语法，和<code>ES6</code>语法相似。此外，也有<strong>默认导出</strong>。</p><p>在<code>CommonJs</code>中可以默认导出任何值。如下默认导出一个正则表达式：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="regexp">/hello( world)?/</span>;</span><br></pre></td></tr></table></figure><p>则在<code>.d.ts</code>文件中，使用<code>export default</code>来进行默认导出。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// xxx.d.ts</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> <span class="attr">helloWorld</span>: <span class="title class_">RegExp</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> helloWorld;</span><br></pre></td></tr></table></figure><p><strong>在<code>CommonJs</code>中导出函数</strong>比较特别，因为函数也是一个对象，可以给它添加属性。因此，<code>CommonJs</code><strong>导出的函数也会包含所添加的属性，但是<code>.d.ts</code>文件中需要分别描述</strong>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getArrayLength</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="property">length</span>;</span><br><span class="line">&#125;</span><br><span class="line">getArrayLength.<span class="property">maxInterval</span> = <span class="number">12</span>;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = getArrayLength; <span class="comment">// 包含了getArrayLength.maxInterval属性</span></span><br></pre></td></tr></table></figure><p>则在<code>.d.ts</code>文件中如下描述：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分开导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">getArrayLength</span>(<span class="params">arr: <span class="built_in">any</span>[]</span>): <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">maxInterval</span>: <span class="number">12</span>;</span><br></pre></td></tr></table></figure><p>需要注意，在<code>.d.ts</code>文件中使用<code>export default</code>需要我们开启<code>esModuleInterop: true</code>，如果无法开启，则只能使用旧语法<code>export = xxx</code>来代替。例如，上面的栗子用<code>export = xxx</code>语法来写：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">getArrayLength</span>(<span class="params">arr: <span class="built_in">any</span>[]</span>): <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> getArrayLength &#123;</span><br><span class="line">  <span class="keyword">declare</span> <span class="keyword">const</span> <span class="attr">maxInterval</span>: <span class="number">12</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> = getArrayLength;</span><br></pre></td></tr></table></figure><h4 id="2-各种导入方式的处理"><a href="#2-各种导入方式的处理" class="headerlink" title="2. 各种导入方式的处理"></a>2. 各种导入方式的处理</h4><p>我们知道，模块的导入有很多写法，如果要支持这些写法，那么我们的库需要做相应的处理。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FastifyInstance</span> &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fastify</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FastifyInstance</span>();</span><br><span class="line">&#125;</span><br><span class="line">fastify.<span class="property">FastifyInstance</span> = <span class="title class_">FastifyInstance</span>;</span><br><span class="line"><span class="comment">// 允许使用 &#123; fastify &#125; 来导入</span></span><br><span class="line">fastify.<span class="property">fastify</span> = fastify;</span><br><span class="line"><span class="comment">// 提供严格的ES Module支持</span></span><br><span class="line">fastify.<span class="property">default</span> = fastify;</span><br><span class="line"><span class="comment">// 设置默认导出项</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = fastify;</span><br></pre></td></tr></table></figure><h4 id="3-模块代码中的命名空间"><a href="#3-模块代码中的命名空间" class="headerlink" title="3. 模块代码中的命名空间"></a>3. 模块代码中的命名空间</h4><p>当我们使用类<code>ES6</code>语法难以描述导出时，就可以使用命名空间来描述。如下，通过 <a href="https://juejin.cn/post/7073383136213598222">声明合并</a> 来合并<code>class</code>和<code>namespace</code>，导出的<code>class</code>中可以访问<code>namespace</code>中暴露的成员。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">API</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">baseURL: <span class="built_in">string</span></span>);</span><br><span class="line">  <span class="title function_">getInfo</span>(<span class="attr">opts</span>: <span class="variable constant_">API</span>.<span class="property">InfoRequest</span>): <span class="variable constant_">API</span>.<span class="property">InfoResponse</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 命名空间和类会被合并</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> API &#123;</span><br><span class="line">  <span class="comment">// 通过export关键字暴露的成员，可以在其它同名的namespace/class中访问</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">InfoRequest</span> &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="built_in">string</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">InfoResponse</span> &#123;</span><br><span class="line">    <span class="attr">width</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">height</span>: <span class="built_in">number</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于<code>namespace</code>在<code>.d.ts</code>文件中起什么作用，会在后面的 <strong>深入理解</strong> 小节中介绍。</p><h4 id="4-可选的全局用法"><a href="#4-可选的全局用法" class="headerlink" title="4. 可选的全局用法"></a>4. 可选的全局用法</h4><p>使用<code>export as namespace MyModule</code>来声明，则在<code>UMD</code>上下文中，可在全局作用域下访问<code>MyModule</code>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">as</span> <span class="keyword">namespace</span> <span class="title class_">MyModule</span>;</span><br></pre></td></tr></table></figure><h4 id="5-文件示例-d-ts"><a href="#5-文件示例-d-ts" class="headerlink" title="5. 文件示例.d.ts"></a>5. 文件示例<code>.d.ts</code></h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Type definitions for [~库的名字~] [~版本号(可选)~]</span></span><br><span class="line"><span class="comment">// Project: [~工程名字~]</span></span><br><span class="line"><span class="comment">// Definitions by: [~你的名字~] &lt;[~你的主页链接~]&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*~这是个示例，我们在写自己的声明文件时，应该重命名为：index.d.ts，</span></span><br><span class="line"><span class="comment"> *~并放在与模块名相同的名字的目录下，例如，模块名为 ModuleA，</span></span><br><span class="line"><span class="comment"> *~则此文件：ModuleA/index.d.ts</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ 如果本模块是暴露了全局对象的UMD模块，</span></span><br><span class="line"><span class="comment"> *~ 则在此处进行全局库的声明，</span></span><br><span class="line"><span class="comment"> *~ 否则，删掉这个声明</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">as</span> <span class="keyword">namespace</span> myLib;</span><br><span class="line"></span><br><span class="line">/*~ 如果本模块导出了函数，则声明如下 */</span><br><span class="line">export function myFunction(a: string): string;</span><br><span class="line">export function myOtherFunction(a: number): number;</span><br><span class="line"></span><br><span class="line">/*~ 类型的声明如下 */</span><br><span class="line">export interface <span class="title class_">SomeType</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">length</span>: <span class="built_in">number</span>;</span><br><span class="line">  extras?: <span class="built_in">string</span>[];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*~ 使用const，let，var等关键字声明属性 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">myField</span>: <span class="built_in">number</span>;</span><br></pre></td></tr></table></figure><h4 id="6-库的目录结构"><a href="#6-库的目录结构" class="headerlink" title="6. 库的目录结构"></a>6. 库的目录结构</h4><p>一个库往往由许多个模块组成，清晰的目录结构十分重要。例如，当我们的库包含如下模块时：</p><p><code>myLib</code></p><pre><code>+---- `index.js `+---- `foo.js`+---- `bar`    +---- `index.js`    +---- `baz.js`</code></pre><p>使用该库时，就有不同的导入：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&quot;myLib&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">&quot;myLib/foo&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> c = <span class="built_in">require</span>(<span class="string">&quot;myLib/bar&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> d = <span class="built_in">require</span>(<span class="string">&quot;myLib/bar/baz&quot;</span>);</span><br></pre></td></tr></table></figure><p>则相应的，我们的声明文件应该在如下的目录结构中：</p><p><code>@types/myLib</code></p><pre><code>+---- `index.d.ts`+---- `foo.d.ts`+---- `bar`    +---- `index.d.ts`    +---- `baz.d.ts`</code></pre><h4 id="7-类型文件测试"><a href="#7-类型文件测试" class="headerlink" title="7. 类型文件测试"></a>7. 类型文件测试</h4><ul><li><p>如果我们希望自己的库提交到<code>DefinitelyTyped</code>供所有人使用，则需要做如下操作：</p><ol><li><p>在<code>node_modules/@types/[libname]</code>处创建新的文件夹；</p></li><li><p>在该文件夹下创建一个<code>index.d.ts</code>文件，并将上面的参考示例复制进去；</p></li><li>根据我们对模块使用中断的地方，来把<code>index.d.ts</code>填充完整；</li><li>当<code>index.d.ts</code>文件填充至满意时，下载<a href="https://github.com/DefinitelyTyped">DefinitelyTyped/DefinitelyTyped</a>]并按<code>README</code>的指导来操作。</li></ol></li><li><p>其它情况，例如只需要在自己的项目中使用，则只需做一些简单操作：</p><ol><li>在项目根目录下创建一个<code>[libname].d.ts</code>文件；</li><li>在该文件中添加<code>declare module &quot;[libname]&quot; &#123; &#125;</code>；</li><li>将参考示例复制到”{ }”中，并根据模块中断的地方进行填充至满意。</li></ol></li></ul><h3 id="二-模块插件声明模板-module-plugin-d-ts"><a href="#二-模块插件声明模板-module-plugin-d-ts" class="headerlink" title="(二) 模块插件声明模板 module-plugin.d.ts"></a>(二) 模块插件声明模板 <code>module-plugin.d.ts</code></h3><p>举个栗子，有时候我们想拓展其它库的功能。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; greeter &#125; <span class="keyword">from</span> <span class="string">&quot;super-greeter&quot;</span>;</span><br><span class="line"><span class="comment">// 平常的Greeter API</span></span><br><span class="line"><span class="title function_">greeter</span>(<span class="number">2</span>);</span><br><span class="line"><span class="title function_">greeter</span>(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line"><span class="comment">// hyper-super-greeter是我们拓展后得到的库，提供了拓展API</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;hyper-super-greeter&quot;</span>;</span><br><span class="line"><span class="comment">// 拓展API</span></span><br><span class="line">greeter.<span class="title function_">hyperGreet</span>();</span><br></pre></td></tr></table></figure><p>假设<code>super-greeter</code>的定义如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*~ 演示通过函数签名来进行函数重载 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">GreeterFunction</span> &#123;</span><br><span class="line">  (<span class="attr">name</span>: <span class="built_in">string</span>): <span class="built_in">void</span>;</span><br><span class="line">  (<span class="attr">time</span>: <span class="built_in">number</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*~ 演示函数的导出 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">greeter</span>: <span class="title class_">GreeterFunction</span>;</span><br></pre></td></tr></table></figure><p>则<code>hyper-super-greeter</code>作为插件模块，拓展<code>super-greeter</code>的<code>API</code>，其定义为：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Type definitions for [~库的名字~] [~版本号(可选)~]</span></span><br><span class="line"><span class="comment">// Project: [~工程名字~]</span></span><br><span class="line"><span class="comment">// Definitions by: [~你的名字~] &lt;[~你的主页链接~]&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*~这是个模块插件示例，我们在写自己的声明文件时，应该重命名为：index.d.ts，</span></span><br><span class="line"><span class="comment"> *~并放在与模块名相同的名字的目录下，例如，模块名为 hyper-super-greeter，</span></span><br><span class="line"><span class="comment"> *~则此文件：hyper-super-greeter/index.d.ts</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ 导入要继承的模块 */</span></span><br><span class="line"><span class="keyword">import</span> &#123; greeter &#125; <span class="keyword">from</span> <span class="string">&quot;super-greeter&quot;</span>;</span><br><span class="line"><span class="comment">/*~ 导出模块，其名称需要和导入的模块名称相同，</span></span><br><span class="line"><span class="comment"> *~ 如此，便对原模块的API进行了拓展</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="variable language_">module</span> <span class="string">&quot;super-greeter&quot;</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">GreeterFunction</span> &#123;</span><br><span class="line">    <span class="comment">/** Greets even better! */</span></span><br><span class="line">    <span class="title function_">hyperGreet</span>(): <span class="built_in">void</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依照官方文档给出的示例，在<code>vscode</code>中进行编辑，却发现对<code>export</code>关键字报错：<code>&#39;export&#39; modifier cannot be applied to ambient modules and module augmentations since they are always visible</code>。此外，我无需进行<code>import &quot;hyper-super-greeter&quot;</code>，就可以直接调用<code>greeter.hyperGreet()</code>，这和说好的不一样！先埋个坑，等解决了回来更新，如果有知道如何解决的同学，还望不吝赐教。</p><h3 id="三-模块类-声明模板"><a href="#三-模块类-声明模板" class="headerlink" title="(三) 模块类 声明模板"></a>(三) 模块类 声明模板</h3><p>在模块中声明类，为了能使模块类按<code>UMD</code>方式导入和按 <strong>模块</strong> 方式导入，需要分别处理。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Type definitions for [~库的名字~] [~版本号，可选~]</span></span><br><span class="line"><span class="comment">// Project: [~工程名字~]</span></span><br><span class="line"><span class="comment">// Definitions by: [~你的名字~] &lt;[~你的主页链接~]&gt;</span></span><br><span class="line"><span class="comment">/*~ 这是个模块类的示例.</span></span><br><span class="line"><span class="comment"> *~ 记得重命名为 index.d.ts 并放在与模块名同名的文件夹下！</span></span><br><span class="line"><span class="comment"> *~ 你如，你编写的模块名为 &quot;super-greeter&quot;,</span></span><br><span class="line"><span class="comment"> *~ 则这个文件的路径为 &#x27;super-greeter/index.d.ts&#x27;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 注意，ES6 模块 不能直接导出 类 对象.</span></span><br><span class="line"><span class="comment">// 本模块应该按照CommonJs风格来导入:</span></span><br><span class="line"><span class="comment">//   import x = require(&#x27;[~THE MODULE~]&#x27;);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 或者，如果开启了 --allowSyntheticDefaultImports 或</span></span><br><span class="line"><span class="comment">// --esModuleInterop , 则本模块也支持默认导入：</span></span><br><span class="line"><span class="comment">//   import x from &#x27;[~THE MODULE~]&#x27;;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">/*~ 如果这是个UMD模块，且暴露了一个全局变量 &#x27;myGreeter&#x27; 用来在模块加载器环境之外来加载本模块，</span></span><br><span class="line"><span class="comment"> *~ 则在这里声明这个全局变量，</span></span><br><span class="line"><span class="comment"> *~ 否则删除这个声明.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">as</span> <span class="keyword">namespace</span> <span class="title class_">MyGreeter</span>;</span><br><span class="line">/*~ 导出类构造函数</span><br><span class="line"> */</span><br><span class="line">export = <span class="title class_">Greeter</span>;</span><br><span class="line">/*~ 编写类的属性和方法 */</span><br><span class="line">declare class <span class="title class_">Greeter</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">customGreeting?: <span class="built_in">string</span></span>);</span><br><span class="line">  <span class="attr">greet</span>: <span class="built_in">void</span>;</span><br><span class="line">  <span class="title function_">myMethod</span>(<span class="attr">opts</span>: <span class="title class_">MyClass</span>.<span class="property">MyClassMethodOptions</span>): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*~ 如果想要导出相关的类型，则可以写在这里。</span></span><br><span class="line"><span class="comment"> *~</span></span><br><span class="line"><span class="comment"> *~ 需要注意，如果导出了这个命名空间，</span></span><br><span class="line"><span class="comment"> *~ 除非启用了 --esModuleInterop，</span></span><br><span class="line"><span class="comment"> *~ 则本模块不能正确地作为命名空间对象来导入：</span></span><br><span class="line"><span class="comment"> *~   import * as x from &#x27;[~THE MODULE~]&#x27;; // 错误</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">MyClassMethodOptions</span> &#123;</span><br><span class="line">    width?: <span class="built_in">number</span>;</span><br><span class="line">    height?: <span class="built_in">number</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四-模块函数-声明模板"><a href="#四-模块函数-声明模板" class="headerlink" title="(四) 模块函数 声明模板"></a>(四) 模块函数 声明模板</h3><p>在模块中声明函数，为了能使模块类按<code>UMD</code>方式导入和按 <strong>模块</strong> 方式导入，需要分别处理。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Type definitions for [~库的名字~] [~版本号，可选~]</span></span><br><span class="line"><span class="comment">// Project: [~工程名字~]</span></span><br><span class="line"><span class="comment">// Definitions by: [~你的名字~] &lt;[~你的主页链接~]&gt;</span></span><br><span class="line"><span class="comment">/*~ 这是个模块函数的模板，</span></span><br><span class="line"><span class="comment"> *~ 记得重命名为 index.d.ts 并置于与模块同名的的文件夹下，</span></span><br><span class="line"><span class="comment"> *~ 例如，模块名为 &quot;super-greeter&quot;,</span></span><br><span class="line"><span class="comment"> *~ 则本文件的路径为 &#x27;super-greeter/index.d.ts&#x27;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 注意，ES6 模块不能直接导出类对象，因此，</span></span><br><span class="line"><span class="comment">// 本文件应该使用CommonJs风格来导入:</span></span><br><span class="line"><span class="comment">//   import x = require(&#x27;[~THE MODULE~]&#x27;);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 或者, 如果启用了 --allowSyntheticDefaultImports 或 --esModuleInterop ，</span></span><br><span class="line"><span class="comment">// 则也可以使用默认导入:</span></span><br><span class="line"><span class="comment">//   import x from &#x27;[~THE MODULE~]&#x27;;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">/*~ 如果这是个暴露了全局变量&quot;myFuncLib&quot;的UMD模块，</span></span><br><span class="line"><span class="comment"> *~ 则在这里声明该全局变量，</span></span><br><span class="line"><span class="comment"> *~ 否则，删除此声明</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">as</span> <span class="keyword">namespace</span> myFuncLib;</span><br><span class="line">/*~ 这里声明导出的对象</span><br><span class="line"> */</span><br><span class="line">export = <span class="title class_">Greeter</span>;</span><br><span class="line">/*~ 演示如何声明多个函数重载 */</span><br><span class="line">declare function <span class="title class_">Greeter</span>(name: string): <span class="title class_">Greeter</span>.<span class="title class_">NamedReturnType</span>;</span><br><span class="line">declare function <span class="title class_">Greeter</span>(length: number): <span class="title class_">Greeter</span>.<span class="title class_">LengthReturnType</span>;</span><br><span class="line">/*~ 如果要导出相应的类型，则在这里进行声明，</span><br><span class="line"> *~ 通常来说，我们会在这里声明函数返回值的类型，示例如下</span><br><span class="line"> *~</span><br><span class="line"> *~ 注意，一旦声明了这个命名空间, 除非启用了 --esModuleInterop ，</span><br><span class="line"> *~ 否则模块将无法正确按照命名空间对象来导入：</span><br><span class="line"> *~   import * as x from &#x27;[~THE MODULE~]&#x27;; // 错误!</span><br><span class="line"> */</span><br><span class="line">declare <span class="keyword">namespace</span> <span class="title class_">Greeter</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">LengthReturnType</span> &#123;</span><br><span class="line">    <span class="attr">width</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">height</span>: <span class="built_in">number</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">NamedReturnType</span> &#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">lastName</span>: <span class="built_in">string</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*~ 如果函数本身具有属性，则在这里进行声明，</span></span><br><span class="line"><span class="comment">   *~ 本声明表示如下操作是ok的:</span></span><br><span class="line"><span class="comment">   *~   import f = require(&#x27;super-greeter&#x27;);</span></span><br><span class="line"><span class="comment">   *~   console.log(f.defaultName);</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">defaultName</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">let</span> <span class="attr">defaultLength</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五-全局声明文件-Global-d-ts"><a href="#五-全局声明文件-Global-d-ts" class="headerlink" title="(五) 全局声明文件 Global.d.ts"></a>(五) 全局声明文件 <code>Global.d.ts</code></h3><p><strong>全局声明的库可以无需导入便能使用</strong>。在 <strong>二、库的结构</strong> 中提到，如今很多流行的全局库都采用<code>UMD</code>的方式来编写，且不易与实际上的<code>UMD</code>库区分开来，也提到了如何从代码层面识别全局库。我们在编写全局库的声明文件时，务必要保证这不是一个<code>UMD</code>的库。</p><p>如下给出一个全局库的声明模板：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Type definitions for [~库的名字~] [~版本号，可选~]</span></span><br><span class="line"><span class="comment">// Project: [~工程名~]</span></span><br><span class="line"><span class="comment">// Definitions by: [~汝名~] &lt;[~你的主页链接~]&gt;</span></span><br><span class="line"><span class="comment">/*~ 如果这个库可以直接进行调用（类似模块函数）,</span></span><br><span class="line"><span class="comment"> *~ 则在此声明调用签名，</span></span><br><span class="line"><span class="comment"> *~ 否则，移除这一段。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">myLib</span>(<span class="params">a: <span class="built_in">string</span></span>): <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">myLib</span>(<span class="params">a: <span class="built_in">number</span></span>): <span class="built_in">number</span>;</span><br><span class="line"><span class="comment">/*~ 如果希望这个库的名字可以作为有效的类型名,</span></span><br><span class="line"><span class="comment"> *~ 则在此处编写，</span></span><br><span class="line"><span class="comment"> *~ 否则可移除本段。</span></span><br><span class="line"><span class="comment"> *~</span></span><br><span class="line"><span class="comment"> *~ 如下示例将允许我们定义变量 &#x27;var x: myLib&#x27;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">interface</span> myLib &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">length</span>: <span class="built_in">number</span>;</span><br><span class="line">  extras?: <span class="built_in">string</span>[];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*~ 如果这个库暴露的全局变量上有其它属性,</span></span><br><span class="line"><span class="comment"> *~ 则在这里进行声明.</span></span><br><span class="line"><span class="comment"> *~ 当然也要声明相应的类型(接口或类型别名)。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> myLib &#123;</span><br><span class="line">  <span class="comment">//~ 变量，&#x27;myLib.timeout = 50;&#x27;</span></span><br><span class="line">  <span class="keyword">let</span> <span class="attr">timeout</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="comment">//~ 常量</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">version</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="comment">//~ 命名空间中嵌套类，可以通过new来创建：&#x27;let c = new myLib.Cat(42)&#x27;</span></span><br><span class="line">  <span class="comment">//~ 或者引用其构造函数，如：&#x27;function f(c: myLib.Cat) &#123; ... &#125;</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">n: <span class="built_in">number</span></span>);</span><br><span class="line">    <span class="comment">//~ 类的只读实例属性</span></span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="comment">//~ 类的实例方法</span></span><br><span class="line">    <span class="title function_">purr</span>(): <span class="built_in">void</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//~ 使用interface声明包含的类型，使得如下操作是ok的：</span></span><br><span class="line">  <span class="comment">//~   &#x27;var s: myLib.CatSettings = &#123; weight: 5, name: &quot;Maru&quot; &#125;;&#x27;</span></span><br><span class="line">  <span class="keyword">interface</span> <span class="title class_">CatSettings</span> &#123;</span><br><span class="line">    <span class="attr">weight</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    tailLength?: <span class="built_in">number</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//~ 使用类型别名来声明类型：</span></span><br><span class="line">  <span class="keyword">type</span> <span class="title class_">VetID</span> = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line">  <span class="comment">//~ 声明方法，本示例可以通过如下方式调用：</span></span><br><span class="line">  <span class="comment">//~ &#x27;myLib.checkCat(c)&#x27; or &#x27;myLib.checkCat(c, v);&#x27;</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">checkCat</span>(<span class="params">c: Cat, s?: VetID</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到区别，全局库都是使用的<code>declare</code>而不是<code>export</code>，因此其声明的库无需导入，全局可用。</p><h3 id="六-全局修改模块"><a href="#六-全局修改模块" class="headerlink" title="(六) 全局修改模块"></a>(六) 全局修改模块</h3><p>全局修改模块用于在导入时更改全局范围内现有的值。例如，可能存在某个全局修改模块<code>gLib</code>，在导入该模块时给<code>Object.prototype</code>添加成员。由于运行时可能存在的冲突，这个模式有一定的危险性，不过我们依然可以为其编写声明。</p><ul><li>识别全局修改模块</li></ul><p>全局修改模块很好识别，它们往往了类似于全局插件，不过需要使用<code>require</code>来导入，使其作用生效。</p><p>其用法示例可能类似如下所示：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用require导入，但是一般不会用到返回值，即unused后续一般不会使用。</span></span><br><span class="line"><span class="keyword">var</span> unused = <span class="built_in">require</span>(<span class="string">&quot;magic-string-time&quot;</span>);</span><br><span class="line"><span class="comment">/* 或者不赋值给某个变量，而直接require */</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;magic-string-time&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> x = <span class="string">&quot;hello, world&quot;</span>;</span><br><span class="line"><span class="comment">// 导入时为某个内置类型添加了新的方法，</span></span><br><span class="line"><span class="comment">// 如这里给字符串类型添加了startsWithHello方法，因此这里可以直接使用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x.<span class="title function_">startsWithHello</span>());</span><br></pre></td></tr></table></figure><ul><li>全局模块 声明模板：</li></ul><p>再次强调，声明模版是用于为库进行声明的，而不是起实际作用的库，真正起作用的是全局修改模块，而不是声明文件本身。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Type definitions for [~库的名字~] [~版本号，可选~]</span></span><br><span class="line"><span class="comment">// Project: [~工程名~]</span></span><br><span class="line"><span class="comment">// Definitions by: [~汝名~] &lt;[~主页链接~]&gt;</span></span><br><span class="line"><span class="comment">/*~ 这是个全局修改模块的模板，本文件应该被重命名为 index.d.ts</span></span><br><span class="line"><span class="comment"> *~ 并置于与模块同名的文件夹下，</span></span><br><span class="line"><span class="comment"> *~ 例如，模块名为 &quot;super-greeter&quot;,</span></span><br><span class="line"><span class="comment"> *~ 则本文件路径为 &#x27;super-greeter/index.d.ts&#x27;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*~ 注意，如果你的全局修改模块可以直接调用或者用作构造函数，</span></span><br><span class="line"><span class="comment"> *~ 则应在此结合模块函数或者模块类的模板文件。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">global</span> &#123;</span><br><span class="line">  <span class="comment">/*~ 此处声明的成员将被置于全局global命名空间中，</span></span><br><span class="line"><span class="comment">   *~ 或用于增强该命名空间中已有的成员。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">interface</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="title function_">fancyFormat</span>(<span class="attr">opts</span>: <span class="title class_">StringFormatOptions</span>): <span class="built_in">string</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*~ 如果你的模块需要导出值或者类型，照常写就ok */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">StringFormatOptions</span> &#123;</span><br><span class="line">  <span class="attr">fancinessLevel</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*~ 例如声明一个方法 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params"></span>): <span class="built_in">void</span>;</span><br><span class="line"><span class="comment">/*~ 如果你的模块啥也不导出，则写下面这句话，否则，删掉这句话 */</span></span><br><span class="line"><span class="keyword">export</span> &#123;&#125;;</span><br></pre></td></tr></table></figure><h2 id="五、注意事项"><a href="#五、注意事项" class="headerlink" title="五、注意事项"></a>五、注意事项</h2><ol><li>不要使用<code>String</code>，<code>Number</code>，<code>Boolean</code>，<code>Object</code>，<code>Symbol</code>来作为类型，相应的，应该使用<code>string</code>，<code>number</code>，<code>boolean</code>，<code>object</code>，<code>symbol</code>，但是其它的<strong>诸如<code>Array</code>等，却可以使用</strong>；</li><li>使用泛型时，应确保每个泛型参数都有使用，<strong>不应该存在未使用的泛型参数</strong>；</li><li><strong>不要使用<code>any</code>类型，如果有需要，应使用<code>unknown</code>替代</strong>；</li><li>无返回值的回调函数，其返回值类型不应使用<code>any</code>，而应使用<code>void</code>；</li><li>回调函数避免存在可选参数；</li><li>避免写仅有参数不同的回调函数的重载；</li><li>明确的函数重载应置于泛型函数重载之前；</li><li>避免写仅有尾随参数不同的函数重载，相应地，使用可选参数来替代；</li><li>在只有一个参数是联合类型时，不要使用函数重载，而应使用联合类型；</li></ol><h2 id="六、深入"><a href="#六、深入" class="headerlink" title="六、深入"></a>六、深入</h2><p>本小节介绍编写拥有友好的<code>API</code>的复杂声明文件。</p><h3 id="一-核心概念"><a href="#一-核心概念" class="headerlink" title="(一) 核心概念"></a>(一) 核心概念</h3><p>理解这些核心概念，就能了解如何编写任何形状的声明。</p><h4 id="1-类型-Types"><a href="#1-类型-Types" class="headerlink" title="1. 类型 Types"></a>1. 类型 <code>Types</code></h4><p>在看本文之前，应该已经理解了在 TS 中什么是类型，什么是值。这里就不再赘述。如果还不太了解类型和值，可以参考我之前的文章 <a href="https://juejin.cn/post/7073383136213598222">声明合并</a> 。</p><h4 id="2-值-Values"><a href="#2-值-Values" class="headerlink" title="2. 值 Values"></a>2. 值 <code>Values</code></h4><p>同上。</p><h4 id="3-命名空间-Namepaces"><a href="#3-命名空间-Namepaces" class="headerlink" title="3. 命名空间 Namepaces"></a>3. 命名空间 <code>Namepaces</code></h4><p>值和类型都可以存在于命名空间中。关于命名空间，也可以参考我之前的文章 <a href="https://juejin.cn/post/7074880866341617694">Namepaces</a> 。</p><h3 id="二-简单组合：一个名字，多种含义"><a href="#二-简单组合：一个名字，多种含义" class="headerlink" title="(二) 简单组合：一个名字，多种含义"></a>(二) 简单组合：一个名字，多种含义</h3><p>一个名字<code>A</code>，可以对应最多三种含义：类型、值 和 命名空间。使用该名字的上下文决定了名字当时的解释含义。例如，在<code>let m: A.A = A</code>中，出现的第一个 A 是命名空间，第二个 A 是类型，第三个 A 是值。</p><h4 id="1-内置组合"><a href="#1-内置组合" class="headerlink" title="1. 内置组合"></a>1. 内置组合</h4><p>可以参考我之前的文章 <a href="https://juejin.cn/post/7073383136213598222">声明合并</a> ，有些声明能同时创建值、类型、命名空间中的两者。例如，<code>class A &#123;&#125;</code>声明可以同时创建一个值 A 和一个同名的类型 A。值 A 表示类，可以通过<code>new A()</code>来创建实例。类型 A 表示<code>new A()</code>创建的实例的类型。</p><h4 id="2-自定义组合"><a href="#2-自定义组合" class="headerlink" title="2.自定义组合"></a>2.自定义组合</h4><p>此外，也可以根据需要自定义值、类型、命名空间之间的组合。</p><h3 id="三-高级组合"><a href="#三-高级组合" class="headerlink" title="(三) 高级组合"></a>(三) 高级组合</h3><p>有些种类的声明可以跨声明组合。例如，<code>class A &#123;&#125;</code>和<code>interface A &#123;&#125;</code>可以共存，两者相互对类型 A 进行扩充。值、类型 和 命名空间 的表现有所不同：</p><ul><li>对于值，会和其它同名的值发生冲突，除非是由命名空间创建的值；</li><li>对于类型，如果是有类型别名<code>type A = xxx</code>创建的，则会产生冲突；</li><li>对于命名空间，永远不会有冲突。</li></ul><p>下面通过示例来进行一些演示，也可以参考我之前的文章 <a href="https://juejin.cn/post/7073383136213598222">声明合并</a> 。</p><h4 id="1-通过interface来添加类型的成员"><a href="#1-通过interface来添加类型的成员" class="headerlink" title="1. 通过interface来添加类型的成员"></a>1. 通过<code>interface</code>来添加类型的成员</h4><p>可以使用同名的<code>interface</code>来添加属性。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 同名的interface，用来添加属性y</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="title class_">Foo</span> = ...;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">x</span> + a.<span class="property">y</span>); <span class="comment">// 即具有x属性，又具有y属性</span></span><br></pre></td></tr></table></figure><p><code>class</code>和<code>interface</code>创建的同名类型，也可以相互拓展属性：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用interface来为类型Foo添加属性y</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="title class_">Foo</span> = ...;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">x</span> + a.<span class="property">y</span>); <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><p>注意，不能使用类型别名<code>type Foo = &#123;y: number&#125;</code>来添加属性，而应该使用<code>interface</code>，因为类型别名声明同名类型会引起冲突。</p><h4 id="2-使用namespace来添加成员"><a href="#2-使用namespace来添加成员" class="headerlink" title="2. 使用namespace来添加成员"></a>2. 使用<code>namespace</code>来添加成员</h4><p><code>namespace</code>可以用来添加类型、值或者命名空间的成员；但是命名空间<code>namespace X &#123;&#125;</code>不会创建类型 X，只会创建一个值 X 和一个命名空间 X。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;&#125;</span><br><span class="line"><span class="keyword">namespace</span> C &#123;</span><br><span class="line">  <span class="comment">// 通过namespace给值C添加成员x</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">let</span> <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="comment">// 通过namespace给类型C添加类型成员CC</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> CC &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> y = C.<span class="property">x</span>; <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">yy</span>: C.<span class="property">CC</span>; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>可以看到，命名空间是用来扩充已有的类型、值或者命名空间的强大工具。我们可以写出更多有趣的组合(尽管现实上很难遇见这种需求)：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> X &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> Y &#123;&#125;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Z</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过namespace来扩充</span></span><br><span class="line"><span class="keyword">namespace</span> X &#123;</span><br><span class="line">  <span class="comment">// 添加一个与已有类型同名的值</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">var</span> <span class="attr">Y</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="comment">// 嵌套一个namespace来对之前同名的class做扩充</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">namespace</span> Z &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">C</span> &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> X = <span class="built_in">string</span>; <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">const</span> x1 = <span class="keyword">new</span> X.<span class="title function_">Z</span>(); <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">const</span> x2 = <span class="keyword">new</span> X.<span class="property">Z</span>.<span class="title function_">C</span>(); <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><h2 id="七、发版"><a href="#七、发版" class="headerlink" title="七、发版"></a>七、发版</h2><p>既然跟着我一起写好了自己的声明文件，现在是时候了解一下如何把自己的类型声明包发布到<code>npm</code>上啦。发版类型声明有两个途径：</p><ol><li>与相应的<code>npm</code>包绑定；</li><li>发版到<code>npm</code>上的 <a href="https://www.npmjs.com/~types">@types organization</a> 。</li></ol><p>如果我们的类型声明是基于自己的包的源代码生成的，那么最好是绑定到相应的<code>npm</code>包中进行发布；否则，推荐发版到<code>npm</code>上的<code>@types</code>机构。</p><h3 id="一-绑定到npm包的源代码中发布"><a href="#一-绑定到npm包的源代码中发布" class="headerlink" title="(一) 绑定到npm包的源代码中发布"></a>(一) 绑定到<code>npm</code>包的源代码中发布</h3><h4 id="1-设置types属性"><a href="#1-设置types属性" class="headerlink" title="1. 设置types属性"></a>1. 设置<code>types</code>属性</h4><p>如果我们的包里有<code>main.js</code>文件，则需要在<code>package.json</code>中指示，且设置<code>types</code>属性来指定包里相应的声明文件：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;awesome&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Vandelay Industries&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;main&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./lib/main.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;types&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./lib/main.d.ts&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>其中，<strong><code>types</code>字段名也可以用<code>typings</code>来替代</strong>，两者同义。此外，如果我们的<code>main</code>声明文件的名字为<code>index.d.ts</code>，且位于包的根目录下（在<code>index.js</code>旁边），则也可以不设置<code>types</code>属性，但是建议添加该属性。</p><h4 id="2-依赖"><a href="#2-依赖" class="headerlink" title="2. 依赖"></a>2. 依赖</h4><p>所有声明的依赖应该在<code>package.json</code>的<code>dependencies</code>属性中注明，例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;browserify-typescript-extension&quot;</span>,</span><br><span class="line">  <span class="string">&quot;author&quot;</span>: <span class="string">&quot;Vandelay Industries&quot;</span>,</span><br><span class="line">  <span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;main&quot;</span>: <span class="string">&quot;./lib/main.js&quot;</span>,</span><br><span class="line">  <span class="string">&quot;types&quot;</span>: <span class="string">&quot;./lib/main.d.ts&quot;</span>,</span><br><span class="line">  <span class="string">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;browserify&quot;</span>: <span class="string">&quot;latest&quot;</span>,</span><br><span class="line">    <span class="string">&quot;@types/browserify&quot;</span>: <span class="string">&quot;latest&quot;</span>,</span><br><span class="line">    <span class="string">&quot;typescript&quot;</span>: <span class="string">&quot;next&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看见，<code>browserify-typescript-extension</code>依赖于<code>browserify</code>和<code>typescript</code>这两个包。<code>browserify</code>包的源代码没有和相应的声明文件绑定，因此需要额外依赖于<code>@types/browserify</code>来提供声明；而<code>typescript</code>包的源代码中已有相应的声明文件，因此无需额外<code>@types</code>包。</p><p>注意这里使用的是<code>dependencies</code>字段而不是<code>devDependencies</code>字段，因此<code>browserify-typescript-extension</code>每个用户都需要有<code>dependencies</code>里的包。</p><h4 id="3-红线！！"><a href="#3-红线！！" class="headerlink" title="3. 红线！！"></a>3. 红线！！</h4><p>在声明文件中不要使用<code>/// &lt;reference path=&quot;...&quot; /&gt;</code>，而应使用<code>/// &lt;reference types=&quot;...&quot; /&gt;</code>来替代。</p><p>如果我们的类型声明依赖于其它的包：</p><ul><li>不要将其与我们的文件内容合并，保持各个文件独立；</li><li>不要将其声明复制到我们的包中；</li><li>如果该依赖没有打包其类型声明文件，则我们可以依赖于<code>npm</code>的类型声明包。</li></ul><h4 id="4-指定TypeScript版本：typesVersions字段"><a href="#4-指定TypeScript版本：typesVersions字段" class="headerlink" title="4. 指定TypeScript版本：typesVersions字段"></a>4. 指定<code>TypeScript</code>版本：<code>typesVersions</code>字段</h4><p><code>TypeScript</code>打开一个<code>package.json</code>文件来查看需要读取的内容时，首先注意到的就是<code>typesVersions</code>字段，我们可以通过该字段指定要求的 TS 版本。</p><p>例如，下面的栗子中，如果符合要求，则该包的<code>import</code>导入会解析为<code>/node_modules/package-name/ts3.1/index.d.ts</code>文件，如果当前 TS 版本不合要求，则会回落到<code>types</code>字段指定的文件。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;package-name&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;types&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./index.d.ts&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;typesVersions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;&gt;=3.1&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;*&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;ts3.1/*&quot;</span><span class="punctuation">]</span> <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="5-文件重定向"><a href="#5-文件重定向" class="headerlink" title="5. 文件重定向"></a>5. 文件重定向</h4><p>上面的栗子演示了整个文件夹下的内容的分辨，如果指向指定单个文件时，可以确切地传入该文件名。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;package-name&quot;</span>,</span><br><span class="line">  <span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;types&quot;</span>: <span class="string">&quot;./index.d.ts&quot;</span>,</span><br><span class="line">  <span class="string">&quot;typesVersions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;&lt;4.0&quot;</span>: &#123; <span class="string">&quot;index.d.ts&quot;</span>: [<span class="string">&quot;index.v3.d.ts&quot;</span>] &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 TS 版本低于 4.0 时，<code>import</code>导入会解析为<code>index.v3.d.ts</code>，否则解析为<code>@types</code>属性指定的<code>index.d.ts</code>。</p><h4 id="6-多个字段"><a href="#6-多个字段" class="headerlink" title="6. 多个字段"></a>6. 多个字段</h4><p><code>typeVersions</code>属性可以包含多个字段，来明确不同的 TS 版本，但是要注意顺序，越是明确的版本，书写位置就越是靠前，否则将无法生效。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;package-name&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;types&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./index.d.ts&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;typesVersions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;&gt;=3.2&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;*&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;ts3.2/*&quot;</span><span class="punctuation">]</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;&gt;=3.1&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;*&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;ts3.1/*&quot;</span><span class="punctuation">]</span> <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>例如，以下的书写顺序是无效的：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;package-name&quot;</span>,</span><br><span class="line">  <span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;types&quot;</span>: <span class="string">&quot;./index.d.ts&quot;</span>,</span><br><span class="line">  <span class="string">&quot;typesVersions&quot;</span>: &#123;</span><br><span class="line">    <span class="comment">// 这个书写顺序无效</span></span><br><span class="line">    <span class="string">&quot;&gt;=3.1&quot;</span>: &#123; <span class="string">&quot;*&quot;</span>: [<span class="string">&quot;ts3.1/*&quot;</span>] &#125;,</span><br><span class="line">    <span class="string">&quot;&gt;=3.2&quot;</span>: &#123; <span class="string">&quot;*&quot;</span>: [<span class="string">&quot;ts3.2/*&quot;</span>] &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>npm</code>包中做了如上几项处理后，当<code>npm</code>包发布之后，相应的声明文件也被包含在<code>npm</code>包里了，如此一来，我们编写的声明文件也就发布出去了。</p><h3 id="二-发版到-types"><a href="#二-发版到-types" class="headerlink" title="(二) 发版到 @types"></a>(二) 发版到 <a href="https://www.npmjs.com/~types">@types</a></h3><p>在 <a href="https://github.com/DefinitelyTyped/DefinitelyTyped">DefinitelyTyped</a> 中的包，会通过 <a href="https://github.com/microsoft/DefinitelyTyped-tools/tree/master/packages/publisher">types-publisher tool</a> 工具自动发版到 <a href="https://www.npmjs.com/~types">@types</a> 机构。如果想让自己的类型声明翻版为<code>@types</code>包，则需要给 <a href="https://github.com/DefinitelyTyped/DefinitelyTyped">DefinitelyTyped</a> 提交一份 <code>pull request</code>，在贡献指导页 <a href="https://definitelytyped.org/guides/contributing.html">contribution guidelines page</a> 可以查看更多详情。</p><h2 id="八、使用"><a href="#八、使用" class="headerlink" title="八、使用"></a>八、使用</h2><h3 id="1-下载"><a href="#1-下载" class="headerlink" title="1. 下载"></a>1. 下载</h3><p>获取类型声明只需要<code>npm</code>，以<code>lodash</code>库为例：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev @types/lodash</span><br></pre></td></tr></table></figure><p>当然，如果在发版时已经包含了类型声明，则无需再下载<code>@types</code>包。</p><h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h3><p>安装了<code>@types</code>类型声明包之后，就能使用相应的模块了。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> _ <span class="keyword">from</span> <span class="string">&quot;lodash&quot;</span>;</span><br><span class="line">_.<span class="title function_">padStart</span>(<span class="string">&quot;Hello TypeScript!&quot;</span>, <span class="number">20</span>, <span class="string">&quot; &quot;</span>);</span><br></pre></td></tr></table></figure><p>如果不是使用模块，也可以通过暴露的全局变量来使用。如<code>lodash</code>暴露的全局变量为<code>_</code>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_.<span class="title function_">padStart</span>(<span class="string">&quot;Hello TypeScript!&quot;</span>, <span class="number">20</span>, <span class="string">&quot; &quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="3-查找"><a href="#3-查找" class="headerlink" title="3. 查找"></a>3. 查找</h3><p>通常来说，类型声明包应该与对应的<code>npm</code>上的包具有相同的名字，只不过类型声明包前面要加上<code>@type/</code>前缀。不过如果有需要，也可以在 <a href="https://aka.ms/types">类型查找</a> 来搜索需要的包的类型声明。</p><p>如上，本指南写到这里就结束咯，但愿大家都能有所收获，我们始终在一同进步！如此一来，我的<code>TypeScript</code>进阶篇只剩下 <strong>模块化</strong> 和 <strong>编译原理</strong> 篇了，希望能坚持完成！</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前 端 </tag>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript 系列 进阶篇 (六) Triple-Slash Directives</title>
      <link href="/articals/ac0adb9b/"/>
      <url>/articals/ac0adb9b/</url>
      
        <content type="html"><![CDATA[<p>上一篇介绍<code>namespace</code>多文件拆分的内容时，用到了一个三斜杠指令<code>/// &lt;reference path=&quot;xxx&quot; /&gt;</code>。这组指令有多个，其作用分别有所不同。有些同学还不是很了解这个语法，因而本文专门来介绍相关指令。</p><h2 id="〇、注意事项"><a href="#〇、注意事项" class="headerlink" title="〇、注意事项"></a>〇、注意事项</h2><p>三斜杠指令是<strong>包含一个<code>XML</code>单标签的单行三斜杠注释</strong>，注释的内容可被编译器识别，用来指示编译器在编译的过程中包含其它文件，或者用作规定文件输出顺序的方法。使用三斜杠指令时需要注意：<strong>只有出现在文件的开头才有效，否则将被当作没有特殊意义的普通注释</strong>。这意味着，在三斜杠指令之前，只能有单行或多行注释的存在，当然也可以有其它的三斜杠指令，而不能有其它的语句或者声明。</p><h2 id="一、-lt-reference-path-quot-quot-gt"><a href="#一、-lt-reference-path-quot-quot-gt" class="headerlink" title="一、/// &lt;reference path=&quot;...&quot; /&gt;"></a>一、<code>/// &lt;reference path=&quot;...&quot; /&gt;</code></h2><p>这是最常用的指令了，用来声明文件之间的依赖关系。</p><h3 id="1-预处理输入文件"><a href="#1-预处理输入文件" class="headerlink" title="1. 预处理输入文件"></a>1. 预处理输入文件</h3><p>编译器将所有的三斜杠指令通过预处理传递输入文件的方式来解析，在此过程中，其它的文件会被添加到编译中。这个过程会从一系列根文件，即通过命令行或者<code>tsconfig.json</code>中指定的文件，按照指定的顺序开始开始。在文件被添加到处理列表之前，会<strong>按三斜杠指令在文件中出现的顺序</strong>，遵循<strong>深度优先</strong>的的方式来进行解析。如果三斜杠指令使用了<strong>相对路径，则是相对于包含文件的路径</strong>。</p><h3 id="2-错误使用"><a href="#2-错误使用" class="headerlink" title="2. 错误使用"></a>2. 错误使用</h3><p>以下做法会导致错误：</p><ul><li>使用三斜杠指令来引入不存在的文件 (我们一般不会故意这么做，因此往往是路径不对)；</li><li>使用三斜杠指令来引入自身（自己引用自己，无限循环）。</li></ul><h3 id="3-使用-noResolve-标志"><a href="#3-使用-noResolve-标志" class="headerlink" title="3. 使用 --noResolve 标志"></a>3. 使用 <code>--noResolve</code> 标志</h3><p>如果我们在命令行或者<code>tsconfig.json</code>中启用了<code>noResolve</code>，则三斜杠指令不会被解析，此时它们和普通的注释无异，不会产生任何特殊作用。因此，如果发现三斜杠指令不报错也不生效，可以试着检查<code>tsconfig.json</code>中的相应配置。</p><h2 id="二、-lt-reference-types-quot-quot-gt"><a href="#二、-lt-reference-types-quot-quot-gt" class="headerlink" title="二、/// &lt;reference types=&quot;...&quot; /&gt;"></a>二、<code>/// &lt;reference types=&quot;...&quot; /&gt;</code></h2><p>与<code>/// &lt;reference path=&quot;...&quot; /&gt;</code>指令相似，<code>/// &lt;reference types=&quot;...&quot; /&gt;</code>用来声明对包的依赖。TS 对这些包名的解析也和对使用<code>import</code>语句的解析差不多，因此三斜杠指令也可以视为<strong>声明包</strong>的导入的一种简单方法。例如，当我们在文件开头使用了<code>/// &lt;reference types=&quot;node&quot; /&gt;</code>时，<code>node</code>包和声明文件就会被包含到编译中。该指令往往在手动编写<code>.d.ts</code>文件时才需要使用。而在编译过程中，编译器会自动为我们添加<code>/// &lt;reference types=&quot;...&quot; /&gt;</code>，当且仅当生成文件使用了来自引用包的声明时，才会在该文件中加入<code>/// &lt;reference types=&quot;...&quot; /&gt;</code>。</p><h2 id="三、-lt-reference-lib-quot-quot-gt"><a href="#三、-lt-reference-lib-quot-quot-gt" class="headerlink" title="三、/// &lt;reference lib=&quot;...&quot; /&gt;"></a>三、<code>/// &lt;reference lib=&quot;...&quot; /&gt;</code></h2><p>该指令让文件显示包含现有的内置库，基本上，依然是给声明文件的作者使用的。内置<code>lib</code>文件的引用方式与在<code>tsconfig.json</code>中的<code>lib</code>配置项一致 (例如应该写<code>lib=&quot;es2015&quot;</code>，而不是<code>lib=&quot;lib.es2015.d.ts&quot;</code>)。例如，在某个文件中使用指令<code>/// &lt;reference lib=&quot;es2017.string&quot; /&gt;</code>，等效于在命令行添加<code>--lib es2017.string</code>标志。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference lib=&quot;es2017.string&quot; /&gt;</span></span><br><span class="line"><span class="string">&quot;foo&quot;</span>.<span class="title function_">padStart</span>(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><h2 id="四、-lt-reference-no-default-lib-quot-true-quot-gt"><a href="#四、-lt-reference-no-default-lib-quot-true-quot-gt" class="headerlink" title="四、/// &lt;reference no-default-lib=&quot;true&quot;/&gt;"></a>四、<code>/// &lt;reference no-default-lib=&quot;true&quot;/&gt;</code></h2><p>这个指令会把文件标记为默认库，并高速编译器在编译时不包含默认库。在<code>lib.d.ts</code>文件及其不同的变体的顶部能看到这个指令。</p><h2 id="五、-lt-amd-module-gt"><a href="#五、-lt-amd-module-gt" class="headerlink" title="五、/// &lt;amd-module /&gt;"></a>五、<code>/// &lt;amd-module /&gt;</code></h2><p>这个指令可以把<code>amd</code>模块的名称传递给编译器：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// other.ts</span></span><br><span class="line"><span class="comment">///&lt;amd-module name=&quot;NamedModule&quot;/&gt;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">C</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>在编译中会把模块名称分配给<code>amd</code>的<code>define</code>函数来参与调用：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ModuleA.js</span></span><br><span class="line"><span class="title function_">define</span>(<span class="string">&quot;ModuleA&quot;</span>, [<span class="string">&quot;require&quot;</span>, <span class="string">&quot;exports&quot;</span>], <span class="keyword">function</span> (<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> C = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">  &#125;)();</span><br><span class="line">  <span class="built_in">exports</span>.<span class="property">C</span> = C;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>事实上，处理<code>/// &lt;reference path=&quot;...&quot; /&gt;</code>，其它的三斜杠指令大多数人平时都用不上，学有余力之时，简单了解一下有这些东西的存在吧。下一篇，真的要开始 <strong>声明文件</strong> 了 。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前 端 </tag>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript系列 进阶篇 (五) Namespaces</title>
      <link href="/articals/8b0527c7/"/>
      <url>/articals/8b0527c7/</url>
      
        <content type="html"><![CDATA[<p>在<code>TypeScript 1.5</code>之前的版本，有着内部模块<code>Internal modules</code>(使用<code>module &#123; &#125;</code>的形式来声明) 和外部模块<code>External modules</code>的概念。而从 1.5 版本开始，这两个概念的命名发生了变化。原本的<code>Internal modules</code>更改为<code>Namespaces</code>(命名空间)，声明方式也相应替换为了<code>namespace &#123; &#125;</code>，而<code>External modules</code>则更改为我们现在熟知的模块<code>Modules</code>。使用命名空间，可以自主定义对外可见/不可见的类型或值，能够极大地避免全局命名冲突的问题。我们使用<code>export</code>关键字来对外暴露相应的类型 / 值。</p><h2 id="一、以官方提供的-Validators为例体验Namespaces"><a href="#一、以官方提供的-Validators为例体验Namespaces" class="headerlink" title="一、以官方提供的 Validators为例体验Namespaces"></a>一、以官方提供的 <code>Validators</code>为例体验<code>Namespaces</code></h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">Validation</span> &#123;</span><br><span class="line">  <span class="comment">// 通过export暴露的类型/值，可在namespaace外部访问</span></span><br><span class="line">  <span class="comment">// 暴露一个interface，其包含一个方法签名</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">StringValidator</span> &#123;</span><br><span class="line">    <span class="title function_">isAcceptable</span>(<span class="attr">s</span>: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 没有使用export来导出，只能在namespace内部访问</span></span><br><span class="line">  <span class="keyword">const</span> lettersRegexp = <span class="regexp">/^[A-Za-z]+$/</span>;</span><br><span class="line">  <span class="keyword">const</span> numberRegexp = <span class="regexp">/^[0-9]+$/</span>;</span><br><span class="line">  <span class="comment">// 暴露两个class</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">LettersOnlyValidator</span> <span class="keyword">implements</span> <span class="title class_">StringValidator</span> &#123;</span><br><span class="line">    <span class="title function_">isAcceptable</span>(<span class="params">s: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> lettersRegexp.<span class="title function_">test</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">ZipCodeValidator</span> <span class="keyword">implements</span> <span class="title class_">StringValidator</span> &#123;</span><br><span class="line">    <span class="title function_">isAcceptable</span>(<span class="params">s: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> s.<span class="property">length</span> === <span class="number">5</span> &amp;&amp; numberRegexp.<span class="title function_">test</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">let</span> strings = [<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;98052&quot;</span>, <span class="string">&quot;101&quot;</span>];</span><br><span class="line"><span class="comment">// 字符串索引签名，初始化变量</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">validators</span>: &#123; [<span class="attr">s</span>: <span class="built_in">string</span>]: <span class="title class_">Validation</span>.<span class="property">StringValidator</span> &#125; = &#123;&#125;;</span><br><span class="line"><span class="comment">// 添加两个属性，分别是一个validator实例</span></span><br><span class="line">validators[<span class="string">&quot;ZIP code&quot;</span>] = <span class="keyword">new</span> <span class="title class_">Validation</span>.<span class="title class_">ZipCodeValidator</span>();</span><br><span class="line">validators[<span class="string">&quot;Letters only&quot;</span>] = <span class="keyword">new</span> <span class="title class_">Validation</span>.<span class="title class_">LettersOnlyValidator</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始测试</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> s <span class="keyword">of</span> strings) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> name <span class="keyword">in</span> validators) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">      <span class="string">`&quot;<span class="subst">$&#123;s&#125;</span>&quot; - <span class="subst">$&#123;</span></span></span><br><span class="line"><span class="subst"><span class="string">        validators[name].isAcceptable(s) ? <span class="string">&quot;matches&quot;</span> : <span class="string">&quot;does not match&quot;</span></span></span></span><br><span class="line"><span class="subst"><span class="string">      &#125;</span> <span class="subst">$&#123;name&#125;</span>`</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一开始不理解为什么要使用命名空间，使用一个简简单单的<code>object</code>不好吗？直到读完官方给的示例，发现在<code>namespace</code>里面自由定义类型或值，不导出的内容就成了私有的内容，这种感受可钛上头了。</p><h2 id="二、多文件命名空间"><a href="#二、多文件命名空间" class="headerlink" title="二、多文件命名空间"></a>二、多文件命名空间</h2><p>在之前的文章<a href="https://juejin.cn/post/7073383136213598222">TypeScript 系列 进阶篇：(三) 声明合并</a>中，我介绍过关于<code>namespace</code>声明合并的相关内容，<code>namespace</code>的声明合并使多文件命名空间成为可能。我们知道，随着项目体积的增大，文件数量越来越多，<code>namespace</code>的内容也会越来越大，将所有内容写在一个<code>namespace</code>文件中，显然不太明智，因此，随之产生了命名空间的跨文件问题。TS 支持将同一个<code>namespace</code>拆分到多个文件中，而能够保持犹如在同一个文件中定义时的相同的用法。当然，这需要在文件的开头使用 <strong>三斜杠指令</strong> <code>/// &lt;reference path=&quot;xxx&quot; /&gt;</code>来指定路径，告诉编译器文件之间的依赖关系，注意 <strong>三斜杠指令应位于文件的开头</strong>，关于三斜杠指令的细节，如果有时间我会另出一篇来介绍，本文只关注<code>namespace</code>的内容。下面继续以官方的示例来演示，将上面的<code>validator</code>的栗子拆分到多个文件中。</p><ul><li>首先，<strong>拆分 Base 部分</strong>，在<code>validation.ts</code>中定义基础命名空间<code>Validation</code>：</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// validation.ts</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">Validation</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">StringValidator</span> &#123;</span><br><span class="line">    <span class="title function_">isAcceptable</span>(<span class="attr">X</span>: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>拆分仅限字母的校验器部分</strong>：在<code>lettersOnlyValidator.ts</code>中，在<strong>文件开头</strong>使用三斜杠指令引入<code>validation.ts</code>并随后进行声明合并：</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用三斜杠指令来引入Validation.ts</span></span><br><span class="line"><span class="comment">/// &lt;reference path=&quot;Validation.ts&quot; /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// // 扩充Validation.ts</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">Validation</span> &#123;</span><br><span class="line">  <span class="comment">// 私有成员，仅在当前namaspace中可见，</span></span><br><span class="line">  <span class="comment">// 外部甚至是其它同名的namespace中都不可见</span></span><br><span class="line">  <span class="keyword">const</span> lettersRegexp = <span class="regexp">/^[A-Za-z]+$/</span>;</span><br><span class="line">  <span class="comment">// 导出共享成员</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">LettersOnlyValidator</span> <span class="keyword">implements</span> <span class="title class_">StringValidator</span> &#123;</span><br><span class="line">    <span class="title function_">isAcceptable</span>(<span class="params">s: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> lettersRegexp.<span class="title function_">test</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>继续扩充</strong>：在<code>ZipCodeValidator.ts</code>中，在文件开头通过 <strong>三斜杠指令</strong> 来引入<code>Validation.ts</code>：</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ZipCodeValidator.ts</span></span><br><span class="line"><span class="comment">/// &lt;reference path=&quot;Validation.ts&quot; /&gt;</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">Validation</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> numberRegexp = <span class="regexp">/^[0-9]+$/</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">ZipCodeValidator</span> <span class="keyword">implements</span> <span class="title class_">StringValidator</span> &#123;</span><br><span class="line">    <span class="title function_">isAcceptable</span>(<span class="params">s: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> s.<span class="property">length</span> === <span class="number">5</span> &amp;&amp; numberRegexp.<span class="title function_">test</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们的命名空间<code>Validation</code>已经合并好了，但是需要注意，当我们在其它文件中使用相应的导出成员时，依然要使用 <strong>三斜杠指令</strong> 来引入相关的<code>namespace</code>文件，如在测试文件<code>test.ts</code>中：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.ts</span></span><br><span class="line"><span class="comment">// 使用三斜杠指令来引入相关的namespace文件</span></span><br><span class="line"><span class="comment">/// &lt;reference path=&quot;Validation.ts&quot; /&gt;</span></span><br><span class="line"><span class="comment">/// &lt;reference path=&quot;LettersOnlyValidator.ts&quot; /&gt;</span></span><br><span class="line"><span class="comment">/// &lt;reference path=&quot;ZipCodeValidator.ts&quot; /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下用法和在最开始没有拆分使相同</span></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">let</span> strings = [<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;98052&quot;</span>, <span class="string">&quot;101&quot;</span>];</span><br><span class="line"><span class="comment">// 变量声明，索引签名</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">validators</span>: &#123; [<span class="attr">s</span>: <span class="built_in">string</span>]: <span class="title class_">Validation</span>.<span class="property">StringValidator</span> &#125; = &#123;&#125;;</span><br><span class="line"><span class="comment">// 添加validator实例</span></span><br><span class="line">validators[<span class="string">&quot;ZIP code&quot;</span>] = <span class="keyword">new</span> <span class="title class_">Validation</span>.<span class="title class_">ZipCodeValidator</span>();</span><br><span class="line">validators[<span class="string">&quot;Letters only&quot;</span>] = <span class="keyword">new</span> <span class="title class_">Validation</span>.<span class="title class_">LettersOnlyValidator</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始测试</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> s <span class="keyword">of</span> strings) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> name <span class="keyword">in</span> validators) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">      <span class="string">`&quot;<span class="subst">$&#123;s&#125;</span>&quot; - <span class="subst">$&#123;</span></span></span><br><span class="line"><span class="subst"><span class="string">        validators[name].isAcceptable(s) ? <span class="string">&quot;matches&quot;</span> : <span class="string">&quot;does not match&quot;</span></span></span></span><br><span class="line"><span class="subst"><span class="string">      &#125;</span> <span class="subst">$&#123;name&#125;</span>`</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，我们把一个混乱的<code>namespace</code>按功能点拆分到不同的文件中，但是除了需要使用三斜杠指令来引入之外，依然保持使用方法不变，后期维护的话就方便多啦！</p><p>当然，现在涉及到了多个文件，因此，我们需要确保所有被编译的代码都被加载。这里主要有两种方式：</p><ul><li><p>单文件输出：</p><p>通过配置<code>outputFile</code>项来使指定的文件（包含其依赖文件）被编译输出为单个<code>js</code>文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx tsc --outFile sample.js test.ts</span><br></pre></td></tr></table></figure><p>如上，该命令会将<code>test.ts</code>文件以及其通过三斜杠指令引入的三个文件，按引入顺序来编译输出在一个<code>sample.js</code>文件中，如此一来当<code>test.ts</code>加载时，便可确保所有被编译的代码都被加载。我们也可以手动列举相应要编译输出的文件，但是显然会更麻烦：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx tsc --outFile sample.<span class="property">js</span> <span class="title class_">Validation</span>.<span class="property">ts</span> <span class="title class_">LettersOnlyValidator</span>.<span class="property">ts</span> <span class="title class_">ZipCodeValidator</span>.<span class="property">ts</span> <span class="title class_">Test</span>.<span class="property">ts</span></span><br></pre></td></tr></table></figure><p>事实上，在现代羡慕中，我们多半使用<code>vue</code>或<code>react</code>等框架，在这些项目的配置文件中，往往都已经帮我们配置好了输出为单个<code>js</code>文件。</p></li><li><p>多文件输出：</p><p>多文件输出为默认选项。使每个被编译的文件都单独输出一个相应的<code>js</code>文件。这时，我们就需要在相应的<code>html</code>文件中，<strong>按照顺序</strong>使用<code>&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;</code>来引入相应的<code>js</code>文件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;Validation.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;LettersOnlyValidator.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;ZipCodeValidator.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;Test.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="三、别名"><a href="#三、别名" class="headerlink" title="三、别名"></a>三、别名</h2><p>可能你也注意到，我们在外部访问命名空间内暴露的成员时，需要带上命名空间本身的名字，尽管现代编辑器很只能，但我们仍然希望有更简单的写法。好在，TS 给我们提供了一种语法，<code>import newName = X.y.z</code>来为命名空间暴露的成员起一个别名。<strong>注意，这不要和模块的导入语法<code>import q = require(X)</code>相混淆，这俩不是同一个东西。命名空间的<code>import newName = X.y.x</code>只是单纯地给命名空间的成员起一个别名而已</strong>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 官方示例的第一个嵌套namespace</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">Shapes</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> age = <span class="number">18</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">getAge</span> = (<span class="params"></span>) =&gt; age;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">namespace</span> <span class="title class_">Polygons</span> &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Triangle</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Square</span> &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以给一般成员起别名</span></span><br><span class="line"><span class="keyword">import</span> age = <span class="title class_">Shapes</span>.<span class="property">getAge</span>;</span><br><span class="line"><span class="comment">// 也可以给嵌套的namespace起别名</span></span><br><span class="line"><span class="keyword">import</span> polygons = <span class="title class_">Shapes</span>.<span class="property">Polygons</span>;</span><br><span class="line"><span class="keyword">let</span> sq = <span class="keyword">new</span> polygons.<span class="title class_">Square</span>(); <span class="comment">// 和 &#x27;new Shapes.Polygons.Square()&#x27; 一样</span></span><br></pre></td></tr></table></figure><h2 id="四、环境命名空间-Ambient-Namespaces"><a href="#四、环境命名空间-Ambient-Namespaces" class="headerlink" title="四、环境命名空间 Ambient Namespaces"></a>四、环境命名空间 <code>Ambient Namespaces</code></h2><p>这部分内容先挖个坑，因为涉及到 <strong>环境</strong> <strong><code>ambient</code></strong>，我们通常吧那些没有定义实现的声明，叫做 <strong><code>ambient</code></strong>，这些声明往往出现在 <code>.d.ts</code>拓展名的文件中 (决定了，下一期就讲这个)。我们知道，有些库并不是用<code>TS</code>写的，而是用的<code>JS</code>，因此，我们需要声明这些库暴露的<code>API</code>。而大多数<code>JS</code>库所暴露的都是一个顶级的<code>object</code>，所以很适合使用<code>namespace</code>来表示。下面以 <code>D3</code>这个库为例演示在环境命名空间中定义第三方库的形状：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意 &#x27;环境&#x27; 的声明都需要添加declare关键字</span></span><br><span class="line"><span class="comment">// 声明没有定义实现的接口</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> D3 &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">Selectors</span> &#123;</span><br><span class="line">    <span class="attr">select</span>: &#123;</span><br><span class="line">      (<span class="attr">selector</span>: <span class="built_in">string</span>): <span class="title class_">Selection</span>;</span><br><span class="line">      (<span class="attr">element</span>: <span class="title class_">EventTarget</span>): <span class="title class_">Selection</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">Event</span> &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">Base</span> <span class="keyword">extends</span> <span class="title class_">Selectors</span> &#123;</span><br><span class="line">    <span class="attr">event</span>: <span class="title class_">Event</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 声明没有分配的值</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">var</span> <span class="attr">d3</span>: <span class="variable constant_">D3</span>.<span class="property">Base</span>;</span><br></pre></td></tr></table></figure><p>环境命名空间看得云里雾里？没关系，下一篇，风里雨里，<strong>声明文件</strong> 里等你！</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前 端 </tag>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript 系列 进阶篇 (四) JSX</title>
      <link href="/articals/baaa9f72/"/>
      <url>/articals/baaa9f72/</url>
      
        <content type="html"><![CDATA[<p><code>JSX</code> ，作为一种可嵌入的类 <code>XML</code>语法，玩过<code>react</code>的同学想必不会陌生。<code>TypeScript</code>支持嵌入和类型检查，并且可以直接将<code>JSX</code>编译为<code>JavaScript</code>。本文就<code>TypeScript</code>中的 <code>JSX</code>，即<code>TSX</code>的用法进行简要介绍。主要资料来源于官方文档，加入了少许自己的理解。</p><h2 id="一、基础用法"><a href="#一、基础用法" class="headerlink" title="一、基础用法"></a>一、基础用法</h2><p>在 TS 中使用<code>JSX</code>之前，需要做两个准备：</p><ul><li>将相关文件的拓展名更改为 <code>.tsx</code>；</li><li>启用<code>jsx</code>选项。</li></ul><p>TS 附带了三种 <code>jsx</code>模式：</p><ul><li><code>preserve</code>：将<code>JSX</code>保留为输出的一部分，且输出文件的拓展名为<code>.jsx</code>；</li><li><code>react</code>：由<code>React.createElement</code>来处理，使用前不需要经过<code>JSX</code>转换，输出文件的拓展名为<code>.js</code>；</li><li><code>react-native</code>：将<code>JSX</code>保留为输出的一部分，输出文件的拓展名为<code>.js</code>。</li></ul><p>此外，一般还有 <code>react-jsx</code>、<code>react-jsxdev</code>等模式，此处不作介绍。我们可以在命令行或配置文件里来启用选择模式，例如，在<code>tsconfig.json</code>里做如下配置：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;target&quot;</span>: <span class="string">&quot;esnext&quot;</span>,</span><br><span class="line">    <span class="string">&quot;module&quot;</span>: <span class="string">&quot;esnext&quot;</span>,</span><br><span class="line">    <span class="string">&quot;strict&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;jsx&quot;</span>: <span class="string">&quot;react&quot;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、使用-as-操作符-与-类型检查"><a href="#二、使用-as-操作符-与-类型检查" class="headerlink" title="二、使用 as 操作符 与 类型检查"></a>二、使用 <mark>as</mark> 操作符 与 类型检查</h2><p>在前面的文章，我们介绍过类型断言的两种写法，一种是尖括号，另一种是使用 <code>as</code> 操作符。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尖括号</span></span><br><span class="line"><span class="keyword">const</span> cc = &lt;<span class="title class_">Person</span>&gt;people1;</span><br><span class="line"><span class="comment">// 使用 as</span></span><br><span class="line"><span class="keyword">const</span> yy = people2 <span class="keyword">as</span> <span class="title class_">Person</span>;</span><br></pre></td></tr></table></figure><p>由于尖括号的写法类似<code>xml</code>标签，在<code>JSX</code>中可能引起混淆，因此，TS 不允许在<code>JSX</code>中使用尖括号的写法，我们在进行类型断言时应使用<code>as</code>操作符。</p><p>此外，我们需要区分一个元素标签，到底是一个内置的元素标签，如<code>&lt;div&gt;</code>、<code>&lt;span&gt;</code>等，还是一个基于值的标签(自定义的标签组件)。一般来说，内置标签的首字母应该小写，而基于值得标签首字母应该大写。而内置元素与基于值的元素也很有区别：</p><ul><li>内置元素会作为字符串，由<code>React.createElement(&quot;div&quot;)</code>来处理，而基于值的元素不是；</li><li>内置元素的属性是已知的，而基于值的属性是我们自定义的。</li></ul><h2 id="三、内置元素-与-基于值的元素"><a href="#三、内置元素-与-基于值的元素" class="headerlink" title="三、内置元素 与 基于值的元素"></a>三、内置元素 与 基于值的元素</h2><h3 id="1-内置元素"><a href="#1-内置元素" class="headerlink" title="1. 内置元素"></a>1. 内置元素</h3><p>内置元素会在特殊接口 <code>JSX.IntrinsicElements</code>上查找。默认情况下，如果没有指定这个接口，则不会对内置元素进行类型检查。<strong>但如果这个接口存在，则内置元素会作为该接口上的属性进行类型检查。</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> JSX &#123;</span><br><span class="line">  <span class="keyword">interface</span> <span class="title class_">IntrinsicElements</span> &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="built_in">any</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;foo /&gt;; <span class="comment">// ok</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">bar</span> /&gt;</span></span>; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><p>当然，也可以用索引签名，使所有的字符串都能通过类型检查：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> JSX &#123;</span><br><span class="line">  <span class="keyword">interface</span> <span class="title class_">IntrinsicElements</span> &#123;</span><br><span class="line">    [<span class="attr">x</span>: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;foo /&gt;; <span class="comment">// ok</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">bar</span> /&gt;</span></span>; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><h3 id="2-基于值的元素"><a href="#2-基于值的元素" class="headerlink" title="2. 基于值的元素"></a>2. 基于值的元素</h3><p>基于值的元素，只需根据作用域内的标识符进行查找。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">MyComponent</span> <span class="keyword">from</span> <span class="string">&quot;./myComponent&quot;</span>;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span></span>; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>基于值的元素有两种方式来定义：<strong>函数组件</strong> <code>Function Component(FC)</code> 和 <strong>类组件</strong> <code>Class Component</code>。</p><ul><li><p><strong>函数组件</strong></p><p>组件如其名，是由<code>JS</code>函数来定义的，函数的第一个参数为接收的属性对象 <code>props</code>。TS 强制函数的返回值必须满足<code>JSX.Element</code>的约束。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义props的形状</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">FooProp</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">X</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">Y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">AnotherComponent</span>(<span class="params">prop: &#123; name: <span class="built_in">string</span> &#125;</span>);</span><br><span class="line"><span class="comment">// 函数组件可以是普通的函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ComponentFoo</span>(<span class="params">prop: FooProp</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">AnotherComponent</span> <span class="attr">name</span>=<span class="string">&#123;prop.name&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 也可以是箭头函数表达式</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Button</span> = (<span class="params">prop: &#123; value: <span class="built_in">string</span> &#125;, context: &#123; color: <span class="built_in">string</span> &#125;</span>) =&gt; (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> /&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>可以看到，函数组件就是一个<code>JS</code>函数，因此，<strong>函数重载</strong>也完全适用。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ClickableProps</span> &#123;</span><br><span class="line">  <span class="attr">children</span>: <span class="variable constant_">JSX</span>.<span class="property">Element</span>[] | <span class="variable constant_">JSX</span>.<span class="property">Element</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">HomeProps</span> <span class="keyword">extends</span> <span class="title class_">ClickableProps</span> &#123;</span><br><span class="line">  <span class="attr">home</span>: <span class="variable constant_">JSX</span>.<span class="property">Element</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">SideProps</span> <span class="keyword">extends</span> <span class="title class_">ClickableProps</span> &#123;</span><br><span class="line">  <span class="attr">side</span>: <span class="variable constant_">JSX</span>.<span class="property">Element</span> | <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MainButton</span>(<span class="params">prop: HomeProps</span>): <span class="variable constant_">JSX</span>.<span class="property">Element</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MainButton</span>(<span class="params">prop: SideProps</span>): <span class="variable constant_">JSX</span>.<span class="property">Element</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MainButton</span>(<span class="params">prop: ClickableProps</span>): <span class="variable constant_">JSX</span>.<span class="property">Element</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以前，函数组件被认为是 无状态组件，即<code>Stateless Function Components (SFC)</code>。但是在 react 最近的版本中，使用 hooks 可以使函数组件具有像类组件一样的状态。因此，<strong>类型<code>SFC</code>及其别名<code>StatelessComponent</code>被弃用了</strong>。</p></li><li><p><strong>类组件</strong></p><p>类组件的类型可以定义，不过在此之前，或许我们得先了解两个术语：元素类 类型，和元素实例 类型。</p><ul><li><p>元素类 类型</p><p>以<code>&lt;Expr&gt;</code>为例，元素类的类型为 <code>Expr</code>，如果该组件是使用<code>ES6</code>的<code>class</code>定义出来的，则类的类型为其构造函数和静态成员；如果该组件是由工厂函数定义出来的，则类的类型为该函数。</p></li><li><p>元素实例 类型</p><p>一旦类的类型确立好之后，元素实例类型便由类类型的<strong>构造签名</strong>或<strong>调用签名</strong>的返回值的联合类型来决定。同样的，在<code>ES6</code>的<code>class</code>的情况下，元素实例类型就是<code>class</code>的实例的类型；如果是工厂函数的情况下，则元素实例的类型是函数返回值的类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对于class，使用构造签名</span></span><br><span class="line"><span class="keyword">const</span> myComponent = <span class="keyword">new</span> <span class="title class_">MyComponent</span>();</span><br><span class="line"><span class="comment">// 则元素类类型为 MyComponent</span></span><br><span class="line"><span class="comment">// 元素实例类型为 &#123; render: () =&gt; void &#125;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyFactoryFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">render</span>: <span class="function">() =&gt;</span> &#123;&#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于工厂函数，使用调用签名</span></span><br><span class="line"><span class="keyword">const</span> myComponent = <span class="title class_">MyFactoryFunction</span>();</span><br><span class="line"><span class="comment">// 元素类类型为 MyFactoryFunction</span></span><br><span class="line"><span class="comment">// 元素实例类型为 &#123; render: () =&gt; void &#125;</span></span><br></pre></td></tr></table></figure><p>元素实例类型 必须符合<code>JSX.ElementClass</code>的约束，否则会报错。默认情况下 <code>JSX.ElementClass</code>为 <code>&#123;&#125;</code>，但是可以自由扩充其属性/方法来限制相应组件的类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> JSX &#123;</span><br><span class="line">  <span class="keyword">interface</span> <span class="title class_">ElementClass</span> &#123;</span><br><span class="line">    <span class="comment">// 扩充一个 render 字段</span></span><br><span class="line">    <span class="attr">render</span>: <span class="built_in">any</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyFactoryFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">render</span>: <span class="function">() =&gt;</span> &#123;&#125; &#125;;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="title class_">MyComponent</span> /&gt;; <span class="comment">// ok</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">MyFactoryFunction</span> /&gt;</span></span>; <span class="comment">// ok</span></span><br><span class="line"><span class="comment">// 以下两个，不符合JSX.ElementClass的约束，用作类组件会报错</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NotAValidComponent</span> &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">NotAValidFactoryFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="title class_">NotAValidComponent</span> /&gt;; <span class="comment">// 报错</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">NotAValidFactoryFunction</span> /&gt;</span></span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="四、属性类型检查"><a href="#四、属性类型检查" class="headerlink" title="四、属性类型检查"></a>四、属性类型检查</h2><p>想要进行属性类型检查，首先得定义属性类型。这在内置元素和基于值的元素之间稍许不同。</p><p>内置元素是<code>JSX.IntrinsicElements</code>上的属性，该属性对应的类型，就是相应内置元素的属性类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> JSX &#123;</span><br><span class="line">  <span class="keyword">interface</span> <span class="title class_">IntrinsicElements</span> &#123;</span><br><span class="line">    <span class="attr">foo</span>: &#123; bar?: <span class="built_in">boolean</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 元素foo的属性类型为 &#x27;&#123;bar?: boolean&#125;&#x27;</span></span><br><span class="line">&lt;foo bar /&gt;;</span><br></pre></td></tr></table></figure><p>基于值的元素，其属性类型取决于 先前定义好的 元素实例类型上的 某个属性 的类型。至于是使用哪个属性，则由<code>JSX.ElementAttributesProperty</code>来决定。声明<code>JSX.ElementAttributesProperty</code>的时候只能有单个属性，即用来作为属性类型检查的那个元素实例属性。在 TS 2.8 中，如果没有提供<code>JSX.ElementAttributesProperty</code>，则类元素的构造签名或者函数组件的调用签名的第一个参数会被用作替代。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> JSX &#123;</span><br><span class="line">  <span class="keyword">interface</span> <span class="title class_">ElementAttributesProperty</span> &#123;</span><br><span class="line">    props; <span class="comment">// 明确使用哪个属性名用于属性类型检查</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> &#123;</span><br><span class="line">  <span class="comment">// 明确元素实例类型上有这个属性</span></span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    foo?: <span class="built_in">string</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 元素属性类型是 &#x27;&#123;foo?: string&#125;&#x27;</span></span><br><span class="line">&lt;<span class="title class_">MyComponent</span> foo=<span class="string">&quot;bar&quot;</span> /&gt;;</span><br></pre></td></tr></table></figure><p>元素属性类型用于<code>JSX</code>中的属性检查，支持可选和必需属性。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> JSX &#123;</span><br><span class="line">  <span class="keyword">interface</span> <span class="title class_">IntrinsicElements</span> &#123;</span><br><span class="line">    <span class="comment">// 一个必需属性 requireProp 和 一个可选属性 optionalProp</span></span><br><span class="line">    <span class="attr">foo</span>: &#123; <span class="attr">requiredProp</span>: <span class="built_in">string</span>; optionalProp?: <span class="built_in">number</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;foo requiredProp=<span class="string">&quot;bar&quot;</span> /&gt;; <span class="comment">// ok</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">foo</span> <span class="attr">requiredProp</span>=<span class="string">&quot;bar&quot;</span> <span class="attr">optionalProp</span>=<span class="string">&#123;0&#125;</span> /&gt;</span></span>; <span class="comment">// ok</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">foo</span> /&gt;</span></span>; <span class="comment">// 错误，缺少必需属性 requireProp</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">foo</span> <span class="attr">requiredProp</span>=<span class="string">&#123;0&#125;</span> /&gt;</span></span>; <span class="comment">// 错误，必需属性requireProp应该是一个字符串</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">foo</span> <span class="attr">requiredProp</span>=<span class="string">&quot;bar&quot;</span> <span class="attr">unknownProp</span> /&gt;</span></span>; <span class="comment">// 错误，不存在属性 unknownProp</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">foo</span> <span class="attr">requiredProp</span>=<span class="string">&quot;bar&quot;</span> <span class="attr">some-unknown-prop</span> /&gt;</span></span>; <span class="comment">// ok，因为some-unknown-prop不是有效的标识符</span></span><br></pre></td></tr></table></figure><p>此外，<code>JSX.IntrinsicAttributes</code>可用来定义一些提供给<code>JSX</code>框架使用的额外属性，如 <code>React</code>中的<code>key</code>。进一步说，泛型类型<code>JSX.IntrinsicClassAttributes&lt;T&gt;</code>可用于为类组件指定相同类型的额外属性。在这种类型中，泛型参数对应于实例类型。一般而言，所有的额外属性应该都是可选的。</p><h2 id="五、子元素类型检查"><a href="#五、子元素类型检查" class="headerlink" title="五、子元素类型检查"></a>五、子元素类型检查</h2><p>在<code>TS 2.3</code>版本中，引入了子元素的类型检查。子元素是元素属性类型中的一个特殊属性，<code>TS</code>使用<code>JSX.ElementChildrenAttribute</code>来决定子元素使用哪个属性名，同样的，<code>JSX.ElementChildrenAttribute</code>的声明也应该只具有单个属性。我们同样可以像其它属性一样，明确子元素的类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">PropsType</span> &#123;</span><br><span class="line">  <span class="comment">// 子元素为 JSX.Element 类型</span></span><br><span class="line">  <span class="attr">children</span>: <span class="variable constant_">JSX</span>.<span class="property">Element</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Component</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&lt;<span class="title class_">PropsType</span>, &#123;&#125;&gt; &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        // 子元素插槽</span></span><br><span class="line"><span class="language-xml">        &#123;this.props.children&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// OK, h1标签即为children</span></span><br><span class="line">&lt;<span class="title class_">Component</span> name=<span class="string">&quot;foo&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Component</span>&gt;</span><br><span class="line"><span class="comment">// 错误，h1和h2标签，相当于一个 JSX.Element的数组，即Array&lt;JSX.Element&gt;，而children是JSX.Element类型</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Component</span> <span class="attr">name</span>=<span class="string">&quot;bar&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">Component</span>&gt;</span></span></span><br><span class="line"><span class="comment">// 错误: h1标签和字符串World，相当于Array&lt;JSX.Element | string&gt;，不符合children的JSX.Element类型</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Component</span> <span class="attr">name</span>=<span class="string">&quot;baz&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  World</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">Component</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="六、JSX-的结果类型-与-嵌入表达式"><a href="#六、JSX-的结果类型-与-嵌入表达式" class="headerlink" title="六、JSX 的结果类型 与 嵌入表达式"></a>六、<mark>JSX</mark> 的结果类型 与 嵌入表达式</h2><p><code>JSX</code>表达式的结果类型默认为<code>any</code>，我们可以通过<code>JSX.Element</code>接口来自定义结果类型，但是无法通过这个接口来检索有关元素、属性和子元素的类型信息，因为这是个黑盒子。</p><p>在<code>JSX</code>中，我们可以使用花括号<code>&#123;&#125;</code>来在标签之间嵌入表达式。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    // 可以嵌入表达式，但是这个表达式本身有误</span></span><br><span class="line"><span class="language-xml">    &#123;[&quot;foo&quot;, &quot;bar&quot;].map((i) =&gt; (</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;i / 2&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    ))&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这个栗子会导致错误，因为<code>i</code>的取值为<code>&quot;foo&quot;</code>或者<code>&quot;bar&quot;</code>，是字符串，不能用来除以一个数字 <code>2</code>。如果要在<code>React</code>中使用<code>JSX</code>，则需要使用 <code>React</code>中的类型，这些类型定义了一些适用于<code>React</code>的<code>JSX</code>命名空间，有关内容不在此处介绍。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前 端 </tag>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript 系列  进阶篇  (三)  枚举</title>
      <link href="/articals/f79f4b48/"/>
      <url>/articals/f79f4b48/</url>
      
        <content type="html"><![CDATA[<p>枚举通过关键字 <code>enum</code> 来声明，会同时得到一个类型和一个同名的值，该值为一组命名了的常量。<code>TS</code>提供了基于数字和基于字符串的枚举，当然，这本该是基础篇的内容…</p><h2 id="一、数字枚举"><a href="#一、数字枚举" class="headerlink" title="一、数字枚举"></a>一、数字枚举</h2><p>我们使用关键字 <code>enum</code> 来声明一个枚举。当我们不给初值时，就会自动初始化，值依次从 <code>0</code> 开始递增。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">  <span class="title class_">Up</span>,</span><br><span class="line">  <span class="title class_">Down</span>,</span><br><span class="line">  <span class="title class_">Left</span>,</span><br><span class="line">  <span class="title class_">Right</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Direction.Up = 0</span></span><br><span class="line"><span class="comment">Direction.Down = 1</span></span><br><span class="line"><span class="comment">Direction.Left = 2</span></span><br><span class="line"><span class="comment">Direction.Right = 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>如果我们初始化了某属性的数值，紧随其后的其它属性的数值则会根据 步长为<code>1</code> 的递增/递减 自动推算。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">  <span class="title class_">Up</span> = <span class="number">1</span>,</span><br><span class="line">  <span class="title class_">Down</span>,</span><br><span class="line">  <span class="title class_">Left</span>,</span><br><span class="line">  <span class="title class_">Right</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Direction.Up = 1</span></span><br><span class="line"><span class="comment">Direction.Down = 2</span></span><br><span class="line"><span class="comment">Direction.Left = 3</span></span><br><span class="line"><span class="comment">Direction.Right = 4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>枚举的使用也很简单。我们知道，声明枚举既得到值，也得到一个同名的类型。我们只需要通过属性来访问枚举内部的值，也能通过枚举的名字来作为类型使用。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">UserResponse</span> &#123;</span><br><span class="line">  <span class="title class_">No</span> = <span class="number">0</span>,</span><br><span class="line">  <span class="title class_">Yes</span> = <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">respond</span>(<span class="params"></span></span><br><span class="line"><span class="params">  recipient: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">  <span class="comment">/*作为类型使用*/</span> message: UserResponse</span></span><br><span class="line"><span class="params"></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为值使用</span></span><br><span class="line"><span class="title function_">respond</span>(<span class="string">&quot;Princess Caroline&quot;</span>, <span class="title class_">UserResponse</span>.<span class="property">Yes</span>);</span><br></pre></td></tr></table></figure><p>此外，枚举成员也能混用计算属性和数字 (当然，还有字符串)，但需要注意：</p><ul><li>枚举的第一个成员，如果没有初始化值，则被自动赋予数值 <strong><code>0</code></strong> ；</li><li>枚举的其它成员，如果紧随一个数值成员之后，则他们的值会依次递增 <strong><code>1</code></strong> ；</li><li>枚举的其它成员，如果不是紧随数值成员之后，则需要初始化其值(数值、字符串或计算属性)；</li></ul><h2 id="二、字符串枚举"><a href="#二、字符串枚举" class="headerlink" title="二、字符串枚举"></a>二、字符串枚举</h2><p>字符串枚举的成员，必须用 string 类型的字面量，或者其它枚举的成员来进行值的初始化。字符串枚举没有自增行为，因此，在我们为其初始化一个有意义的 string 类型的字面量之后，在调试中将会比数子枚举更加友好。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">  <span class="title class_">Up</span> = <span class="string">&quot;UP&quot;</span>,</span><br><span class="line">  <span class="title class_">Down</span> = <span class="string">&quot;DOWN&quot;</span>,</span><br><span class="line">  <span class="title class_">Left</span> = <span class="string">&quot;LEFT&quot;</span>,</span><br><span class="line">  <span class="comment">// 报错，Right必须有一个初始化的值</span></span><br><span class="line">  <span class="title class_">Right</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、异构枚举"><a href="#三、异构枚举" class="headerlink" title="三、异构枚举"></a>三、异构枚举</h2><p>将数字和字符串混合使用，即为异构枚举。但是，与这个听起来好像很高端的名字不一样，使用异构枚举往往没有声明对我们写代码没有什么帮助，建议避免这种写法。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">BooleanLikeHeterogeneousEnum</span> &#123;</span><br><span class="line">  <span class="title class_">No</span> = <span class="number">0</span>,</span><br><span class="line">  <span class="title class_">Yes</span> = <span class="string">&quot;YES&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、计算属性成员和常量成员"><a href="#四、计算属性成员和常量成员" class="headerlink" title="四、计算属性成员和常量成员"></a>四、计算属性成员和常量成员</h2><p>我们使用常量枚举表达式来初始化枚举的成员。符合以下条件的都是常量枚举表达式：</p><ol><li>字面量枚举表达式；</li><li>对已经定义好的枚举成员的引用(可以是自身的成员，也可以是其它枚举的成员)；</li><li>带括号的常量枚举表达式；</li><li>使用 + 、- 、~ 等一元运算符来操作的常量表达式；</li><li><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&gt;&gt;&gt;</code>, <code>&amp;</code>, <code>|</code>, <code>^</code> 等二元运算符来操作的常量表达式</li></ol><p>如果常量枚举表达式发生运行时错误，则其值会变为<code>NaN</code>或者 <code>Infinity</code> 。其它的所有情况下，枚举成员都被认为是计算属性成员。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">FileAccess</span> &#123;</span><br><span class="line">  <span class="comment">// 常量成员</span></span><br><span class="line">  <span class="title class_">None</span>,</span><br><span class="line">  <span class="title class_">Read</span> = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line">  <span class="title class_">Write</span> = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</span><br><span class="line">  <span class="title class_">ReadWrite</span> = <span class="title class_">Read</span> | <span class="title class_">Write</span>,</span><br><span class="line">  <span class="comment">// 计算属性成员</span></span><br><span class="line">  G = <span class="string">&quot;123&quot;</span>.<span class="property">length</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、联合枚举-和-枚举成员的类型"><a href="#五、联合枚举-和-枚举成员的类型" class="headerlink" title="五、联合枚举 和 枚举成员的类型"></a>五、<mark>联合枚举</mark> 和 枚举成员的类型</h2><p><strong>字面量枚举成员</strong>：</p><ul><li>任何的字符串字面量，如<code>&quot;cc&quot;</code>，<code>&quot;age</code>“等；</li><li>任何的数值字面量，如 <code>1</code> ，<code>99</code> 等；</li><li>任何一元运算符操作的数值字面量，如 <code>-100</code> 等。</li></ul><p>当一个枚举的所有成员都是字面量枚举成员时，<strong>则<mark>枚举成员</mark>也会成为一个类型</strong>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">ShapeKind</span> &#123;</span><br><span class="line">  <span class="title class_">Circle</span>,</span><br><span class="line">  <span class="title class_">Square</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">  <span class="comment">// 枚举成员ShapeKind.Circle也用作类型</span></span><br><span class="line">  <span class="attr">kind</span>: <span class="title class_">ShapeKind</span>.<span class="property">Circle</span>;</span><br><span class="line">  <span class="attr">radius</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Square</span> &#123;</span><br><span class="line">  <span class="comment">// 枚举成员ShapeKind.Square也用作类型</span></span><br><span class="line">  <span class="attr">kind</span>: <span class="title class_">ShapeKind</span>.<span class="property">Square</span>;</span><br><span class="line">  <span class="attr">sideLength</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>: <span class="title class_">Circle</span> = &#123;</span><br><span class="line">  <span class="comment">// 错误，Circle类型中，kind字段只能是ShapeKind.Circle类型</span></span><br><span class="line">  <span class="attr">kind</span>: <span class="title class_">ShapeKind</span>.<span class="property">Square</span>,</span><br><span class="line">  <span class="attr">radius</span>: <span class="number">100</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当一个枚举的所有成员都是字面量枚举成员时，<strong>则该枚举本身作为类型，等价于所有枚举成员的联合</strong>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> E &#123;</span><br><span class="line">  <span class="title class_">Foo</span>,</span><br><span class="line">  <span class="title class_">Bar</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x: E</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (x !== E.<span class="property">Foo</span> || x !== E.<span class="property">Bar</span>) &#123;</span><br><span class="line">    <span class="comment">// 这个条件永远是true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、运行时-与-编译时-的-枚举"><a href="#六、运行时-与-编译时-的-枚举" class="headerlink" title="六、运行时 与 编译时 的 枚举"></a>六、运行时 与 编译时 的 枚举</h2><h3 id="1-运行时的枚举是一个真实的对象。"><a href="#1-运行时的枚举是一个真实的对象。" class="headerlink" title="1. 运行时的枚举是一个真实的对象。"></a>1. 运行时的枚举是一个真实的对象。</h3><h3 id="2-编译时的枚举有如下特性："><a href="#2-编译时的枚举有如下特性：" class="headerlink" title="2. 编译时的枚举有如下特性："></a>2. 编译时的枚举有如下特性：</h3><ul><li><p><strong><mark>反向映射</mark></strong></p><p>在典型的对象中，我们通常使用属性名来获取值，这是从 key 到 value 的正向映射。然而在枚举中，我们也可以通过值来获取属性名，这便是反向映射。<strong><mark>只有数字枚举才会有反向映射</mark></strong>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> E &#123;</span><br><span class="line">  age = <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = E.<span class="property">age</span>; <span class="comment">// 18</span></span><br><span class="line"><span class="keyword">const</span> keyOfcc = E[a]; <span class="comment">// &quot;age&quot;，反向映射</span></span><br></pre></td></tr></table></figure></li><li><p><strong><mark>常量枚举</mark></strong></p><p>常量枚举的成员只能使用常量枚举表达式，且它们在编译期间会被完全删除。如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">  <span class="title class_">Up</span>,</span><br><span class="line">  <span class="title class_">Down</span>,</span><br><span class="line">  <span class="title class_">Left</span>,</span><br><span class="line">  <span class="title class_">Right</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> directions = [</span><br><span class="line">  <span class="title class_">Direction</span>.<span class="property">Up</span>,</span><br><span class="line">  <span class="title class_">Direction</span>.<span class="property">Down</span>,</span><br><span class="line">  <span class="title class_">Direction</span>.<span class="property">Left</span>,</span><br><span class="line">  <span class="title class_">Direction</span>.<span class="property">Right</span>,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>在编译之后，生成的代码中，该枚举会被删除，替换为相应的常量，生成如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">let directions = [</span><br><span class="line">    0 /* Up */,</span><br><span class="line">    1 /* Down */,</span><br><span class="line">    2 /* Left */,</span><br><span class="line">    3 /* Right */,</span><br><span class="line">];</span><br></pre></td></tr></table></figure></li><li><p><strong><mark>常量枚举陷阱</mark></strong></p><p>陷阱就不提了，涉及到一些我目前的这些文章中没提到的概念。不够官方文档提供了两条解决办法。</p><ol><li><p>完全不使用常量枚举。这可以解决陷阱问题，但是完全禁止了常量枚举的使用，对我们的项目并不友好；</p></li><li><p>不发布环境常量枚举，据说 TS 项目内部就是这么做的。</p></li></ol></li></ul><h2 id="七、环境枚举"><a href="#七、环境枚举" class="headerlink" title="七、环境枚举"></a>七、环境枚举</h2><p>环境枚举用于描述一个已经存在的枚举的形状。与常规枚举不同的是，环境枚举的所有没有初始化的成员会被 TS 认为是计算属性成员。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">enum</span> <span class="title class_">Enum</span> &#123;</span><br><span class="line">  A = <span class="number">1</span>,</span><br><span class="line">  B,</span><br><span class="line">  C = <span class="number">2</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="八、枚举-vs-对象"><a href="#八、枚举-vs-对象" class="headerlink" title="八、枚举 vs 对象"></a>八、枚举 vs 对象</h2><p>本来还在开开心心学枚举，直到看到官网上这么一句话：在现代<code>TypeScript</code>中，我们或许不太需要枚举类型，因为可以通过对一个对象使用常量断言 <code>as const</code>来替代枚举。甚至用对象的方式可能会更好，因为更贴近<code>JS</code>语言习惯。？？？所以我花了大半天时间在官方文档上看枚举是为了啥？？？不管怎么样，还是把栗子搬过来：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> <span class="title class_">EDirection</span> &#123;</span><br><span class="line">  <span class="title class_">Up</span>,</span><br><span class="line">  <span class="title class_">Down</span>,</span><br><span class="line">  <span class="title class_">Left</span>,</span><br><span class="line">  <span class="title class_">Right</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ODirection</span> = &#123;</span><br><span class="line">  <span class="title class_">Up</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="title class_">Down</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="title class_">Left</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="title class_">Right</span>: <span class="number">3</span>,</span><br><span class="line">&#125; <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">EDirection</span>.<span class="property">Up</span>; <span class="comment">// 0</span></span><br><span class="line"><span class="title class_">ODirection</span>.<span class="property">Up</span>; <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>行吧，枚举咱就学到这里了，下一期我们来学习 <code>namespace</code>，也许吧。下一篇再见！</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前 端 </tag>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript 系列  进阶篇(二)  装饰器</title>
      <link href="/articals/75816c7c/"/>
      <url>/articals/75816c7c/</url>
      
        <content type="html"><![CDATA[<p>装饰器可以为类提供附加功能。在<code>JS</code>中，装饰器仍是第 2 阶段的提案，而在<code>TS</code>中，可作为一项实验性功能来使用，增强类的功能。</p><h2 id="〇、启用装饰器"><a href="#〇、启用装饰器" class="headerlink" title="〇、启用装饰器"></a>〇、启用装饰器</h2><p>由于装饰器是一项实验性功能，因此需要在<strong>命令行 或 <code>tsconfig.json</code></strong>配置文件中启用。</p><h3 id="1-命令行启用"><a href="#1-命令行启用" class="headerlink" title="1. 命令行启用"></a>1. 命令行启用</h3><p>在执行编译命令时 加入 <strong><code>--experimentalDecorators</code></strong>：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx tsc <span class="literal">--target</span> ES5 <span class="literal">--experimentalDecorators</span></span><br></pre></td></tr></table></figure><h3 id="2-在tsconfig-json中启用"><a href="#2-在tsconfig-json中启用" class="headerlink" title="2. 在tsconfig.json中启用"></a>2. 在<code>tsconfig.json</code>中启用</h3><p>只需要修改配置文件即可：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ES5&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;experimentalDecorators&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="一、装饰器"><a href="#一、装饰器" class="headerlink" title="一、装饰器"></a>一、装饰器</h2><p>装饰器是一个函数，可以被附加到类的声明、方法、存取器、属性甚至是参数上，从而提供附加功能。装饰器的形式为 <strong><code>@ func*</code></strong>，其中 <code>func</code> 是一个函数。例如，我们给出一个 <code>@sealed</code> 装饰器，则应该有相应的 <code>sealed</code> 函数：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sealed</span>(<span class="params">target</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、装饰器工厂函数"><a href="#二、装饰器工厂函数" class="headerlink" title="二、装饰器工厂函数"></a>二、装饰器工厂函数</h2><p>装饰器工厂是一个函数，其返回值是一个装饰器。我们可以调用装饰器工厂函数，来得到装饰器，即形式为：<strong><code>@ decoratorFactory( )</code></strong>，注意与直接写装饰器的形式的区别。<strong>装饰器形式无法手动传入参数，但是装饰器工厂函数可以！</strong> 因此，如果是需要传参的装饰器，我们应该使用装饰器工厂，让其返回一个装饰器。</p><p>装饰器工厂返回值的类型为装饰器的类型，<code>TS</code>已内置提供：</p><ul><li>类装饰器类型：<code>ClassDecorator</code>；</li><li>方法装饰器类型：<code>MethodDecorator</code>；</li><li>属性装饰器：<code>PropertyDecorator</code>；</li><li>存取器装饰器：未提供；</li><li>参数装饰器：<code>ParameterDecorator</code>；</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类装饰器工厂函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">food</span>(<span class="params"></span>): <span class="title class_">ClassDecorator</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 返回一个类装饰器</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、装饰器的组合"><a href="#三、装饰器的组合" class="headerlink" title="三、装饰器的组合"></a>三、装饰器的组合</h2><p>多个装饰器可以组合使用，可以写在单行，也可以写在多行。例如，用 <code>@f</code> 和 <code>@g</code> 来装饰 <code>x</code>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单行</span></span><br><span class="line"><span class="meta">@f</span> <span class="meta">@g</span> x</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多行</span></span><br><span class="line"><span class="meta">@f</span></span><br><span class="line"><span class="meta">@g</span></span><br><span class="line">x</span><br></pre></td></tr></table></figure><p>组合使用的装饰器，和数学中的函数嵌套一样。如上面的栗子在数学中表达为 <code>f( g(x) )</code>。因此，装饰器的执行顺序是由内而外的，即内层装饰器函数先执行，再将得到的结果传给外层装饰器调用。但是如果我们用的是装饰器工厂，则<strong>工厂函数会自上而下先执行，之后装饰器函数则下而上执行</strong>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">first</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;first(): factory evaluated&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span></span><br><span class="line"><span class="params">    target: <span class="built_in">any</span>,</span></span><br><span class="line"><span class="params">    propertyKey: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">    descriptor: PropertyDescriptor</span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;first(): called&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">second</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;second(): factory evaluated&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span></span><br><span class="line"><span class="params">    target: <span class="built_in">any</span>,</span></span><br><span class="line"><span class="params">    propertyKey: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">    descriptor: PropertyDescriptor</span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;second(): called&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExampleClass</span> &#123;</span><br><span class="line">  <span class="meta">@first</span>()</span><br><span class="line">  <span class="meta">@second</span>()</span><br><span class="line">  <span class="title function_">method</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会先执行first工厂函数、second工厂函数，</span></span><br><span class="line"><span class="comment">// 再执行second工厂返回的装饰器、first工厂返回的装饰器函数</span></span><br><span class="line"><span class="comment">// 因此，打印顺序为：</span></span><br><span class="line"><span class="comment">// &#x27;first(): factory evaluated&#x27;</span></span><br><span class="line"><span class="comment">// &#x27;second(): factory evaluated&#x27;</span></span><br><span class="line"><span class="comment">// &#x27;second(): called&#x27;</span></span><br><span class="line"><span class="comment">// &#x27;first(): called&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="四、装饰器的执行顺序"><a href="#四、装饰器的执行顺序" class="headerlink" title="四、装饰器的执行顺序"></a>四、装饰器的执行顺序</h2><ul><li><strong>参数装饰器</strong>，然后依次是<strong>方法装饰器</strong>，<strong>存取器装饰器</strong>，或<strong>属性装饰器</strong>应用到每个实例成员;</li><li><strong>参数装饰器</strong>，然后依次是<strong>方法装饰器</strong>，<strong>存取器装饰器</strong>，或<strong>属性装饰器</strong>应用到每个静态成员;</li><li><strong>参数装饰器</strong>应用到构造函数;</li><li><strong>类装饰器</strong>应用到类;</li></ul><h2 id="五、类装饰器"><a href="#五、类装饰器" class="headerlink" title="五、类装饰器"></a>五、类装饰器</h2><p>只能在声明一个类之前，来声明类装饰器，不能子声明文件或其它任何环境的上下文中声明。<strong>类装饰器会被应用于类的构造函数上，以该构造函数作为唯一的参数，用于观察、修改或替换类的定义</strong>。如果类装饰器有返回值 (必须是一个函数)，则该<strong>返回值会替换类的构造函数</strong>。需要注意，如果我们要用装饰器返回的函数来替换类的构造函数，那么<strong>应该在手动该函数中调整原型指向</strong>，因为类装饰器的运行时逻辑不会自动来做这些。</p><p>搬运一个官方的栗子，通过<code>seal</code>装饰器来阻止构造函数和原型被修改，装饰器不会影响到类的继承，我们依然可以给其创建子类。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@sealed</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BugReport</span> &#123;</span><br><span class="line">  <span class="keyword">type</span> = <span class="string">&quot;report&quot;</span>;</span><br><span class="line">  <span class="attr">title</span>: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">t: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">title</span> = t;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 装饰器，通过Object.seal方法封闭构造函数和原型，使之无法新增或被删除</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sealed</span>(<span class="params">constructor: <span class="built_in">Function</span></span>) &#123;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">seal</span>(constructor);</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">seal</span>(constructor.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的栗子演示了通过类装饰器的返回值来重载类。由于类装饰器不会改变<code>TS</code>中的类型，因此即使类被重载了，却依然保留着之前的类型。因此，<code>TS</code>并不知道重载后的新属性的存在(实际上是存在的)。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> reportableClassDecorator&lt;T <span class="keyword">extends</span> &#123; <span class="keyword">new</span> (...<span class="attr">args</span>: <span class="built_in">any</span>[]): &#123;&#125; &#125;&gt;(</span><br><span class="line">  <span class="attr">constructor</span>: T</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> constructor &#123;</span><br><span class="line">    reportingURL = <span class="string">&quot;http://www...&quot;</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@reportableClassDecorator</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BugReport</span> &#123;</span><br><span class="line">  <span class="keyword">type</span> = <span class="string">&quot;report&quot;</span>;</span><br><span class="line">  <span class="attr">title</span>: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">t: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">title</span> = t;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bug = <span class="keyword">new</span> <span class="title class_">BugReport</span>(<span class="string">&quot;Needs dark mode&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bug.<span class="property">title</span>); <span class="comment">// 打印 &quot;Needs dark mode&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bug.<span class="property">type</span>); <span class="comment">// 打印 &quot;report&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 敲黑板：TS不知道reportingUrl属性的存在，因此检查机制会报错，</span></span><br><span class="line"><span class="comment">// 但是实际上它是存在的</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bug.<span class="property">reportingURL</span>);</span><br></pre></td></tr></table></figure><h2 id="六、方法装饰器"><a href="#六、方法装饰器" class="headerlink" title="六、方法装饰器"></a>六、方法装饰器</h2><p>方法装饰器的声明，位于方法之前，<mark><strong>作用于方法的属性描述符上</strong></mark>，<strong>来观察、修改或替换方法的定义</strong>。方法装饰器也不能用于声明文件、函数重载或其它上下文环境中。如果<strong>方法装饰器有返回值，则该返回值会被用作方法的属性描述符</strong>。注意，若<strong><code>target</code>设置为低于 <code>ES5</code> 的版本，则属性描述符为 <code>undefined</code> ，且方法装饰器的返回值也会被忽略</strong>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 装饰器工厂</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">enumerable</span>(<span class="params">val: <span class="built_in">boolean</span> = <span class="literal">true</span></span>) &#123;</span><br><span class="line">  <span class="comment">// 返回一个装饰器，PropertyDescriptor是属性描述符的类型</span></span><br><span class="line">  <span class="comment">// 该装饰器用于根据传入的值修改方法的enumerable属性</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span></span><br><span class="line"><span class="params">    target: <span class="built_in">Function</span>,</span></span><br><span class="line"><span class="params">    key: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">    descriptor: PropertyDescriptor</span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    descriptor.<span class="property">enumerable</span> = val;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于装饰某个方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将sayHello方法设置为不可遍历(仍然按可以调用，但是无法被遍历出来)</span></span><br><span class="line">  <span class="meta">@enumerable</span>(<span class="literal">false</span>)</span><br><span class="line">  <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, I am <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="七、存取器装饰器"><a href="#七、存取器装饰器" class="headerlink" title="七、存取器装饰器"></a>七、存取器装饰器</h2><p>和方法装饰器一样，存取器装饰器声明于 存取器的声明 之前，作用于存取器的属性描述符，用以观测、修改或替换存取器的定义。存取器装饰器不能用在声明文件或其它上下文环境中。<code>TS</code>不允许同时装饰同一个成员的 <code>get</code> 和 <code>set</code> ，只能按照书写的顺序装饰最先出现的那一个，因为<code>get</code>和<code>set</code>结合起来，属于同一个属性描述符。</p><p>存取器装饰器带有三个参数</p><ul><li>如果被装饰的是静态成员，则第一个参数为类的构造函数；如果被装饰的是实例成员，则第一个参数是实例成员的原型 <code>prototype</code> ；</li><li>该成员的名字；</li><li>该成员的属性描述符。</li></ul><p>同样的，如果存取器装饰器有返回值，则该返回值被用作该成员的属性描述符；如果<code>target</code>设置的版本低于<code>ES5</code>，则返回值会被忽略，成员的属性描述符也为<code>undefined</code>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="comment">// 属性</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span>, <span class="keyword">private</span> _age: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">  <span class="meta">@configurale</span>(<span class="literal">false</span>)</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">age</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_age</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">configurable</span>(<span class="params">val: <span class="built_in">boolean</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">target: Person, key: <span class="built_in">string</span>, desc: PropertyDescriptor</span>) &#123;</span><br><span class="line">    desc.<span class="property">configurable</span> = val;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="八、属性装饰器"><a href="#八、属性装饰器" class="headerlink" title="八、属性装饰器"></a>八、属性装饰器</h2><p>属性装饰器声明于属性的声明之前，不能用在声明文件或其它上下文环境中。属性装饰器函数只有两个参数：</p><ul><li>如果是装饰静态属性，则第一个参数为构造函数；如果装饰实例属性，则第一个参数为实例的原型；</li><li>属性名；</li></ul><p>属性装饰器不支持属性描述符作为参数，其返回值也会被忽略，因为属性是在实例成员身上，而不是在原型身上，目前的机制无法通过修改原型而影响到实例身上的属性。</p><p>下面的栗子中使用了<code>reflect-metadata API</code>，如果对该<code>API</code>没有了解，建议先阅读第十节<strong><code>Metadata</code></strong>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Greeter</span> &#123;</span><br><span class="line">  <span class="comment">// 属性装饰器：提供一个格式化模板，该装饰器函数中声明了元数据，</span></span><br><span class="line">  <span class="comment">// 真正的格式化是在greet中进行的</span></span><br><span class="line">  <span class="meta">@format</span>(<span class="string">&quot;Hello, %s&quot;</span>)</span><br><span class="line">  <span class="attr">greeting</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="comment">// 初始化</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">message: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">greeting</span> = message;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// getFormat中获取 metadata 数据</span></span><br><span class="line">    <span class="keyword">let</span> formatString = <span class="title function_">getFormat</span>(<span class="variable language_">this</span>, <span class="string">&quot;greeting&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> formatString.<span class="title function_">replace</span>(<span class="string">&quot;%s&quot;</span>, <span class="variable language_">this</span>.<span class="property">greeting</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要先安装依赖 npm i reflect-metadata --save</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;reflect-metadata&quot;</span>;</span><br><span class="line"><span class="comment">// 元数据的key，使用Symbol避免key的冲突</span></span><br><span class="line"><span class="keyword">const</span> formatMetadataKey = <span class="title class_">Symbol</span>(<span class="string">&quot;format&quot;</span>);</span><br><span class="line"><span class="comment">// 装饰器工厂，将参数为元数据的值，后续获取</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">format</span>(<span class="params">formatString: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="comment">// 这里return的返回值事实上会被忽略，</span></span><br><span class="line">  <span class="comment">// 但是通过Reflect.matadata声明的元数据依然存在，</span></span><br><span class="line">  <span class="comment">// 可后续通过Reflect.getMetadata方法获取</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">metadata</span>(formatMetadataKey, formatString);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取声明的元数据的值，该函数在greet方法中调用，事实上就是获取format传入的</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getFormat</span>(<span class="params">target: <span class="built_in">any</span>, propertyKey: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(formatMetadataKey, target, propertyKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="九、参数装饰器"><a href="#九、参数装饰器" class="headerlink" title="九、参数装饰器"></a>九、参数装饰器</h2><p>形参装饰器位于形参之前，可用于构造函数或方法中，不可用在声明文件、函数/方法重载以及其它上下文环境中。接收三个参数：</p><ul><li>如果是装饰静态方法，则第一个参数为构造函数；如果装饰实例方法，则第一个参数是实例的原型；</li><li>方法名；</li><li>函数的参数列表中该参数的索引顺序。</li></ul><p>参数装饰器仅能用来监测在方法中声明了的参数。下面的栗子同样用到了<code>reflect-metadata</code>API，并且使用参数装饰器 <code>@required</code>来标记必需的参数，使用方法装饰器<code>@validate</code>来进行校验。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BugReport</span> &#123;</span><br><span class="line">  <span class="keyword">type</span> = <span class="string">&quot;report&quot;</span>;</span><br><span class="line">  <span class="attr">title</span>: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">t: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">title</span> = t;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 方法装饰器和参数装饰器，还记得执行顺序吗？</span></span><br><span class="line">  <span class="meta">@validate</span></span><br><span class="line">  <span class="title function_">print</span>(<span class="params"><span class="meta">@required</span> verbose: <span class="built_in">boolean</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (verbose) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">`type: <span class="subst">$&#123;<span class="variable language_">this</span>.<span class="keyword">type</span>&#125;</span>\ntitle: <span class="subst">$&#123;<span class="variable language_">this</span>.title&#125;</span>`</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">title</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用到了 reflect-metadata ，需要先引入</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;reflect-metadata&quot;</span>;</span><br><span class="line"><span class="comment">// 使用Symbol来防止key冲突</span></span><br><span class="line"><span class="keyword">const</span> requiredMetadataKey = <span class="title class_">Symbol</span>(<span class="string">&quot;required&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数装饰器函数，接收三个参数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">required</span>(<span class="params"></span></span><br><span class="line"><span class="params">  target: <span class="built_in">Object</span>,</span></span><br><span class="line"><span class="params">  propertyKey: <span class="built_in">string</span> | <span class="built_in">symbol</span>,</span></span><br><span class="line"><span class="params">  parameterIndex: <span class="built_in">number</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 获取或者初始化已存在的必需参数数组</span></span><br><span class="line">  <span class="keyword">let</span> <span class="attr">existingRequiredParameters</span>: <span class="built_in">number</span>[] =</span><br><span class="line">    <span class="title class_">Reflect</span>.<span class="title function_">getOwnMetadata</span>(requiredMetadataKey, target, propertyKey) || [];</span><br><span class="line">  <span class="comment">// 将该参数在 函数参数列表中的索引值 添加进 必须参数数组 中</span></span><br><span class="line">  existingRequiredParameters.<span class="title function_">push</span>(parameterIndex);</span><br><span class="line">  <span class="comment">// 将该必需参数数组设置为自定义的元数据，可在下一次装饰器执行时获取，</span></span><br><span class="line">  <span class="comment">// 或在validate装饰器中校验时获取</span></span><br><span class="line">  <span class="title class_">Reflect</span>.<span class="title function_">defineMetadata</span>(</span><br><span class="line">    requiredMetadataKey,</span><br><span class="line">    existingRequiredParameters,</span><br><span class="line">    target,</span><br><span class="line">    propertyKey</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法装饰器：校验必需参数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">validate</span>(<span class="params"></span></span><br><span class="line"><span class="params">  target: <span class="built_in">any</span>,</span></span><br><span class="line"><span class="params">  propertyName: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">  descriptor: TypedPropertyDescriptor&lt;<span class="built_in">Function</span>&gt;</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 获取原始方法，并进行非空断言，留着在重写的方法中调用</span></span><br><span class="line">  <span class="keyword">let</span> method = descriptor.<span class="property">value</span>!;</span><br><span class="line">  <span class="comment">// 重写方法</span></span><br><span class="line">  descriptor.<span class="property">value</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 获取在参数装饰器@required加入的必需参数</span></span><br><span class="line">    <span class="keyword">let</span> <span class="attr">requiredParameters</span>: <span class="built_in">number</span>[] = <span class="title class_">Reflect</span>.<span class="title function_">getOwnMetadata</span>(</span><br><span class="line">      requiredMetadataKey,</span><br><span class="line">      target,</span><br><span class="line">      propertyName</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 当存在必需参数时（有参数被@required装饰）</span></span><br><span class="line">    <span class="keyword">if</span> (requiredParameters) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> parameterIndex <span class="keyword">of</span> requiredParameters) &#123;</span><br><span class="line">        <span class="comment">// 如果参数的索引值超出了实参列表长度范围，或者实参列表中该索引对应的参数为undefined</span></span><br><span class="line">        <span class="comment">// 则会抛出错误，从而达到校验的效果</span></span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">          parameterIndex &gt;= <span class="variable language_">arguments</span>.<span class="property">length</span> ||</span><br><span class="line">          <span class="variable language_">arguments</span>[parameterIndex] === <span class="literal">undefined</span></span><br><span class="line">        ) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Missing required argument.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调整this指向，类方法中的this指向实例对象</span></span><br><span class="line">    <span class="keyword">return</span> method.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="十、Metadata-元数据"><a href="#十、Metadata-元数据" class="headerlink" title="十、Metadata 元数据"></a>十、<code>Metadata</code> 元数据</h2><p>上面的部分栗子使用了 <strong><code>reflect-metadata</code></strong> 库，它作为垫片给实验性的 <code>metadata</code> (元数据) <code>API</code> 打补丁，基本都是用作装饰器或在装饰器函数中使用。<code>Metadata</code>是<code>ES7</code>的提案，这些拓展目前还没成为 <code>ECMAScript</code> 的标准，但如果装饰器正式成为 <code>ECMAScript</code> 的标准，那么这个库也会被提议采用。</p><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h3><p>使用它需要先进行安装：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i reflect<span class="literal">-metadata</span> <span class="literal">--save</span></span><br></pre></td></tr></table></figure><p>并且在编译时命令行或者<code>tsconfig.json</code>中启用：</p><ul><li>命令行：</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx tsc <span class="literal">--target</span> ES5 <span class="literal">--experimentalDecorators</span> <span class="literal">--emitDecoratorMetadata</span></span><br></pre></td></tr></table></figure><ul><li><code>tsconfig.json</code>：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ES5&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;experimentalDecorators&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;emitDecoratorMetadata&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="2-Reflect-metadata"><a href="#2-Reflect-metadata" class="headerlink" title="2. Reflect.metadata( )"></a>2. <code>Reflect.metadata( )</code></h3><p>该方法通常作为装饰器用于在<strong>类</strong>或者<strong>类方法</strong>中通过<code>key</code>, <code>value</code>的形式声明元数据，后续可使用 <strong><code>Reflect.getMetadata( )</code></strong> 方法来获取元数据。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;reflect-metadata&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Reflect</span>.<span class="title function_">metadata</span>(<span class="string">&quot;inPerson&quot;</span>, <span class="string">&quot;someData1&quot;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="meta">@Reflect</span>.<span class="title function_">metadata</span>(<span class="string">&quot;inMethod&quot;</span>, <span class="string">&quot;someData2&quot;</span>)</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">sayHello</span>(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取声明的类元数据</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(<span class="string">&quot;inClass&quot;</span>, <span class="title class_">Test</span>)); <span class="comment">// &#x27;someData1&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取声明的类方法元数据</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(<span class="string">&quot;inMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Person</span>(), <span class="string">&quot;sayHello&quot;</span>));</span><br><span class="line"><span class="comment">// &#x27;someData2&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="3-Reflect-getMetadata"><a href="#3-Reflect-getMetadata" class="headerlink" title="3. Reflect.getMetadata( )"></a>3. <code>Reflect.getMetadata( )</code></h3><p>用于获取内置的或者人为声明的元数据。如获取类型信息：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;reflect-metadata&quot;</span>;</span><br><span class="line"><span class="comment">// 装饰器工厂</span></span><br><span class="line"><span class="keyword">function</span> <span class="title class_">TypeMeta</span>&lt;T&gt;(): <span class="title class_">PropertyDecorator</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">target: T, key: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">type</span> = <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(<span class="string">&quot;design:type&quot;</span>, target, key);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span> 的 type 为：<span class="subst">$&#123;<span class="keyword">type</span>&#125;</span>`</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印 name 的 type 为：number</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="meta">@TypeMeta</span>()</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，通过<code>Reflect.getMetadata(&quot;design:paramtypes&quot;, target, key)</code> 和 <code>Reflect.getMetadata(&quot;design:returntype&quot;, target, key)</code>可以分别获取函数的参数类型和返回值的类型。</p><h3 id="4-Reflect-defineMetadata"><a href="#4-Reflect-defineMetadata" class="headerlink" title="4. Reflect.defineMetadata( )"></a>4. <code>Reflect.defineMetadata( )</code></h3><p>此方法通常用在装饰器中自定义<code>metadataKey</code>，后续可通过<code>Reflect.getMetadata()</code>来获取。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;reflect-metadata&quot;</span>;</span><br><span class="line"><span class="comment">// 类装饰器工厂</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">classDecoratorFactory</span>(<span class="params"></span>): <span class="title class_">ClassDecorator</span> &#123;</span><br><span class="line">  <span class="comment">// 类装饰器接收一个target参数，通过ClassDecorator可自动推论出target的类型</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">target</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 在类上定义元数据，key 为 `classMetaDataKey`，value 为 `value1`</span></span><br><span class="line">    <span class="title class_">Reflect</span>.<span class="title function_">defineMetadata</span>(<span class="string">&quot;classMetaDataKey&quot;</span>, <span class="string">&quot;value1&quot;</span>, target);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法装饰器工厂</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">methodDecoratorFactory</span>(<span class="params"></span>): <span class="title class_">MethodDecorator</span> &#123;</span><br><span class="line">  <span class="comment">// 方法装饰器接收三个参数，通过MethodDecorator可自动推论参数的类型</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">target, key, descriptor</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 在类的原型属性 &#x27;myMethod&#x27; 上定义元数据，key 为 `methodMetaDataKey`，value 为 `value2`</span></span><br><span class="line">    <span class="title class_">Reflect</span>.<span class="title function_">defineMetadata</span>(<span class="string">&quot;methodMetaDataKey&quot;</span>, <span class="string">&quot;value2&quot;</span>, target, key);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@classDecoratorFactory</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myClass</span> &#123;</span><br><span class="line">  <span class="meta">@methodDecoratorFactory</span>()</span><br><span class="line">  <span class="title function_">myMethod</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(<span class="string">&quot;classMetaData&quot;</span>, myClass); <span class="comment">// &#x27;value1&#x27;</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(<span class="string">&quot;methodMetaData&quot;</span>, <span class="keyword">new</span> <span class="title function_">myClass</span>(), <span class="string">&quot;myMethod&quot;</span>); <span class="comment">// &#x27;value2&#x27;</span></span><br></pre></td></tr></table></figure><p>装饰器的基本使用就到此为止了，需要深化的话，还得是在项目中实战。下一篇，em，下一篇不晓得写点啥，最近公司的项目也即将开始，后面没有太多时间归纳。嗐，下一篇再见吧！</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前 端 </tag>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript 系列 进阶篇 (一) TS 内置泛型接口</title>
      <link href="/articals/e3b42d57/"/>
      <url>/articals/e3b42d57/</url>
      
        <content type="html"><![CDATA[<p>TS 提供了许多实用的全局内置类型，可以极大地方便我们的操作。</p><h2 id="1-Partial-lt-Type-gt-可选类型接口"><a href="#1-Partial-lt-Type-gt-可选类型接口" class="headerlink" title="1. Partial&lt;Type&gt; 可选类型接口"></a>1. <em><code>Partial&lt;Type&gt;</code></em> 可选类型接口</h2><p>通过<code>Partial&lt;T&gt;</code>可以通过将传入的类型的所有属性变为可选属性，从而得到一个新的类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PartialPerson</span> = <span class="title class_">Partial</span>&lt;<span class="title class_">Person</span>&gt;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">PartialPerson 为 &#123;</span></span><br><span class="line"><span class="comment">  name?: string,</span></span><br><span class="line"><span class="comment">  age?: number</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="2-Required-lt-Type-gt-必需类型接口"><a href="#2-Required-lt-Type-gt-必需类型接口" class="headerlink" title="2. Required&lt;Type&gt; 必需类型接口"></a>2. <em><code>Required&lt;Type&gt;</code></em> 必需类型接口</h2><p>与 <code>Partial</code> 相反，<code>Required&lt;T&gt;</code> 把传入的类型<code>T</code>的所有属性都变为必需的，得到一个新的类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  name?: <span class="built_in">string</span>;</span><br><span class="line">  age?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">RequiredPerson</span> = <span class="title class_">Required</span>&lt;<span class="title class_">Person</span>&gt;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">RequiredPerson为 &#123;</span></span><br><span class="line"><span class="comment">  name: string,</span></span><br><span class="line"><span class="comment">  age: number</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="3-Readonly-lt-Type-gt-只读类型接口"><a href="#3-Readonly-lt-Type-gt-只读类型接口" class="headerlink" title="3. Readonly&lt;Type&gt; 只读类型接口"></a>3. <em><code>Readonly&lt;Type&gt;</code></em> 只读类型接口</h2><p>将传入的类型的所有属性都变为只读属性，得到一个新的类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ReadonlyPerson</span> = <span class="title class_">Readonly</span>&lt;<span class="title class_">Person</span>&gt;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">ReadonlyPerson 为 &#123;</span></span><br><span class="line"><span class="comment">  readonly name: string,</span></span><br><span class="line"><span class="comment">  readonly age: number</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="4-Record-lt-Key-Type-gt"><a href="#4-Record-lt-Key-Type-gt" class="headerlink" title="4. Record&lt;Key, Type&gt;"></a>4. <em><code>Record&lt;Key, Type&gt;</code></em></h2><p>创建一个 <code>key</code> 为 <code>Key</code> 类型、<code>value</code> 为 <code>Type</code>类型的对象类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Partners</span> = <span class="string">&quot;cc&quot;</span> | <span class="string">&quot;yy&quot;</span> | <span class="string">&quot;princess&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PartnerInfo</span> = <span class="title class_">Record</span>&lt;<span class="title class_">Partners</span>, <span class="title class_">Person</span>&gt;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">PartnerInfo 为 &#123;</span></span><br><span class="line"><span class="comment">  cc: &#123;name: string, age: number&#125;,</span></span><br><span class="line"><span class="comment">  yy: &#123;name: string, age: number&#125;,</span></span><br><span class="line"><span class="comment">  princess: &#123;name: string, age: number&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="5-Pick-lt-Type-Keys-gt"><a href="#5-Pick-lt-Type-Keys-gt" class="headerlink" title="5. Pick&lt;Type, Keys&gt;"></a>5. <em><code>Pick&lt;Type, Keys&gt;</code></em></h2><p>挑选出 <code>Type</code>类型 中的 <code>Keys</code> 类型的属性，得到一个新的类型。一般来说，<code>Keys</code>为联合类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">gerder</span>: <span class="number">1</span> | <span class="number">2</span>;</span><br><span class="line">  <span class="attr">interests</span>: <span class="built_in">string</span>[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PickedPerson</span> = <span class="title class_">Pick</span>&lt;<span class="title class_">Person</span>, <span class="string">&quot;name&quot;</span> | <span class="string">&quot;interests&quot;</span>&gt;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">PickedPerson 为 &#123;</span></span><br><span class="line"><span class="comment">  name: string,</span></span><br><span class="line"><span class="comment">  interests: string[]</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="6-Omit-lt-Type-Keys-gt"><a href="#6-Omit-lt-Type-Keys-gt" class="headerlink" title="6. Omit&lt;Type, Keys&gt;"></a>6. <em><code>Omit&lt;Type, Keys&gt;</code></em></h2><p>与 <strong><code>Pick</code></strong> 相反，移除掉 <code>Type</code>类型 中的 <code>Keys</code> 类型的属性，得到一个由剩下的属性组成一个新的类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">gerder</span>: <span class="number">1</span> | <span class="number">2</span>;</span><br><span class="line">  <span class="attr">interests</span>: <span class="built_in">string</span>[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">OmitedPerson</span> = <span class="title class_">Omit</span>&lt;<span class="title class_">Person</span>, <span class="string">&quot;name&quot;</span> | <span class="string">&quot;interests&quot;</span>&gt;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">PickedPerson 为 &#123;</span></span><br><span class="line"><span class="comment">  age: number,</span></span><br><span class="line"><span class="comment">  gerder: 1 | 2</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="7-Exclude-lt-UnionType-ExcludeMember-gt"><a href="#7-Exclude-lt-UnionType-ExcludeMember-gt" class="headerlink" title="7. Exclude&lt;UnionType, ExcludeMember&gt;"></a>7. <em><code>Exclude&lt;UnionType, ExcludeMember&gt;</code></em></h2><p>从联合类型 <code>UnionType</code> 中移除某些类型，得到一个新的类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyType</span> = <span class="title class_">Exclude</span>&lt;<span class="string">&quot;cc&quot;</span> | <span class="string">&quot;yy&quot;</span> | <span class="string">&quot;princess&quot;</span>, <span class="string">&quot;princess&quot;</span>&gt;;</span><br><span class="line"><span class="comment">// MyType 为 &#x27;cc&#x27; | &#x27;yy&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="8-Extract-lt-Type-Union-gt"><a href="#8-Extract-lt-Type-Union-gt" class="headerlink" title="8. Extract&lt;Type, Union&gt;"></a>8. <em><code>Extract&lt;Type, Union&gt;</code></em></h2><p>提取出 <code>Type</code> 类型中能符合 <code>Union</code> 联合类型的类型，得到一个新的类型。很迷惑，这不就是用 “<code>&amp;</code>“ 连接两个类型么？</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A 为 (x: string) =&gt; void</span></span><br><span class="line"><span class="keyword">type</span> A = <span class="title class_">Extract</span>&lt;<span class="string">&quot;cc&quot;</span> | <span class="string">&quot;yy&quot;</span> | (<span class="function">(<span class="params">x: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>), <span class="title class_">Function</span>&gt;;</span><br><span class="line"><span class="comment">// B 为 &#123;name: string, age: number&#125;</span></span><br><span class="line"><span class="keyword">type</span> B = <span class="title class_">Extract</span>&lt;&#123; <span class="attr">name</span>: <span class="built_in">string</span>; <span class="attr">age</span>: <span class="built_in">number</span> &#125;, <span class="built_in">string</span> | &#123; <span class="attr">name</span>: <span class="built_in">string</span> &#125;&gt;;</span><br><span class="line"><span class="comment">// C 为 &#123;name: string, age: number&#125;</span></span><br><span class="line"><span class="keyword">type</span> C = (&#123; <span class="attr">name</span>: <span class="built_in">string</span>; <span class="attr">age</span>: <span class="built_in">number</span> &#125; &amp; <span class="built_in">string</span>) | &#123; <span class="attr">name</span>: <span class="built_in">string</span> &#125;;</span><br></pre></td></tr></table></figure><h2 id="9-NonNullable-lt-Type-gt-非空类型"><a href="#9-NonNullable-lt-Type-gt-非空类型" class="headerlink" title="9. NonNullable&lt;Type&gt; 非空类型"></a>9. <em><code>NonNullable&lt;Type&gt;</code></em> 非空类型</h2><p>移除 <code>Type</code> 类型中的 <code>null</code> 和 <code>undefined</code> ，得到一个新的类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Person</span> = <span class="string">&quot;cc&quot;</span> | <span class="string">&quot;yy&quot;</span> | <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NonNullPerson</span> = <span class="title class_">NonNullable</span>&lt;<span class="title class_">Person</span>&gt;; <span class="comment">// &#x27;cc&#x27; | &#x27;yy&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="10-Parameters-lt-FunctionType-gt"><a href="#10-Parameters-lt-FunctionType-gt" class="headerlink" title="10. Parameters&lt;FunctionType&gt;"></a>10. <em><code>Parameters&lt;FunctionType&gt;</code></em></h2><p>提取函数类型（或 <code>any</code>，<code>never</code> 等类型）中的参数，得到一个新的 元组 类型 (或<code>never</code>)。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params">arg: &#123; a: <span class="built_in">number</span>; b: <span class="built_in">string</span> &#125;</span>): <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T0</span> = <span class="title class_">Parameters</span>&lt;<span class="function">() =&gt;</span> <span class="built_in">string</span>&gt;;</span><br><span class="line"><span class="comment">// T0 = []</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">Parameters</span>&lt;<span class="function">(<span class="params">s: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>&gt;;</span><br><span class="line"><span class="comment">// T1 = [s: string]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = <span class="title class_">Parameters</span>&lt;&lt;T&gt;<span class="function">(<span class="params">arg: T</span>) =&gt;</span> T&gt;;</span><br><span class="line"><span class="comment">// T2 = [arg: unknown]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T3</span> = <span class="title class_">Parameters</span>&lt;<span class="keyword">typeof</span> f1&gt;;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">T3 = [arg: &#123;</span></span><br><span class="line"><span class="comment">  a: number;</span></span><br><span class="line"><span class="comment">  b: string;</span></span><br><span class="line"><span class="comment">&#125;]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T4</span> = <span class="title class_">Parameters</span>&lt;<span class="built_in">any</span>&gt;;</span><br><span class="line"><span class="comment">// T4 = unknown[]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T5</span> = <span class="title class_">Parameters</span>&lt;<span class="built_in">never</span>&gt;;</span><br><span class="line"><span class="comment">// T5 = never</span></span><br></pre></td></tr></table></figure><h2 id="11-ConstructorParameters-lt-Type-gt"><a href="#11-ConstructorParameters-lt-Type-gt" class="headerlink" title="11. ConstructorParameters&lt;Type&gt;"></a>11. <em><code>ConstructorParameters&lt;Type&gt;</code></em></h2><p>提取构造函数中的所有参数，得到一个新的 元组 或 数组 类型(或 <code>never</code> )。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">T0</span> = <span class="title class_">ConstructorParameters</span>&lt;<span class="title class_">ErrorConstructor</span>&gt;;</span><br><span class="line"><span class="comment">// T0 = [message?: string]</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">ConstructorParameters</span>&lt;<span class="title class_">FunctionConstructor</span>&gt;;</span><br><span class="line"><span class="comment">//  T1 = string[]</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = <span class="title class_">ConstructorParameters</span>&lt;<span class="title class_">RegExpConstructor</span>&gt;;</span><br><span class="line"><span class="comment">// T2 = [pattern: string | RegExp, flags?: string]</span></span><br></pre></td></tr></table></figure><h2 id="12-ReturnType-lt-Type-gt"><a href="#12-ReturnType-lt-Type-gt" class="headerlink" title="12. ReturnType&lt;Type&gt;"></a>12. <em><code>ReturnType&lt;Type&gt;</code></em></h2><p>得到一个由函数类型的返回值类型 组成的新类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>): &#123; <span class="attr">a</span>: <span class="built_in">number</span>; <span class="attr">b</span>: <span class="built_in">string</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T0</span> = <span class="title class_">ReturnType</span>&lt;<span class="function">() =&gt;</span> <span class="built_in">string</span>&gt;;</span><br><span class="line"><span class="comment">// T0 = string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">ReturnType</span>&lt;<span class="function">(<span class="params">s: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>&gt;;</span><br><span class="line"><span class="comment">// T1 = void</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = <span class="title class_">ReturnType</span>&lt;&lt;T&gt;<span class="function">() =&gt;</span> T&gt;;</span><br><span class="line"><span class="comment">// T2 = unknown</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T3</span> = <span class="title class_">ReturnType</span>&lt;&lt;T <span class="keyword">extends</span> U, U <span class="keyword">extends</span> <span class="built_in">number</span>[]&gt;<span class="function">() =&gt;</span> T&gt;;</span><br><span class="line"><span class="comment">// T3 = number[]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T4</span> = <span class="title class_">ReturnType</span>&lt;<span class="keyword">typeof</span> f1&gt;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">T4 = &#123;</span></span><br><span class="line"><span class="comment">    a: number;</span></span><br><span class="line"><span class="comment">    b: string;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T5</span> = <span class="title class_">ReturnType</span>&lt;<span class="built_in">any</span>&gt;;</span><br><span class="line"><span class="comment">// T5 = any</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T6</span> = <span class="title class_">ReturnType</span>&lt;<span class="built_in">never</span>&gt;;</span><br><span class="line"><span class="comment">// T6 = never</span></span><br></pre></td></tr></table></figure><h2 id="13-InstanceType-lt-Type-gt"><a href="#13-InstanceType-lt-Type-gt" class="headerlink" title="13. InstanceType&lt;Type&gt;"></a>13. <em><code>InstanceType&lt;Type&gt;</code></em></h2><p>得到<code>Type</code> 类型中的构造函数实例的类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  x = <span class="number">0</span>;</span><br><span class="line">  y = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T0</span> = <span class="title class_">InstanceType</span>&lt;<span class="keyword">typeof</span> C&gt;;</span><br><span class="line"><span class="comment">// T0 = C</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">InstanceType</span>&lt;<span class="built_in">any</span>&gt;;</span><br><span class="line"><span class="comment">// T1 = any</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = <span class="title class_">InstanceType</span>&lt;<span class="built_in">never</span>&gt;;</span><br><span class="line"><span class="comment">// T2 = never</span></span><br></pre></td></tr></table></figure><h2 id="14-ThisParameterType-lt-Type-gt"><a href="#14-ThisParameterType-lt-Type-gt" class="headerlink" title="14. ThisParameterType&lt;Type&gt;"></a>14. <em><code>ThisParameterType&lt;Type&gt;</code></em></h2><p>得到函数类型 <code>Type</code> 中的 <code>this</code> 参数的类型，如果没有 <code>this</code> 参数，则为<code>unknown</code>类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">toHex</span>(<span class="params"><span class="variable language_">this</span>: <span class="built_in">Number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">toString</span>(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P = Number</span></span><br><span class="line"><span class="keyword">type</span> P = <span class="title class_">ThisParameterType</span>&lt;<span class="keyword">typeof</span> toHex&gt;;</span><br></pre></td></tr></table></figure><h2 id="15-OmitThisParameter-lt-Type-gt"><a href="#15-OmitThisParameter-lt-Type-gt" class="headerlink" title="15. OmitThisParameter&lt;Type&gt;"></a>15. <em><code>OmitThisParameter&lt;Type&gt;</code></em></h2><p>移除函数类型 <code>Type</code> 中的 <code>this</code> 参数，得到一个新的类型。如果没有 <code>this</code> 参数，则直接返回 <code>Type</code> 类型；如果有 <code>this</code> 参数，则返回一个移除了 <code>this</code> 参数的新的函数类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">toHex</span>(<span class="params"><span class="variable language_">this</span>: <span class="built_in">Number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">toString</span>(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">fiveToHex</span>: <span class="title class_">OmitThisParameter</span>&lt;<span class="keyword">typeof</span> toHex&gt; = toHex.<span class="title function_">bind</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><h2 id="16-ThisType-lt-Type-gt"><a href="#16-ThisType-lt-Type-gt" class="headerlink" title="16. ThisType&lt;Type&gt;"></a>16. <em><code>ThisType&lt;Type&gt;</code></em></h2><p>不会返回新的类型，而是用于指定上下文中的 <code>this</code> 的类型为 <code>Type</code>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ObjectDescriptor</span>&lt;D, M&gt; = &#123;</span><br><span class="line">  data?: D;</span><br><span class="line">  methods?: M &amp; <span class="title class_">ThisType</span>&lt;D &amp; M&gt;; <span class="comment">// methods 中的 this 类型为 D &amp; M</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="17-Uppercase-lt-StringType-gt"><a href="#17-Uppercase-lt-StringType-gt" class="headerlink" title="17. Uppercase&lt;StringType&gt;"></a>17. <em><code>Uppercase&lt;StringType&gt;</code></em></h2><p>将 <code>string</code> 字面量类型 全部转化为大写，得到一个新的类型；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">UpperStr</span> = <span class="title class_">Uppercase</span>&lt;<span class="string">&quot;cc&quot;</span> | <span class="string">&quot;yy&quot;</span>&gt;;</span><br><span class="line"><span class="comment">// &#x27;CC&#x27; | &#x27;YY&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="18-Lowercase-lt-StringType-gt"><a href="#18-Lowercase-lt-StringType-gt" class="headerlink" title="18. Lowercase&lt;StringType&gt;"></a>18. <em><code>Lowercase&lt;StringType&gt;</code></em></h2><p>将 <code>string</code> 字面量类型 全部转化为小写，得到一个新的类型；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">LowerStr</span> = <span class="title class_">Lowercase</span>&lt;<span class="string">&quot;CC&quot;</span> | <span class="string">&quot;YY&quot;</span>&gt;;</span><br><span class="line"><span class="comment">// &#x27;cc&#x27; | &#x27;yy&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="19-Capitalize-lt-StringType-gt"><a href="#19-Capitalize-lt-StringType-gt" class="headerlink" title="19. Capitalize&lt;StringType&gt;"></a>19. <em><code>Capitalize&lt;StringType&gt;</code></em></h2><p>将 <code>string</code> 字面量类型 首字母转化为大写，得到一个新的类型；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">CapitalizeStr</span> = <span class="title class_">Capitalize</span>&lt;<span class="string">&quot;cc&quot;</span> | <span class="string">&quot;yy&quot;</span>&gt;;</span><br><span class="line"><span class="comment">// &#x27;Cc&#x27; | &#x27;Yy&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="20-Uncapitalize-lt-StringType-gt"><a href="#20-Uncapitalize-lt-StringType-gt" class="headerlink" title="20. Uncapitalize&lt;StringType&gt;"></a>20. <em><code>Uncapitalize&lt;StringType&gt;</code></em></h2><p>将 <code>string</code> 字面量类型 首字母转化为小写，得到一个新的类型；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">UncapitalizeStr</span> = <span class="title class_">Uncapitalize</span>&lt;<span class="string">&quot;CCcc&quot;</span> | <span class="string">&quot;YYyy&quot;</span>&gt;;</span><br><span class="line"><span class="comment">// &#x27;cCcc&#x27; | &#x27;yYyy&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前 端 </tag>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typescript系列 基础篇 (六) 模块化入门篇</title>
      <link href="/articals/7d186aad/"/>
      <url>/articals/7d186aad/</url>
      
        <content type="html"><![CDATA[<h1 id="Typescript-系列-基础篇-六-模块化入门篇"><a href="#Typescript-系列-基础篇-六-模块化入门篇" class="headerlink" title="Typescript 系列 基础篇 (六) 模块化入门篇"></a>Typescript 系列 基础篇 (六) 模块化入门篇</h1><p><code>TS</code>模块化是建立在<code>JS</code>模块化的基础上，与<code>JS</code>中的写法有许多的不同之处。<code>TS</code>极大地支持了主流的<code>ESM</code>和<code>CommomJs</code>，也对其他的模块化方案有所兼容。</p><h2 id="一、ES-模块化语法"><a href="#一、ES-模块化语法" class="headerlink" title="一、ES 模块化语法"></a>一、<code>ES</code> 模块化语法</h2><h3 id="1-export-导出"><a href="#1-export-导出" class="headerlink" title="1. export 导出"></a>1. <em><code>export</code></em> 导出</h3><p><code>TS</code>支持<code>ES</code>模块化方案，写法和<code>JS</code>中一致。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ModuleA.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> b = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> <span class="title function_">c</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 设置默认导出项，仅TS中可导出interface、type等</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-import-导入"><a href="#2-import-导入" class="headerlink" title="2. import 导入"></a>2. <em><code>import</code></em> 导入</h3><ul><li>使用<code>import</code>加载其它模块，和<code>JS</code>中一致，可以使用 <strong><code>as</code></strong> 重命名。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; a, b, c <span class="keyword">as</span> <span class="title class_">RenamedC</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./ModuleA&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Person</span> <span class="keyword">from</span> <span class="string">&quot;./ModuleA&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li>可以混合导入，但是默认项必须写在前面。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.ts</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Person</span>, &#123; a, b, c <span class="keyword">as</span> <span class="title class_">RenamedC</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./ModuleA&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li>可以使用 <strong><code>import *</code></strong> 来导入所有内容，并用 <strong><code>as</code></strong> 重命名。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.ts</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> M <span class="keyword">from</span> <span class="string">&quot;./ModuleA&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li>可以使用 <code>import + 文件名</code> 来导入一个文件，这种情况下，被导入的文件中的代码会被执行，可能会对当前作用域中的变量产生影响。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.ts</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./ModuleA&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li><p><code>TS</code>特有的语法</p><ul><li><p><code>JS</code>中没有<code>interface</code>、<code>type</code>等概念，没有相应的关键字。因此，<code>interface</code>和<code>type</code>语句是<code>TS</code>特有的导出语法。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ModuleB.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">Cat</span> = &#123; <span class="attr">breed</span>: <span class="built_in">string</span>; <span class="attr">yearOfBirth</span>: <span class="built_in">number</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">  <span class="attr">breeds</span>: <span class="built_in">string</span>[];</span><br><span class="line">  <span class="attr">yearOfBirth</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> c = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>导入时正常导入就行了。</p></li><li><p><strong><em><code>import type</code></em></strong> 语法</p><p>该语法只能用来导入类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不能导入变量c</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; <span class="title class_">Cat</span>, <span class="title class_">Dog</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./ModuleB&quot;</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>inline type imports</code></p><p><code>TS 4.5</code> 版本允许混合导入类型和变量。<strong>把 <code>type</code> 关键字写在导入的类型前面</strong>，不写<code>type</code>的则为变量。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不能导入变量c</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">type</span> <span class="title class_">Cat</span>, <span class="keyword">type</span> <span class="title class_">Dog</span>, c &#125; <span class="keyword">from</span> <span class="string">&quot;./ModuleB&quot;</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>具有 <code>CommonJs</code> 表现的 <code>ES</code> 语法</p><p>使用 <strong><code>export = &#123; // ... &#125;</code></strong> 来导出的模块，既可以用<code>CommonJs</code>语法导入，也可以用<code>ESM</code>的兼容语法 <code>import a = require(&#39;./xxx&#39;)</code> 语法导入。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ModuleX.ts</span></span><br><span class="line"><span class="keyword">export</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;x&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// app.ts</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="built_in">require</span>(<span class="string">&quot;./ModuleX&quot;</span>); <span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">import</span> b = <span class="built_in">require</span>(<span class="string">&quot;./ModuleX&quot;</span>); <span class="comment">// 推荐写法</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="二、CommonJs-模块化语法"><a href="#二、CommonJs-模块化语法" class="headerlink" title="二、CommonJs 模块化语法"></a>二、<code>CommonJs</code> 模块化语法</h2><p><strong>通过 全局变量 <code>module</code> 上的 <code>exports</code> 属性来设置导出的内容</strong>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MathModule.ts</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">pi</span>: <span class="number">3.14</span>,</span><br><span class="line">  <span class="attr">squareTwo</span>: <span class="number">1.41</span>,</span><br><span class="line">  <span class="attr">phi</span>: <span class="number">1.61</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对应的，使用 <strong><code>require</code></strong> 来导入。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.ts</span></span><br><span class="line"><span class="keyword">const</span> math = <span class="built_in">require</span>(<span class="string">&quot;./MathModule&quot;</span>);</span><br><span class="line"><span class="comment">// 或者也可以解构</span></span><br><span class="line"><span class="keyword">const</span> &#123; pi, squareTwo &#125; = <span class="built_in">require</span>(<span class="string">&quot;./MathModule&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>TS</code>系列基础篇就写到这儿了，累了，<code>TS</code>进阶篇再见。另外，想进一步了解<code>TS</code>模块化的知识，可以参考我的<strong><code>TS</code>进阶系列</strong>：<a href="https://juejin.cn/post/7080089003113840670">深入理解 TS 模块</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前 端 </tag>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript系列  基础篇(五)  Classes 类</title>
      <link href="/articals/e1f9072b/"/>
      <url>/articals/e1f9072b/</url>
      
        <content type="html"><![CDATA[<h1 id="TypeScript-系列-基础篇-五-Classes-类"><a href="#TypeScript-系列-基础篇-五-Classes-类" class="headerlink" title="TypeScript 系列 基础篇(五) Classes 类"></a>TypeScript 系列 基础篇(五) Classes 类</h1><p><strong>类</strong> 在 <code>JavaScript</code> 中出现于 <code>ES2015</code> 版本，<code>TS</code>对 类 进行了全面支持，还加入了一些其它语法来增强类的表达能力，本文将详细聊一聊<code>TS</code>中的类的知识，你知道的和不知道的，这里都有。</p><h2 id="一、类的成员"><a href="#一、类的成员" class="headerlink" title="一、类的成员"></a>一、类的成员</h2><h3 id="1-属性字段-Fields"><a href="#1-属性字段-Fields" class="headerlink" title="1. 属性字段 (Fields)"></a>1. 属性字段 (<code>Fields</code>)</h3><p>字段声明会为类添加创建一个<strong>公共</strong>的<strong>可写</strong>的<strong>实例属性</strong>。我们可以为字段添加类型注释，如果不添加，就会是 <code>any</code> 类型，当然这是我们不希望发生的。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  gender; <span class="comment">// gender为 any 类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字段声明时可以赋初值，其类型会被 TS 自动推论，在实例化时会自动执行值的初始化。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  name = <span class="string">&quot;cc&quot;</span>; <span class="comment">// name为string类型</span></span><br><span class="line">  age = <span class="number">18</span>; <span class="comment">// age 为 string 类型</span></span><br><span class="line">  <span class="attr">gender</span>: <span class="number">1</span> | <span class="number">2</span> = <span class="number">2</span>; <span class="comment">// 如果不注释类型，则gender会被推论为number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cc = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">cc.<span class="property">name</span>; <span class="comment">// &#x27;cc&#x27;</span></span><br><span class="line">cc.<span class="property">age</span>; <span class="comment">// 18</span></span><br></pre></td></tr></table></figure><p>如果开启了严格属性初始化检查： <strong><code>strictPropertyInitialization</code></strong>，则<strong>没有赋初值</strong>的字段<strong>必须在构造函数中初始化</strong>，不能在其它的方法中初始化，TS 不会去检测其它方法内的初始化。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  name = <span class="string">&quot;cc&quot;</span>; <span class="comment">// name为string类型</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = <span class="number">18</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，开启该检测是为了防止属性值为空带来的意外错误。我们可以使用<strong>非空断言</strong>来明确该属性不会为空，这样也不会报错。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  name!: <span class="built_in">number</span>; <span class="comment">// 非空断言</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-readonly-只读属性"><a href="#2-readonly-只读属性" class="headerlink" title="2. readonly 只读属性"></a>2. <em><code>readonly</code></em> 只读属性</h3><p>添加了 <strong><code>readonly</code></strong> 修饰符的属性，将<strong>不允许在构造函数以外的地方中进行重新赋值</strong>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&quot;cc&quot;</span>; <span class="comment">// 只读属性</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;yy&quot;</span>; <span class="comment">// 可以构造函数中赋值，因为构造函数相当于初始化</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">setName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;hi&quot;</span>; <span class="comment">// 报错，只读属性不允许重新赋值</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 也不可在类以外进行赋值</span></span><br><span class="line"><span class="keyword">const</span> cc = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">cc.<span class="property">name</span> = <span class="string">&quot;cc&quot;</span>; <span class="comment">// 报错，只读属性不允许重新赋值</span></span><br></pre></td></tr></table></figure><h3 id="3-constructor-构造函数"><a href="#3-constructor-构造函数" class="headerlink" title="3. constructor 构造函数"></a>3. <code>constructor</code> 构造函数</h3><p>构造函数接收实例化时传入的参数，可以提供参数默认值。在构造函数中进行类实例的初始化操作，可以分配属性值、调用类的方法等。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name = <span class="string">&quot;cc&quot;</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还记得我们在<a href="https://juejin.cn/post/7070172611849748517">Typescript 系列：(二)函数篇</a>里讲的函数重载吗？构造函数自然也可以重载。注意构造函数的<strong>重载签名</strong>和<strong>实现签名</strong>是没有返回值类型的。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="comment">// 两套重载签名</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">number</span></span>);</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>);</span><br><span class="line">  <span class="comment">// 实现签名</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">number</span> | <span class="built_in">string</span>, age?: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-调用-super"><a href="#4-调用-super" class="headerlink" title="4. 调用 super( )"></a>4. 调用 <em><code>super( )</code></em></h3><p>我们知道，类可以通过 <strong><code>extends</code></strong> 关键字来继承一个基类。此时，我们在构造函数中使用 <strong><code>this</code></strong> 关键字<strong>之前</strong>需要先调用 <strong><code>super( )</code></strong> ，相当于调用了父类的构造函数。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误，没有在构造函数中先调用super()，就使用了this</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User1</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User2</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-methods-方法"><a href="#5-methods-方法" class="headerlink" title="5. methods 方法"></a>5. <code>methods</code> 方法</h3><p>类里面的函数叫做方法。<strong>声明一个方法不要用 <code>function</code> 关键字</strong>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name = <span class="string">&quot;cc&quot;</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// setName方法</span></span><br><span class="line">  <span class="title function_">setName</span>(<span class="attr">name</span>: <span class="built_in">string</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-存取器-setters-getters"><a href="#6-存取器-setters-getters" class="headerlink" title="6. 存取器 setters/getters"></a>6. 存取器 <code>setters/getters</code></h3><p>和 <code>JS</code> 里没什么差别。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">_name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name = <span class="string">&quot;cc&quot;</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// setter</span></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">name: <span class="built_in">string</span></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">name</span>(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于存取器，<code>TS</code>有几个特别的推论：</p><ul><li>如果有 <code>get</code> 而没有 <code>set</code>，则该属性会被推论为 <code>readonly</code> 只读属性；</li><li>如果 <code>setter</code> 没有明确参数的类型，则会推论为 <code>getter</code> 的返回值的类型；</li><li><code>getter</code> 和 <code>setter</code> 的可见性保持一致。</li></ul><h3 id="7-索引签名"><a href="#7-索引签名" class="headerlink" title="7. 索引签名"></a>7. 索引签名</h3><p>类 也可以使用索引签名，和在对象类型里使用差不多。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  [<span class="attr">x</span>: <span class="built_in">string</span>]: <span class="built_in">string</span> | <span class="built_in">number</span> | (<span class="function">(<span class="params">s?: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">string</span> | <span class="built_in">number</span>);</span><br><span class="line"></span><br><span class="line">  name = <span class="number">1</span>;</span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、类的继承"><a href="#二、类的继承" class="headerlink" title="二、类的继承"></a>二、类的继承</h2><h3 id="1-implement-语句"><a href="#1-implement-语句" class="headerlink" title="1. implement 语句"></a>1. <code>implement</code> 语句</h3><p>使用 <strong><code>implements</code></strong> 语句检查类是否符合某接口规范。实现某个接口，则类中需要含有该接口的所有属性和方法才能通过检测。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">setName</span>: <span class="function">(<span class="params">x: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// People类 实现 Person 接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span> <span class="keyword">implements</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&quot;cc&quot;</span>;</span><br><span class="line">  <span class="title function_">setName</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以同时实现多个接口：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">setName</span>: <span class="function">(<span class="params">x: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Manager</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// People类 实现 Person 接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span> <span class="keyword">implements</span> <span class="title class_">Person</span>, <span class="title class_">Manager</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&quot;cc&quot;</span>;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">string</span> = <span class="string">&quot;001&quot;</span>;</span><br><span class="line">  <span class="title function_">setName</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 <strong>implements</strong> 语句只是检测类是否符合接口规范。</p><h3 id="2-extends-语句"><a href="#2-extends-语句" class="headerlink" title="2. extends 语句"></a>2. <code>extends</code> 语句</h3><ul><li>通过 <code>extends</code> 语句可以让类继承一个基类，获得它所有的属性和方法，还能定义自己的属性和方法。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&quot;cc&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cc = <span class="keyword">new</span> <span class="title class_">Manager</span>();</span><br><span class="line">cc.<span class="property">name</span>; <span class="comment">// &#x27;cc&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>重写父类方法，可以通过 <code>super.xx( )</code> 来调用父类的方法。子类的方法需要能兼容父类的方法，包括参数数量、类型，以及返回值。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&quot;cc&quot;</span>;</span><br><span class="line">  <span class="title function_">setName</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  <span class="title function_">setName</span>(<span class="params">name: <span class="built_in">string</span> | <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> name === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">name</span> = <span class="title class_">String</span>(name + <span class="number">100</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">super</span>.<span class="title function_">setName</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cc = <span class="keyword">new</span> <span class="title class_">Manager</span>();</span><br><span class="line">cc.<span class="title function_">setName</span>(<span class="number">99</span>);</span><br><span class="line">cc.<span class="property">name</span>; <span class="comment">// &#x27;199&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>字段类型声明</li></ul><p>在父类的构造函数执行完之后，才会开始子类的初始化，期间可能改写来自父类的属性或方法。当 子类的某个属性 是 父类相应属性 的子类型时，这个过程就会浪费性能。可以通过 <strong><em><code>declare</code></em></strong> 关键字来声明字段类型，使其不受运行时效果的影响。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">bark</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AnimalHouse</span> &#123;</span><br><span class="line">  <span class="attr">resident</span>: <span class="title class_">Animal</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">animal: Animal</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">resident</span> = animal;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DogHouse</span> <span class="keyword">extends</span> <span class="title class_ inherited__">AnimalHouse</span> &#123;</span><br><span class="line">  <span class="comment">// 通过declare关键字，使resident属性的类型固定为Dog</span></span><br><span class="line">  <span class="keyword">declare</span> <span class="attr">resident</span>: <span class="title class_">Dog</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">dog: Dog</span>) &#123;</span><br><span class="line">    <span class="comment">// 不要忘记调用super()</span></span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>初始化顺序</li></ul><p>父类字段初始化 —&gt; 父类构造函数执行 —&gt; 子类字段初始化 —&gt; 子类构造函数执行</p><h3 id="3-继承内置类型"><a href="#3-继承内置类型" class="headerlink" title="3. 继承内置类型"></a>3. 继承内置类型</h3><p>继承内置类型，如<code>Array</code>、<code>Error</code>等，当在构造函数中调用<code>super( )</code>之后，<code>this</code>的原型指向会错误地指向<code>super</code>的调用者，即<code>Array</code>、<code>Error</code>等内置类型。<code>ES6</code>使用 <strong><code>new.target</code></strong> 来调整原型链，但是在 <code>ES5</code> 中却保证不了 <code>new.target</code> 的值。因此，我们在调用<code>super()</code>之后，要手动调整原型链，让<code>this</code>的原型指向我们新的类。 <strong><code>Object.setPrototypeOf( )</code></strong> 便是要用的方法 (不支持该方法的可以退一步使用<code>Object.prototype.__proto__</code> )。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MsgError1</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Error</span> &#123;</span><br><span class="line">  naame = <span class="number">123</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">m: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(m);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello &quot;</span> + <span class="variable language_">this</span>.<span class="property">message</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">let</span> m1 = <span class="keyword">new</span> <span class="title class_">MsgError1</span>(<span class="string">&quot;cc&quot;</span>);</span><br><span class="line"><span class="comment">// 由于原型链错误，sayHello方法在MsgError的原型上，</span></span><br><span class="line"><span class="comment">// 而m1的原型指向Error，索引没有sayHello方法</span></span><br><span class="line">m1.<span class="title function_">sayHello</span>(); <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MsgError2</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Error</span> &#123;</span><br><span class="line">  naame = <span class="number">123</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">m: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(m);</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(<span class="variable language_">this</span>, <span class="title class_">MsgError2</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello &quot;</span> + <span class="variable language_">this</span>.<span class="property">message</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> m2 = <span class="keyword">new</span> <span class="title class_">MsgError2</span>(<span class="string">&quot;cc&quot;</span>);</span><br><span class="line">m2.<span class="title function_">sayHello</span>(); <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><p>需要注意，这种问题会一直传递下去，也就是说，<strong>以 <code>MsgError2</code> 为基类所创造的子类，也需要再次手动调整原型的指向</strong>。此外，不支持<code>IE10</code>及更低的版本。</p><h2 id="三、成员的可见性-Member-Visibility"><a href="#三、成员的可见性-Member-Visibility" class="headerlink" title="三、成员的可见性 Member Visibility"></a>三、成员的可见性 <code>Member Visibility</code></h2><p>在 TS 中，实现了 <code>public</code>，<code>protected</code>，<code>private</code>等修饰符来实现成员的可见性。</p><h3 id="1-public"><a href="#1-public" class="headerlink" title="1. public"></a>1. <code>public</code></h3><p><strong><code>public</code></strong> 修饰符用来定义公开成员，这也是默认的成员可见性，当没有写可见性修饰符时，就默认是 <code>public</code> 。被声明为<code>public</code>的成员，可在任何地方访问。太简单了就不给栗子了。</p><h2 id="2-protected"><a href="#2-protected" class="headerlink" title="2. protected"></a>2. <code>protected</code></h2><p>被 <strong><code>protected</code></strong> 修饰的成员只能在类或者其子类中访问，无法通过实例来访问。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 类中可以</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cc = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;cc&quot;</span>);</span><br><span class="line">cc.<span class="property">name</span>; <span class="comment">// TS会报错，实例无法访问protected成员</span></span><br></pre></td></tr></table></figure><p>在子类中，如果我们通过字段重新声明了基类中的 <code>protected</code> 成员，则会将其在子类中变为 <code>public</code> 成员，除非重新加上 <code>protected</code> 修饰符：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">protected</span> <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  <span class="comment">// 不加 protected 修饰符， 则name变为public，通过实例来访问</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="comment">// 而这个则依然是protected成员</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cc = <span class="keyword">new</span> <span class="title class_">Manager</span>(<span class="string">&quot;cc&quot;</span>, <span class="number">18</span>);</span><br><span class="line">cc.<span class="property">name</span>; <span class="comment">// &#x27;cc&#x27;</span></span><br><span class="line"><span class="comment">// 报错，实例无法调用 protected</span></span><br><span class="line">cc.<span class="property">age</span>;</span><br></pre></td></tr></table></figure><h3 id="3-private"><a href="#3-private" class="headerlink" title="3. private"></a>3. <code>private</code></h3><p>被 <strong><code>private</code></strong> 修饰的成员只能在类中访问，无法通过实例来访问，也无法在其子类中访问。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  <span class="comment">// 错误，private成员不能在子类中访问</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="comment">// 同样错误，private成员不能在子类中访问</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cc = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;cc&quot;</span>, <span class="number">18</span>);</span><br><span class="line">cc.<span class="property">name</span>; <span class="comment">// 也错误，private成员不能通过实例来访问</span></span><br></pre></td></tr></table></figure><p>但是在<code>TS</code>中支持在类中通过同类的其它实例获取该实例上的<code>private</code>成员：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">hasSameName</span>(<span class="params">other: Person</span>) &#123;</span><br><span class="line">    <span class="comment">// 可以访问其它同类实例的 private 成员name</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span> === other.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cc = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;cc&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> yy = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;yy&quot;</span>);</span><br><span class="line">cc.<span class="title function_">hasSameName</span>(yy); <span class="comment">// 不报错，得到false</span></span><br></pre></td></tr></table></figure><p>需要注意，成员可见性仅在 <code>TS</code> 的类型检查时有效。一旦代码被编译为 <code>JS</code> 代码，则在<code>JS</code>中，可以通过类实例查看原本在<code>TS</code>是 <code>pretected</code> 或 <code>private</code> 的成员。另外 <code>JS</code> 的私有修饰符 “<code>#</code>“ 可以实现在编译后依然是私有成员。因此，如果要实现通过私有化来保护成员，应使用闭包、<code>WeakMap</code>或私有字段 “<code>#</code>“ 等手段。</p><h2 id="四、静态成员-static"><a href="#四、静态成员-static" class="headerlink" title="四、静态成员 static"></a>四、静态成员 <code>static</code></h2><p>首先我们要明确一点，类本身也是一个对象。我们通过<strong><em><code>static</code></em></strong>修饰符可以将某个成员变成静态成员。<strong>静态成员与类的实例无关，而是被挂到类对象本身，可以与实例成员重名，且静态方法中的 <code>this</code> 指向类对象本身，我们通过类对象本身来访问类成员</strong>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="comment">// 这是实例成员</span></span><br><span class="line">  <span class="attr">_name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 给实例成员name赋值</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 静态属性 name</span></span><br><span class="line">  <span class="keyword">static</span> <span class="attr">_name</span>: <span class="built_in">string</span> = <span class="string">&quot;person&quot;</span>;</span><br><span class="line">  <span class="comment">// 静态方法 其中的this指向类Person</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">setName</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_name</span> = name;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// class Person &#123; // ... &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cc = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;cc&quot;</span>);</span><br><span class="line"><span class="comment">// 访问实例成员_name</span></span><br><span class="line">cc.<span class="property">_name</span>; <span class="comment">// &#x27;cc&#x27;</span></span><br><span class="line"><span class="comment">// 访问静态成员_name</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property">_name</span>; <span class="comment">// &#x27;person&#x27;</span></span><br></pre></td></tr></table></figure><p>也许你会好奇我为什么用 <code>_name</code> 而不是<code>name</code>，事实上不是我不使用，而是不能使用。稍后你会得到答案。</p><p>静态成员也可以使用 <code>public</code>、<code>protected</code>、<code>private</code>等修饰符。类似的，<strong><code>protected</code> 静态属性 只能由类或子类中的静态成员访问；<code>private</code>静态成员只能由 类 中的静态成员访问</strong>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">static</span> _name = <span class="string">&quot;person&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property">_name</span>; <span class="comment">// 报错，不能访问protected成员</span></span><br></pre></td></tr></table></figure><p>静态成员可以被子类继承：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> _name = <span class="string">&quot;person&quot;</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">setName</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Manager</span>.<span class="property">_name</span>; <span class="comment">// &#x27;person&#x27;</span></span><br><span class="line"><span class="title class_">Manager</span>.<span class="title function_">setName</span>(<span class="string">&quot;cc&quot;</span>);</span><br><span class="line"><span class="title class_">Manager</span>.<span class="property">_name</span>; <span class="comment">// &#x27;cc&#x27;</span></span><br></pre></td></tr></table></figure><p>特殊的静态名字：<strong><code>name</code></strong> ，由于存在内置静态属性 <strong><code>Function.name</code></strong>，因此我们在给静态属性命名时，不能使用<code>name</code>，否则会发生冲突。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="comment">// 错误，静态属性name与内置静态属性 Function.name 冲突</span></span><br><span class="line">  <span class="keyword">static</span> name = <span class="string">&quot;person&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、静态域"><a href="#五、静态域" class="headerlink" title="五、静态域"></a>五、静态域</h2><p>我将类中的 <code>static blocks</code> 称为静态域，通过 <strong><em><code>static &#123; &#125;</code></em></strong>声明一块区域，在该区域编写的语句能够自动执行，且能访问私有属性 如 “<code>#name</code>“。因此，可以在静态域中书写静态成员做初始化逻辑。这里想不出什么好的栗子，就搬运了官网的：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> #count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">count</span>()</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Foo</span>.#count;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> lastInstances = <span class="title function_">loadLastInstances</span>();</span><br><span class="line">      <span class="title class_">Foo</span>.#count += lastInstances.<span class="property">length</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、泛型类"><a href="#六、泛型类" class="headerlink" title="六、泛型类"></a>六、泛型类</h2><p>在执行<code>new</code>操作时，泛型类的类型参数也会由传入的参数来进行推论。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">name</span>: T;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: T</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">setName</span>(<span class="params">name: T</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cc = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;cc&quot;</span>); <span class="comment">// T被推论</span></span><br></pre></td></tr></table></figure><p>泛型类可以像泛型接口一样进行泛型约束以及指定类型参数的默认值。大家都能明白的吧，就不给栗子了。</p><p>静态成员无法享用泛型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">// 错误，静态成员不可引用类型参数</span></span><br><span class="line">  <span class="keyword">static</span> <span class="attr">_name</span>: T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是因为每个静态成员都只有一个，而实例成员在每个实例上都存在一个。假若静态成员能享用泛型，那么我们<code>new</code>一个实例<code>a</code>，传入类型<code>string</code>，此时静态属性<code>_name</code>类型为<code>string</code>；我们<code>new</code> 一个实例<code>b</code>，传入类型<code>number</code>，那么此时静态属性_<code>name</code>的类型是啥呢？<code>string</code>亦或<code>number</code> ? 显然都不合理。所以静态成员无法使用类型参数。</p><h2 id="七、运行时的-this"><a href="#七、运行时的-this" class="headerlink" title="七、运行时的 this"></a>七、运行时的 <code>this</code></h2><p><code>Ts</code>中的<code>this</code>指向和 <code>JS</code> 保持一致，因此有时候我们需要防止成员丢失<code>this</code>上下文。</p><h3 id="1-使用箭头函数"><a href="#1-使用箭头函数" class="headerlink" title="1. 使用箭头函数"></a>1. 使用箭头函数</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  setName = <span class="function">(<span class="params">name: <span class="built_in">string</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这也需要权衡利弊：</p><ul><li>这样做能保证<code>setName</code>方法的<code>this</code>永远正确地指向实例本身；</li><li>使用中这种方式定义的方法不会挂载原型上，而是会被添加到每一个实例上，因此会占用更多的内存；</li><li>同样，其子类无法通过<code>super</code>,<code>setName</code>来调用父类的<code>setName</code>方法，因为无法在原型链上找到；</li></ul><h3 id="2-使用-this-参数"><a href="#2-使用-this-参数" class="headerlink" title="2. 使用 this 参数"></a>2. 使用 <code>this</code> 参数</h3><p>如同在<code>TS</code>的函数中将<code>this</code>作为参数，为其指定类型一样，在类的方法中也可以如此这般。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="comment">// 为this指定类型为 Person，则只有Person实例才可以调用该方法</span></span><br><span class="line">  <span class="title function_">setName</span>(<span class="params"><span class="variable language_">this</span>: Person, name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式很好地弥补了箭头函数的不足，唯一的缺点就是习惯了 <code>JS</code> 思维的同学可能会试图通过其它对象来调用该方法，显然这样是不会成功的。</p><h2 id="八、-把-this-作为-类型"><a href="#八、-把-this-作为-类型" class="headerlink" title="八、 把 this 作为 类型"></a>八、 <em>把 <code>this</code> 作为 类型</em></h2><p><strong>首先要说，这玩意儿非常有用</strong>。在<code>TS</code>的类中，<code>this</code> 可以作为一种特殊的类型，由当前的类进行动态推论。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="comment">// 把 this 作为形参person的类型</span></span><br><span class="line">  <span class="title function_">setName</span>(<span class="params">person: <span class="variable language_">this</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = person.<span class="property">name</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="keyword">const</span> b = a.<span class="title function_">setName</span>(a); <span class="comment">// b的类型为当前的类 Person</span></span><br></pre></td></tr></table></figure><p>这里得<code>setName</code>返回了<code>this</code>，这个<code>this</code>是表示实例值，其类型被推论为 <code>this</code>，这个<code>this</code>表示类型。<code>this</code> 类型就会在<code>setName</code>调用时被动态推论为当前的类。这样的好处是在子类中可以也自动推论为子类。例如我们在<code>Person</code>类的实例中调用<code>setName</code>，返回值的类型就是<code>Person</code>；如果在<code>Person</code>的子类<code>Manager</code>的实例中调用<code>setName</code>，返回值的类型则是<code>Person</code>的子类<code>Manage</code>r：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="comment">// 把 this 作为形参person的类型</span></span><br><span class="line">  <span class="title function_">setName</span>(<span class="params">person: <span class="variable language_">this</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = person.<span class="property">name</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> y = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="keyword">const</span> yy = y.<span class="title function_">setName</span>(y); <span class="comment">// aa的类型为Person</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> <span class="title class_">Manager</span>();</span><br><span class="line"><span class="keyword">const</span> cc = c.<span class="title function_">setName</span>(c); <span class="comment">// cc的类型为Manager</span></span><br></pre></td></tr></table></figure><p><strong>基于 <code>this</code> 类型的 类型守卫</strong>：和在函数中一样，我们可以在类或接口的方法的返回值的类型的位置使用<strong><em><code>this is Type</code></em></strong>来进行类型缩减。写个最简单的栗子吧，实在是懒癌犯了 <code>qwq</code>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  name? = <span class="string">&#x27;cc&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  <span class="comment">// 类型守卫的 this 为类型</span></span><br><span class="line">  <span class="title function_">isPerson</span>()<span class="variable language_">this</span> is <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">// return 语句的 this 指代类实例</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Person</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 可以利用 基于 this 类型的类型守卫 来进行类型缩减</span></span><br><span class="line">  <span class="title function_">hasName</span>()<span class="variable language_">this</span> is &#123;<span class="attr">name</span>: <span class="built_in">string</span>&#125; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span> !== <span class="literal">undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cc = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"><span class="comment">// 利用类型守卫来进行类型缩减</span></span><br><span class="line"><span class="keyword">if</span>(cc.<span class="title function_">hasName</span>())&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="九、参数属性"><a href="#九、参数属性" class="headerlink" title="九、参数属性"></a>九、参数属性</h2><p>参数属性是<code>TS</code>提供的一个非常方便的语法。在构造函数的参数前加上 <code>public</code>、<code>protected</code>、<code>private</code>或者<code>readonly</code>等修饰符，就可以把普通参数变为参数属性。参数属性既是构造函数的参数，又会作为实例属性自动被添加到实例上，且在传参时自动进行赋值，无需在函数体内进行赋值操作。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="keyword">public</span> name: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">    <span class="keyword">protected</span> age: <span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> gender: <span class="number">1</span> | <span class="number">2</span></span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="comment">// 不需要在这里再进行赋值</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">setAge</span>(<span class="params">age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getAge</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">age</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> cc = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;cc&quot;</span>, <span class="number">18</span>, <span class="number">2</span>);</span><br><span class="line">cc.<span class="property">name</span>; <span class="comment">// &#x27;cc&#x27;</span></span><br><span class="line">cc.<span class="title function_">setAge</span>(<span class="number">20</span>);</span><br><span class="line">cc.<span class="title function_">getAge</span>(); <span class="comment">// 20</span></span><br><span class="line">cc.<span class="property">gender</span>; <span class="comment">// 报错，private属性不能通过实例</span></span><br></pre></td></tr></table></figure><h2 id="十、类表达式"><a href="#十、类表达式" class="headerlink" title="十、类表达式"></a>十、类表达式</h2><p>类似函数表达式，没啥说的，直接上栗子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Person</span> = <span class="keyword">class</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&quot;cc&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cc = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">cc.<span class="property">name</span>; <span class="comment">// &#x27;cc&#x27;  cc的类型是Person</span></span><br></pre></td></tr></table></figure><h2 id="十一、abstract-抽象类及其成员"><a href="#十一、abstract-抽象类及其成员" class="headerlink" title="十一、abstract 抽象类及其成员"></a>十一、<em>abstract</em> 抽象类及其成员</h2><p>含有抽象成员的类为抽象类。抽象类和抽象成员都需要在前面加上 <strong><code>abstract</code></strong> 修饰符。抽象类不能使用 <code>new</code> 进行实例化，而是用来作为<strong>基类</strong>，声明一些抽象方法或抽象属性，其子类需要实现所有这些方法或属性。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="title function_">setName</span>(<span class="attr">x</span>: <span class="built_in">string</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类必须包含父类的全部</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&quot;manager&quot;</span>;</span><br><span class="line">  <span class="title function_">setName</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="十二、类成员之间的关系"><a href="#十二、类成员之间的关系" class="headerlink" title="十二、类成员之间的关系"></a>十二、类成员之间的关系</h2><p>和其它类型一样，类之间也是通过结构来进行比较的，当拥有相同的成员，则可以相互替换；当一个类<code>A</code>中含有另一个类<code>B</code>的所有成员，尽管没有显示地通过 <code>extends</code> 继承，类 <code>A</code> 依然会被认为是类 <code>B</code> 的子类。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不会报错</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">person</span>: <span class="title class_">Person</span> = <span class="keyword">new</span> <span class="title class_">Manager</span>();</span><br></pre></td></tr></table></figure><p>这看起来很直观简单，不过少数情况下会看起来有些 <code>emmm</code>，怪怪的。拿个官方栗子来：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x: Empty</span>) &#123;</span><br><span class="line">  <span class="comment">// 啥也不做</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下这几个都没问题，也就是说，它们都是空类 Empty 的子类</span></span><br><span class="line"><span class="comment">// bigint和symbol不是</span></span><br><span class="line"><span class="title function_">fn</span>(<span class="variable language_">window</span>);</span><br><span class="line"><span class="title function_">fn</span>(&#123;&#125;);</span><br><span class="line"><span class="title function_">fn</span>(fn);</span><br><span class="line"><span class="title function_">fn</span>(<span class="number">0</span>);</span><br><span class="line"><span class="title function_">fn</span>(<span class="literal">undefined</span>);</span><br></pre></td></tr></table></figure><p>关于类的知识就分享到这里啦，下一篇 分享 <code>TS</code> 中的 <strong><em>模块</em></strong> 的内容，不见不散！</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前 端 </tag>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript系列基础篇(四) 类型操纵</title>
      <link href="/articals/2d027281/"/>
      <url>/articals/2d027281/</url>
      
        <content type="html"><![CDATA[<h1 id="TypeScript-系列基础篇-四-类型操纵"><a href="#TypeScript-系列基础篇-四-类型操纵" class="headerlink" title="TypeScript 系列基础篇(四) 类型操纵"></a>TypeScript 系列基础篇(四) 类型操纵</h1><p>定义一个类型，我们通常使用<strong><code>interface</code></strong>和 <strong><code>type</code></strong>关键字来进行规定，有时候也会直接使用字面量类型，这些过程足以应付大部分场景。但是有些时候，我们希望掌握<strong>从已经存在的值或者类型中提取或派生出新的类型</strong>的技巧，这就是我们今天要来了解的<strong><code>Type Manipulation</code> 类型操纵</strong>。相信我，掌握这些技巧后，你也能被各种类型玩出百般花样。</p><h2 id="一、使用-keyof-操作符"><a href="#一、使用-keyof-操作符" class="headerlink" title="一、使用 keyof 操作符"></a>一、使用 <strong><em><code>keyof</code></em></strong> 操作符</h2><p>使用 <strong><code>keyof</code></strong> 操作符，可以获取一个 <strong>对象类型</strong> 的属性名 (字符串或者数值)，并将其组合成一个联合类型。注意得到的是一个类型，因此<strong>应使用<code>type</code>关键字</strong>，而不能使用<code>var</code>, <code>let</code>, <code>const</code>等声明值变量的关键字。</p><ul><li>一般情况下，<code>keyof</code>操作会得到字面量联合类型；</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Person类型有三个属性，属性名分别为&quot;name&quot;,&quot;age&quot;,100</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="number">100</span>: <span class="built_in">string</span>[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对Person类型使用keyof操作符，可以将其属性名组合成一个字面量联合类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NewType</span> = keyof <span class="title class_">Person</span>; <span class="comment">// NewType为 &quot;name&quot; | &quot;age&quot; | 100</span></span><br></pre></td></tr></table></figure><ul><li><p>如果被操作的对象类型有着<code>string</code>类型或者<code>number</code>类型的<strong>索引签名</strong>，那么<code>keyof</code>操作会得到<code>string</code>或者<code>number</code>类型，而不是字面量类型。</p><ul><li><code>number</code>类型的索引签名，<code>keyof</code>会得到 <code>number</code> 类型；</li><li><code>string</code>类型的索引签名，<code>keyof</code>会得到 <code>string | number</code> 类型；</li></ul></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 索引签名规定索引必须为number类型，属性值是string类型</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  [<span class="attr">x</span>: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Type1为number类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Type1</span> = keyof <span class="title class_">Person</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是如果是string类型的索引签名</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">People</span> &#123;</span><br><span class="line">  [<span class="attr">x</span>: <span class="built_in">string</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Type2为 string | number</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Type2</span> = keyof <span class="title class_">People</span>;</span><br></pre></td></tr></table></figure><p>由于<code>JavaScript</code>中对象的 <code>key</code> 会被强制转换成 <code>string</code> 类型。因此，我们即使用数值型的<code>key</code>，最后也等同于转化之后的字符串 <code>key</code> ，<strong>即 <code>obj[0]</code> 和 <code>obj[&quot;0&quot;]</code> 完全一样</strong>。因此，<strong><code>string</code>类型的索引签名，对象实例可以由 <code>number</code> 类型的<code>key</code>，因为会被强制转化为<code>string</code>。所以<code>keyof</code>操作得到的是 <code>string | number</code>类型</strong>。</p><h2 id="二、使用-typeof-操作符"><a href="#二、使用-typeof-操作符" class="headerlink" title="二、使用 typeof 操作符"></a>二、使用 <em><code>typeof</code></em> 操作符</h2><p>在<code>JavaScript</code>中，<strong><code>typeof</code></strong>操作符常用于基本数据类型的判断。而<code>TS</code>在类型上下文中也加入了 <strong><code>typeof</code></strong> 操作符，用于获取一个变量或属性的类型。不同于我们平常的用法，当<code>typeof</code>出现在类型上下文中时，得到的类型也可以是一个对象类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;cc&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> T = <span class="keyword">typeof</span> a; <span class="comment">// T为number</span></span><br><span class="line"><span class="keyword">type</span> K = <span class="keyword">typeof</span> obj.<span class="property">name</span>; <span class="comment">// K为string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> U = <span class="keyword">typeof</span> obj; <span class="comment">// U为 &#123;name: string, age: number&#125;</span></span><br></pre></td></tr></table></figure><p><strong><code>typeof</code></strong>用在这些简单类型的值上，不得不说有点累赘。但是对于复杂类型的值，用<code>typeof</code>就可以很方便地表达多种类型。例如，可以用<code>TS</code>提供的泛型类型<strong><code>ReturnType</code></strong>来获取一个<strong>函数类型</strong>的<strong>返回值的类型</strong>(指定<code>ReturnType</code>的类型参数为某个函数类型，得到该函数类型的返回值的类型)。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛型函数类型表达式，设置泛型类型参数默认值</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Fn</span>&lt;T = <span class="built_in">number</span>&gt; = <span class="function">(<span class="params">x: T</span>) =&gt;</span> T;</span><br><span class="line"><span class="comment">// 不指定类型参数，则泛型T为number</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Type1</span> = <span class="title class_">ReturnType</span>&lt;<span class="title class_">Fn</span>&gt;; <span class="comment">// Type1为number</span></span><br><span class="line"><span class="comment">// 指定泛型类型参数T为string</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Type2</span> = <span class="title class_">ReturnType</span>&lt;<span class="title class_">Fn</span>&lt;<span class="built_in">string</span>&gt;&gt;; <span class="comment">// Type2为string</span></span><br></pre></td></tr></table></figure><p>注意 <strong><code>ReturnType</code></strong> 接收的泛型类型参数应该是一个类型，而不是一个值。在类型上下文中可以使用<code>typeof</code>关键字将通过<strong>表示值的变量或属性</strong>来表达一个类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fn是&quot;值&quot;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">a: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 错误，ReturnType的泛型类型参数应该是一个类型，而不是一个值</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Type1</span> = <span class="title class_">ReturnType</span>&lt;fn&gt;;</span><br><span class="line"><span class="comment">// 使用typeof 关键字表达fn的类型, ok</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Type2</span> = returnType&lt;<span class="keyword">typeof</span> fn&gt;; <span class="comment">// Type2为number</span></span><br></pre></td></tr></table></figure><p>注意，<strong><code>typeof</code>关键字在类型上下文中，永远只能用于变量名和属性名后面</strong>。在平常用于判断类型时，则不受此限制。<strong>类型上下文</strong>：接收一个类型作为参数或者声明、表达、生成一个类型的上下文，如<code>interface</code>、<code>type</code>等关键字以及泛型参数的上下文。</p><h2 id="三、索引访问类型"><a href="#三、索引访问类型" class="headerlink" title="三、索引访问类型"></a>三、索引访问类型</h2><p>在<strong>对象实例</strong>中，我们可以通过索引来访问某个属性值。同样的，在<strong>对象类型</strong>中，我们也可以通过索引访问某个属性的类型，此时的索引应该是一个类型，而不是一个值，用方括号的形式接收该索引。索引可以是联合类型、字面量类型、类型别名、乃至<code>keyof</code>操作符表达的类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个对象类型</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过方括号索引获得某个属性的类型，索引为字面量类型&quot;name&quot;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Name</span> = <span class="title class_">Person</span>[<span class="string">&quot;name&quot;</span>]; <span class="comment">// name</span></span><br><span class="line"><span class="comment">// 错误，不可以用 . 的方式访问</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Age</span> = <span class="title class_">Person</span>.<span class="property">age</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 索引为字面量联合类型 &quot;name&quot; | &quot;age&quot;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NameOrAge1</span> = <span class="title class_">Person</span>[<span class="string">&quot;name&quot;</span> | <span class="string">&quot;age&quot;</span>]; <span class="comment">// string | number</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 索引为类型别名</span></span><br><span class="line"><span class="keyword">type</span> M = <span class="string">&quot;name&quot;</span> | <span class="string">&quot;age&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NameOrAge2</span> = <span class="title class_">Person</span>[M]; <span class="comment">// string | number</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 索引为用keyof表达的类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NameOrAge3</span> = <span class="title class_">Person</span>[keyof <span class="title class_">Person</span>]; <span class="comment">// string | number</span></span><br></pre></td></tr></table></figure><p>无法访问对象类型中没有的属性。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个对象类型</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 错误，Person类型中没有gender属性/方法</span></span><br><span class="line"><span class="keyword">type</span> T = <span class="title class_">Person</span>[<span class="string">&quot;gender&quot;</span>];</span><br></pre></td></tr></table></figure><p>前面说到，接收的索引应该是一个类型。所以，当我们的对象类型具有索引签名时，则也可以接收<strong><code>string</code></strong>、<strong><code>number</code></strong>。另外，在数组类型中，也可以用<code>number</code>作为索引来访问。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  [<span class="attr">x</span>: <span class="built_in">number</span>]: <span class="built_in">string</span>[];</span><br><span class="line">  [<span class="attr">x</span>: <span class="built_in">string</span>]: <span class="built_in">string</span>[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用number作为索引</span></span><br><span class="line"><span class="keyword">type</span> A = <span class="title class_">Person</span>[<span class="built_in">number</span>]; <span class="comment">// string[]</span></span><br><span class="line"><span class="comment">// 使用string作为索引</span></span><br><span class="line"><span class="keyword">type</span> B = <span class="title class_">Person</span>[<span class="built_in">string</span>]; <span class="comment">// string[]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;cc&quot;</span>];</span><br><span class="line"><span class="keyword">type</span> C = <span class="keyword">typeof</span> arr[<span class="built_in">number</span>]; <span class="comment">// number | string</span></span><br></pre></td></tr></table></figure><h2 id="四、条件类型"><a href="#四、条件类型" class="headerlink" title="四、条件类型"></a>四、条件类型</h2><p>类似我们常用的三元表达式，<strong>条件类型表达式</strong>：<strong><em><code>Type1 extends Type2 ? TrueType : FalseType</code></em></strong>；当<code>Type2</code>是<code>Type1</code>的子类型时，表达式得到<code>TrueType</code>，否则得到<code>FalseType</code>。这看起来好像没啥用，然而，</p><ul><li><strong>条件类型表达式的强劲之处在于用于泛型</strong>。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyType</span>&lt;T&gt; = T <span class="keyword">extends</span> &#123; <span class="attr">info</span>: <span class="built_in">unknown</span> &#125; ? T[<span class="string">&quot;info&quot;</span>] : <span class="built_in">never</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="title class_">MyType</span>&lt;&#123; <span class="attr">name</span>: <span class="built_in">string</span>; <span class="attr">info</span>: <span class="built_in">number</span> &#125;&gt;; <span class="comment">// a为number类型的值</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">b</span>: <span class="title class_">MyType</span>&lt;<span class="title class_">Array</span>&lt;<span class="built_in">string</span>&gt;&gt;; <span class="comment">// b为never类型的值</span></span><br></pre></td></tr></table></figure><p>对条件类型的泛型类型参数使用<code>extends</code>关键字可以约束其类型：</p><ul><li><strong>在条件类型中进行推论</strong></li></ul><p>在条件类型表达式的中使用 <strong><em><code>infer</code></em></strong>关键字推论泛型类型参数或函数类型的返回值的类型，并用一个形式类型指代，这个形式类型可用于条件类型表达式中指代推论得出的实际类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在条件类型表达式的Array泛型中使用infer关键字，</span></span><br><span class="line"><span class="comment">// 推论Array成员的类型为Item类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyType</span>&lt;<span class="title class_">Type</span>&gt; = <span class="title class_">Type</span> <span class="keyword">extends</span> <span class="title class_">Array</span>&lt;infer <span class="title class_">Item</span>&gt; ? <span class="title class_">Item</span> : <span class="title class_">Type</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="title class_">MyType</span>&lt;<span class="built_in">string</span>[]&gt;; <span class="comment">// a为string类型的变量</span></span><br></pre></td></tr></table></figure><ul><li><strong>分布式条件类型</strong></li></ul><p>当我们为泛型指定的类型参数为联合类型时，条件类型的作用会分布于联合类型的每一个单独的子类型上。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">GetArrType</span>&lt;T&gt; = T <span class="keyword">extends</span> <span class="built_in">any</span> ? T[] : <span class="built_in">never</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// T[]的作用会分布到strig和number上，形成string[] | number[]</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">StrOrNumArr</span> = <span class="title class_">GetArrType</span>&lt;<span class="built_in">string</span> | <span class="built_in">number</span>&gt;; <span class="comment">// string[] | number[]</span></span><br></pre></td></tr></table></figure><h2 id="五、映射类型"><a href="#五、映射类型" class="headerlink" title="五、映射类型"></a>五、映射类型</h2><h3 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1. 基本使用"></a>1. 基本使用</h3><p>映射类型是一种泛型，往往<strong>建立在索引签名之上</strong>，即以索引签名的形式，利用指定的泛型类型参数<code>T</code>的所有属性类型的联合(一般使用 <code>keyof</code> 关键字来遍历出<code>T</code>的所有属性类型)，作为新的对象类型的索引签名，并为其指定新的返回值类型。好吧，这太绕了。说白了，就是<strong>给对象类型 A 的所有属性/方法指定新的返回值的类型，从而得到一个新的对象类型</strong>。<strong>关键字 <code>in</code> 后面是一个与类型参数<code>T</code>有关的联合类型</strong>。还是有些绕？那就来看一个栗子吧：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">OptionsFlags</span>&lt;<span class="title class_">Type</span>&gt; = &#123;</span><br><span class="line">  <span class="comment">// 索引签名的形式，这里的Property时类型参数，可以随便命名,T、K啥的都可以</span></span><br><span class="line">  [<span class="title class_">Property</span> <span class="keyword">in</span> keyof <span class="title class_">Type</span>]: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们尝试定义一个对象类型</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">gender</span>: <span class="number">1</span> | <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将Person类型传递给OptionsFlag，得到新的类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NewType</span> = <span class="title class_">OptionsFlags</span>&lt;<span class="title class_">Person</span>&gt;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">NewType为 &#123;</span></span><br><span class="line"><span class="comment">  name: boolean,</span></span><br><span class="line"><span class="comment">  age: boolean,</span></span><br><span class="line"><span class="comment">  gender: boolean</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这下我们就能明白了，文字说再多都是虚的，还得是代码。通过映射类型的方式得到新的类型，新类型继承了所有原来的属性(包括方法)，并指定了新的返回值 (当然可以使用条件类型表达式)。</p><h3 id="2-映射修饰符"><a href="#2-映射修饰符" class="headerlink" title="2.映射修饰符"></a>2.映射修饰符</h3><p>既然已经了解了映射类型的基本使用，现在来看看有哪些类型修饰符，它们又分别是用来做什么的。在上一篇文章<a href="https://juejin.cn/post/7070434381013188615">今天来聊聊 TS 中的那些对象类型——TypeScript 系列：(三) 对象类型</a>中，我们了解了对象属性的属性修饰符 <code>?</code> 和 <code>readonly</code>，事实上，映射修饰符也是这两小只。</p><ul><li><p><strong><code>readonly</code> 修饰符</strong></p><p>我们知道，通过映射类型，我们可以继承原有对象类型的所有属性，并它们指定新的返回值的类型。那么，我们如何为新的对象类型的属性添加为只读属性呢？或者如果原有的类型中存在只读属性，如何在新的类型中移除只读限制呢？很简单，在签名的<code>[ ]</code> 之前使用 <strong><code>+readonly</code></strong> 、<strong><code>-readonly</code></strong> 号即可，+ 号也可以省略。</p></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Person类型中有只读</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">id</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义一个映射类型MapperA</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MapperA</span>&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]: <span class="built_in">string</span>[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给Mapper传入Person类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PeopleA</span> = <span class="title class_">MapperA</span>&lt;<span class="title class_">Person</span>&gt;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">PersonA为 &#123;</span></span><br><span class="line"><span class="comment">  name: string[],</span></span><br><span class="line"><span class="comment">  age: string[],</span></span><br><span class="line"><span class="comment">  readonly id: string[]</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 - 移除新类型id的readonly限制</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MapperB</span>&lt;T&gt; = &#123;</span><br><span class="line">  -<span class="keyword">readonly</span> [K <span class="keyword">in</span> keyof T]: <span class="built_in">string</span>[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PeopleB</span> = <span class="title class_">MapperB</span>&lt;<span class="title class_">Person</span>&gt;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">PeopleB为 &#123;</span></span><br><span class="line"><span class="comment">  name: string[],</span></span><br><span class="line"><span class="comment">  age: string[],</span></span><br><span class="line"><span class="comment">  id: string[]</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 + 给新的对象类型的所有属性添加只读限制</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MapperC</span>&lt;T&gt; = &#123;</span><br><span class="line">  +<span class="keyword">readonly</span> [K <span class="keyword">in</span> keyof T]: <span class="built_in">string</span>[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PeopleC</span> = <span class="title class_">MapperC</span>&lt;<span class="title class_">Person</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// + 号通常省略</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PeopleCC</span> = <span class="title class_">MapperC</span>&lt;<span class="title class_">Person</span>&gt;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">PeopleC、PeopleCC都为  &#123;</span></span><br><span class="line"><span class="comment">  readonly name: string[];</span></span><br><span class="line"><span class="comment">  readonly age: string[];</span></span><br><span class="line"><span class="comment">  readonly id: string[];</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>?</code> 可选修饰符</strong></li></ul><p>同样，在映射类型产生新类型时，可选修饰符也会保留。我们可以<strong>在签名的 <code>[ ]</code> 后用 <code>-?</code>来移除可选性</strong>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">NewType</span>&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]-?: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-key的重映射"><a href="#3-key的重映射" class="headerlink" title="3. key的重映射"></a>3. <code>key</code>的重映射</h3><p><strong>使用 <code>as</code> 可以在新的对象类型中对原有的 <code>key</code> 进行重映射</strong>。直接<code>show code</code>吧，来一道官方栗子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Getters</span>&lt;<span class="title class_">Type</span>&gt; = &#123;</span><br><span class="line">  <span class="comment">// 这句代码可以分为三个部分</span></span><br><span class="line">  [<span class="title class_">Property</span> <span class="keyword">in</span> keyof <span class="title class_">Type</span> <span class="keyword">as</span> <span class="string">`get<span class="subst">$&#123;Capitalize&lt;</span></span></span><br><span class="line"><span class="subst"><span class="string">    <span class="built_in">string</span> &amp; Property</span></span></span><br><span class="line"><span class="subst"><span class="string">  &gt;&#125;</span>`</span>]: <span class="function">() =&gt;</span> <span class="title class_">Type</span>[<span class="title class_">Property</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">gender</span>: <span class="number">1</span> | <span class="number">2</span>;</span><br><span class="line">  <span class="number">100</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">GetPerson</span> = <span class="title class_">Getters</span>&lt;<span class="title class_">Person</span>&gt;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">GetPerson为 &#123;</span></span><br><span class="line"><span class="comment">  getName: () =&gt; string;</span></span><br><span class="line"><span class="comment">  getAge: () =&gt; number;</span></span><br><span class="line"><span class="comment">  getGender: () =&gt; 1 | 2;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在上面的栗子中，我们把那句代码分为三个部分, “<code>as</code>“ 之前的<code>A</code>部分, “<code>as</code>“ ~ “<code>:</code>“ 之间的<code>B</code>部分，”<code>:</code>“之后的<code>C</code>部分。<code>A</code> 和 <code>C</code>两部分结合起来，就是我们之前了解到的映射类型。所以，难点在于理解 <code>B</code> 部分的内容。这里涉及到了<strong>模板字面量类型</strong>，类似与模板字符串，(下一节有详细介绍)。<strong><code>Capitalize</code></strong>是<code>TS</code>提供的首字母大写的泛型类型。类型参数<code>Property</code>指代<code>keyof</code>每一次遍历到的类型<code>Type</code>的<code>key</code>，使用 <code>as</code> 将 新的对象类型中对应的 <code>key</code> 重命名为 模板字面量类型 <code>get + Property</code>类型(即原来的对象类型的对应的<code>key</code>)中属于<code>string</code>类型的<code>key</code> (即排除<code>number</code>索引) 首字母大写的 。</p><p>还可以利用<code>TS</code>提供<strong><code>Exclude&lt;P, B&gt;</code>的泛型类型</strong>来排除 B 类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新类型中移除了&quot;kind&quot;属性</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">RemoveKindField</span>&lt;<span class="title class_">Type</span>&gt; = &#123;</span><br><span class="line">  [<span class="title class_">Property</span> <span class="keyword">in</span> keyof <span class="title class_">Type</span> <span class="keyword">as</span> <span class="title class_">Exclude</span>&lt;<span class="title class_">Property</span>, <span class="string">&quot;kind&quot;</span>&gt;]: <span class="title class_">Type</span>[<span class="title class_">Property</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>还记得一开始我们说的<strong>关键字 <code>in</code> 后面是一个与类型参数<code>T</code>有关的联合类型</strong>吗？事实上，这个联合类型不是仅仅只能用简单类型的联合，而可以是一切类型的联合，只需要通过 <code>as</code> 来把 <code>key</code> 重新映射为<code>string</code>或<code>number</code>或两者的字面量类型即可。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">EventConfig</span>&lt;<span class="title class_">Events</span> <span class="keyword">extends</span> &#123; <span class="attr">kind</span>: <span class="built_in">string</span> &#125;&gt; = &#123;</span><br><span class="line">  [E <span class="keyword">in</span> <span class="title class_">Events</span> <span class="keyword">as</span> E[<span class="string">&quot;kind&quot;</span>]]: <span class="function">(<span class="params">event: E</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面是一个官网的栗子。<code>Events</code>是一个具<code>kind</code>属性的对象类型的联合类型，<code>E</code>代表这个联合类型中的每一个具有<code>kind</code>属性的对象类型，也是新对象的<code>key</code>，通过<code>as</code> 关键字将 <code>E</code> 重映射为索引访问类型 <code>E[&quot;kind&quot;]</code>，也就是<code>string</code>类型。因此，最后得到的是一个 <code>key</code> 为<code>string</code>类型的方法签名(函数的调用签名)。</p><p>(不得不说，各种类型操纵方法结合起来，是真能玩出花来。虽然明白比尔写的是啥，但我这脑瓜子实在是设计不出来这么优雅的类型。)</p><h2 id="六、模板字面量类型"><a href="#六、模板字面量类型" class="headerlink" title="六、模板字面量类型"></a>六、模板字面量类型</h2><p>这是本文要分享的最后一种类型操纵方式了，毕竟没把泛型加进来讲，因为我之前的文章里介绍过了。</p><ul><li>利用字符串模板的形式，可以得到模板字面量类型。注意类型是用<code>type</code>来定义。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Name</span> = <span class="string">&quot;cc&quot;</span>; <span class="comment">// 类型，不是值，不要使用let、var、const等</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TemplateType</span> = <span class="string">`I am <span class="subst">$&#123;Name&#125;</span>`</span>; <span class="comment">// &#x27;I am cc&#x27;类型，不是值</span></span><br></pre></td></tr></table></figure><ul><li>如果模板用的类型是联合类型，则会分别对联合类型的每一个类型进行处理</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Name</span> = <span class="string">&quot;cc&quot;</span> | <span class="string">&quot;yy&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TemplateType</span> = <span class="string">`love<span class="subst">$&#123;Name&#125;</span>`</span>; <span class="comment">// &#x27;lovecc&#x27; | &#x27;loveyy&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>如果模板本身也是联合类型，则会分别对模板的每一个类型和使用的类型进行处理</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Name</span> = <span class="string">&quot;cc&quot;</span> | <span class="string">&quot;yy&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Gender</span> = <span class="number">1</span> | <span class="number">2</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TemplateType</span> = <span class="string">`love<span class="subst">$&#123;Name | Gender&#125;</span>`</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">则TemplateType为 lovecc | loveyy | love1 | love2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li>如果有多个模板，则是将每个模板的情况和其它模板的情况进行组合</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Name</span> = <span class="string">&quot;cc&quot;</span> | <span class="string">&quot;yy&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Gender</span> = <span class="number">1</span> | <span class="number">2</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Age</span> = <span class="number">18</span> | <span class="number">20</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TemplateType</span> = <span class="string">`<span class="subst">$&#123;Age&#125;</span>love<span class="subst">$&#123;Name | Gender&#125;</span>`</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">则TemplateType为</span></span><br><span class="line"><span class="comment">18lovecc | 18loveyy | 18love1 | 18love2</span></span><br><span class="line"><span class="comment"> | 20lovecc | 20loveyy | 20love1 | 20love2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li>用在函数签名中，才能体会到模版字面量类型有多强大</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">PropEventSource</span>&lt;<span class="title class_">Type</span>&gt; = &#123;</span><br><span class="line">  <span class="comment">// 调用签名，通过模板字面量类型指定了第一个参数的类型</span></span><br><span class="line">  <span class="title function_">on</span>(</span><br><span class="line">    <span class="attr">eventName</span>: <span class="string">`<span class="subst">$&#123;<span class="built_in">string</span> &amp; keyof Type&#125;</span>Changed`</span>,</span><br><span class="line">    <span class="attr">callback</span>: <span class="function">(<span class="params">newValue: <span class="built_in">any</span></span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line">  ): <span class="built_in">void</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>模板字面量类型的推论</li></ul><p>把<code>on( )</code>设计为泛型函数，使<code>TS</code>自己进行类型推论。不说了，都是泪。直接上官方示例代码吧。一层一层的泛型，不思考的话实在不容易看懂。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">PropEventSource</span>&lt;<span class="title class_">Type</span>&gt; = &#123;</span><br><span class="line">  on&lt;<span class="title class_">Key</span> <span class="keyword">extends</span> <span class="built_in">string</span> &amp; keyof <span class="title class_">Type</span>&gt;(</span><br><span class="line">    <span class="attr">eventName</span>: <span class="string">`<span class="subst">$&#123;Key&#125;</span>Changed`</span>,</span><br><span class="line">    <span class="attr">callback</span>: <span class="function">(<span class="params">newValue: Type[Key]</span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line">  ): <span class="built_in">void</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="七、内置的字符串操纵类型"><a href="#七、内置的字符串操纵类型" class="headerlink" title="七、内置的字符串操纵类型"></a>七、内置的字符串操纵类型</h2><h3 id="1-Uppercase-lt-StringType-gt"><a href="#1-Uppercase-lt-StringType-gt" class="headerlink" title="1. Uppercase &lt;StringType&gt;"></a>1. <code>Uppercase &lt;StringType&gt;</code></h3><p>产生一个<strong>将泛型类型（必须是字符串类型、字符串型的字面量类型）所有字母转化为大写</strong>的新类型。不改变原来的类型。如果是<code>string</code>类型而不是字面量类型，则生成的类型依然是<code>string</code>，不要求其值的首字母大写（一下几个内置方法都是如此）。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Name</span> = <span class="string">&quot;cc&quot;</span> | <span class="string">&quot;yy&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UpperName</span> = <span class="title class_">Uppercase</span>&lt;<span class="title class_">Name</span>&gt;; <span class="comment">// &#x27;CC&#x27; | &#x27;YY&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="2-Lowercase-lt-StringType-gt"><a href="#2-Lowercase-lt-StringType-gt" class="headerlink" title="2. Lowercase &lt;StringType&gt;"></a>2. <code>Lowercase &lt;StringType&gt;</code></h3><p>产生一个<strong>将泛型类型（必须是字符串类型、字符串型的字面量类型）所有字母转化为小写</strong>的新类型。不改变原来的类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Name</span> = <span class="string">&quot;CC&quot;</span> | <span class="string">&quot;YY&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UpperName</span> = <span class="title class_">Uppercase</span>&lt;<span class="title class_">Name</span>&gt;; <span class="comment">// &#x27;cc&#x27; | &#x27;yy&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="3-Capitalize-lt-StringType-gt"><a href="#3-Capitalize-lt-StringType-gt" class="headerlink" title="3. Capitalize &lt;StringType&gt;"></a>3. <code>Capitalize &lt;StringType&gt;</code></h3><p>产生一个<strong>将泛型类型（必须是字符串类型、字符串型的字面量类型）首字母转化为大写</strong>的新类型。不改变原来的类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Name</span> = <span class="string">&quot;cc&quot;</span> | <span class="string">&quot;yy&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UpperName</span> = <span class="title class_">Uppercase</span>&lt;<span class="title class_">Name</span>&gt;; <span class="comment">// &#x27;Cc&#x27; | &#x27;Yy&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="4-Uncapitalize-lt-StringType-gt"><a href="#4-Uncapitalize-lt-StringType-gt" class="headerlink" title="4. Uncapitalize &lt;StringType&gt;"></a>4. <code>Uncapitalize &lt;StringType&gt;</code></h3><p>产生一个<strong>将泛型类型（必须是字符串类型、字符串型的字面量类型）首字母转化为小写</strong>的新类型。不改变原来的类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Name</span> = <span class="string">&quot;CC&quot;</span> | <span class="string">&quot;YY&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UpperName</span> = <span class="title class_">Uppercase</span>&lt;<span class="title class_">Name</span>&gt;; <span class="comment">// &#x27;cC&#x27; | &#x27;yY&#x27;</span></span><br></pre></td></tr></table></figure><p>好了，本篇就到此为止了，各种类型已经把我玩出花来了。下一篇，我们将一起学习 <strong><code>class</code></strong> ，不见不散！</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前 端 </tag>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript 系列基础篇(三) 对象类型</title>
      <link href="/articals/364db865/"/>
      <url>/articals/364db865/</url>
      
        <content type="html"><![CDATA[<h1 id="TypeScript-系列基础篇-三-对象类型"><a href="#TypeScript-系列基础篇-三-对象类型" class="headerlink" title="TypeScript 系列基础篇(三) 对象类型"></a>TypeScript 系列基础篇(三) 对象类型</h1><p>对象是我们组织数据的基本方式。除了常规的对象类型外，TS 还提供了<strong>只读数组</strong>、<strong>元组</strong>、<strong>属性修饰符</strong>、<strong>索引签名</strong>等知识体系。在前面的章节中，我们已经了解到了对象的基本使用。可以用<strong>字面量</strong>、<strong><code>interface</code></strong>、<strong><code>type alias</code></strong>来规定一个普通的对象类型。现在是时候了解一下常用的对象属性修饰符、类型拓展、索引签名和内置的特殊对象类型了。 还没有对象吗？那就赶紧<code>new</code>一个吧！</p><h2 id="一、属性修饰符"><a href="#一、属性修饰符" class="headerlink" title="一、属性修饰符"></a>一、<mark>属性修饰符</mark></h2><p>利用属性修饰符，我们可以增强对象的属性的约束。</p><h3 id="1-可选属性"><a href="#1-可选属性" class="headerlink" title="1. ? 可选属性"></a>1. <code>?</code> 可选属性</h3><p>可选属性我们在之前就已经有所了解。定义对象类型时，在属性名后面加上英文问号 “<code>?</code>“ ，表示该属性可选。此后，该类型的对象里可以有这个属性，也可以没有。因此，该属性除了我们给它约束了的类型之外，还可能是<code>undefined</code>，从而引发某些问题。在之前的文章中提到过，这可以通过<strong>真值校验</strong>来进行类型缩减，或者给函数的形参设置默认值，从而解决。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其中gender为可选属性</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  gender?: <span class="number">1</span> | <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以有全部属性</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">cc</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;cc&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">gender</span>: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以缺失可选属性</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">yy</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;yy&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-readonly-只读属性"><a href="#2-readonly-只读属性" class="headerlink" title="2. readonly 只读属性"></a>2. <code>readonly</code> 只读属性</h3><p>在对象的某个或某些属性前加上关键字 <strong><code>readonly</code></strong>，可以设置该属性为只读属性。<strong>对象的只读属性在<code>TS</code>里一般不允许被重新赋值</strong>。只读属性不意味着完全不能修改。如果只读属性是一个对象类型，那我们可以修改它里面的成员。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// id为只读属性，不允许重新赋值</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">idInfo</span>: &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">addr</span>: <span class="built_in">string</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以有全部属性</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">cc</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;cc&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">idInfo</span>: &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="string">&quot;42xxxx199x04xxxx1X&quot;</span>,</span><br><span class="line">    <span class="attr">addr</span>: <span class="string">&quot;Wuhan&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面这句会报错，因为cc的id信息被设置为只读属性，不可以被重新哦</span></span><br><span class="line">cc.<span class="property">idInfo</span> = &#123; <span class="attr">id</span>: <span class="string">&quot;xiao cai ji&quot;</span>, <span class="attr">addr</span>: <span class="string">&quot;beijing&quot;</span> &#125;;</span><br><span class="line"><span class="comment">// 这样修改就可以啦</span></span><br><span class="line">cc.<span class="property">idInfo</span>.<span class="property">addr</span> = <span class="string">&quot;beijing&quot;</span>;</span><br></pre></td></tr></table></figure><p>然而事实上，在<code>TS</code>里我们依然有方法可以让只读属性被重新赋值。由于<code>TS</code>的类型检查机制，在检查两个对象类型是否兼容时，只针对类型，而不会去检测属性是否有 <code>readonly</code> 。例如，下面这两个对象类型是完全相互兼容的。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// id为只读属性，不允许重新赋值</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">idInfo</span>: &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">addr</span>: <span class="built_in">string</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 没有readonly属性，所有成员都可以被赋值</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">People</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">idInfo</span>: &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">addr</span>: <span class="built_in">string</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意Person的属性是只读的</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">person</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;gg&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">15</span>,</span><br><span class="line">  <span class="attr">idInfo</span>: &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="string">&quot;qaq&quot;</span>,</span><br><span class="line">    <span class="attr">addr</span>: <span class="string">&quot;zzZ&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 声明一个People类型的对象person，它的属性不是只读的</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">people</span>: <span class="title class_">People</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型兼容，具有只读属性的person可以被赋值给people</span></span><br><span class="line"><span class="comment">// 此时people是People类型，其属性可以修改；person是Person类型，其属性只读</span></span><br><span class="line"><span class="comment">// 熟悉JS引用类型的同学们都知道，people和person是同一个对象</span></span><br><span class="line">people = person;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改people的属性，我们发现person也会被相应修改，因为他们实际是同一个对象</span></span><br><span class="line">people.<span class="property">name</span> = <span class="string">&quot;pp&quot;</span>;</span><br><span class="line">people.<span class="property">age</span> = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p>从这个栗子中可以看到，我们可以通过一个<strong>不具有相应只读属性，且属性类型能够兼容</strong>的对象，来重写另一个对象的只读属性。因此，在<strong>使用只读属性时，一定要注意这种情况</strong>，以免引起超出意料的困扰。</p><h2 id="二、索引签名"><a href="#二、索引签名" class="headerlink" title="二、索引签名"></a>二、<mark>索引签名</mark></h2><p>在上一篇文章<a href="https://juejin.cn/post/7070172611849748517">TS 中的函数签名，函数重载，泛型函数，你都了解多少？Typescript 系列：(二)函数篇 </a>中，我们了解了函数签名。和这里的<strong>索引签名</strong>多多少少有些相像。</p><p>我们在使用<strong><code>interface</code></strong>或者<strong><code>type alias</code></strong>定义某个对象类型时，以往的做法是列举出所有的属性名并规定它们的值的类型。但是有时候，我们不知道对象里会有哪些属性，无法逐个列出。此时，我们可以使用<mark><strong>索引签名</strong></mark>，来<strong>规定属性名的类型</strong>和对应属性值的类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过索引签名，我们可以定义一个伪数组的</span></span><br><span class="line"><span class="comment">// 规定了属性名必须是number</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">StringArray</span> &#123;</span><br><span class="line">  [<span class="attr">index</span>: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意和真数组区分开来</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">strArr1</span>: <span class="title class_">StringArray</span> = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&quot;100分&quot;</span>,</span><br><span class="line">  <span class="number">5</span>: <span class="string">&quot;95分&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 报错，因为属性名grades不是number类型，不符合StringArray类型的约束</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">strArr2</span>: <span class="title class_">StringArray</span> = &#123;</span><br><span class="line">  <span class="attr">grades</span>: <span class="string">&quot;100分&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当我们使用<code>number</code>类型作为属性名时，<code>JS</code>在把他放进对象之前<strong>会先将其转化为<code>string</code>类型</strong>。索引签名可以和指定属性名,以及属性修饰符混合使用，此时，对象中必须包含列举出的属性(可选属性除外)，而且可拓展符合索引签名的约束的属性。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  [<span class="attr">x</span>: <span class="built_in">string</span>]: <span class="built_in">string</span>;</span><br><span class="line">  <span class="number">100</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="number">50</span>?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">cc</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="number">100</span>: <span class="string">&quot;满意100&quot;</span>,</span><br><span class="line">  <span class="number">6</span>: <span class="string">&quot;我是由索引签名拓展的属性&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">yy</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&quot;QAQ&quot;</span>,</span><br><span class="line">  <span class="number">100</span>: <span class="string">&quot;555~&quot;</span>,</span><br><span class="line">  <span class="number">50</span>: <span class="string">&quot;0.0&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>索引签名可以不止一套，但是<strong>各个索引签名的返回值应该互相兼容</strong>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  [<span class="attr">x</span>: <span class="built_in">string</span>]: <span class="built_in">string</span>;</span><br><span class="line">  [<span class="attr">y</span>: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以<strong>在索引签名的签名加上<code>readonly</code>关键字，使被签名的属性变为只读属性。</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> [<span class="attr">x</span>: <span class="built_in">number</span>]: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">cc</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="number">2</span>: <span class="string">&quot;cc&quot;</span>,</span><br><span class="line">  <span class="number">5</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="number">10</span>: <span class="string">&quot;boi&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="三、类型拓展"><a href="#三、类型拓展" class="headerlink" title="三、类型拓展"></a>三、<mark>类型拓展</mark></h2><p>我们可以从已有的对象类型的配置中，生成一个全新的类型，使其不仅含有原来类型的所有属性，还能拥有自己独有的属性。这样可以方便地实现类型复用，避免过多地重复敲代码，提高我们的工作效率。在定义新类型时，<strong>使用 <code>interface</code> 和 <code>type</code> 关键字，实现类型拓展的方式会有差别</strong>。</p><h3 id="1-类型继承"><a href="#1-类型继承" class="headerlink" title="1. 类型继承"></a>1. 类型继承</h3><p>使用<strong><code>interface</code></strong>关键字声明的对象类型，可以通过<strong><code>extends</code></strong>关键字来继承其它的对象类型，从而<strong>直接获得父类型的所有属性配置、属性签名，而不必重复列举一遍</strong>。<strong>可以同时继承多个对象类型</strong>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> B &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C类型继承A类型，包含name属性，不添加其它属性</span></span><br><span class="line"><span class="keyword">interface</span> C <span class="keyword">extends</span> A &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CC类型继承A，B类型，包含name, age, 以及自己列举的gender属性</span></span><br><span class="line"><span class="keyword">interface</span> CC <span class="keyword">extends</span> A, B &#123;</span><br><span class="line">  <span class="attr">gender</span>: <span class="number">1</span> | <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-类型交叉"><a href="#2-类型交叉" class="headerlink" title="2. 类型交叉"></a>2. 类型交叉</h3><p>通过<strong><code>type</code></strong>关键字给一个对象类型起<strong>别名</strong>时，使用 <code>&amp;</code> 符号来连接多个类型，从而产生一个新类型，新的类型包含所有其它对象类型的属性，即类型交叉。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> B &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类型CC包含name和age属性</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">CC</span> = A &amp; B;</span><br></pre></td></tr></table></figure><p>值得一提的是，如果 <code>&amp;</code> 连接的是简单联合类型，则产生的新类型是 <code>&amp;</code> 符号两边类型的公有类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">type</span> B = <span class="built_in">string</span>[] | <span class="built_in">number</span>;</span><br><span class="line"><span class="comment">// C是A和B共有的类型，number类型</span></span><br><span class="line"><span class="keyword">type</span> C = A &amp; B;</span><br></pre></td></tr></table></figure><p>这一点 和 <code>&amp;</code>在对象类型之间的使用看起来完全不同，起初我也有些疑惑。但是我们可以从本质上来思考，就不再有疑惑了。在关键字 type 定义的类型别名中，使用 <code>&amp;</code> 符号连接已有的类型可以产生一个新的类型，这个<strong>新类型需要同时满足 <code>&amp;</code> 符号两边的类型的约束</strong>。</p><p>因此，在<strong>对象类型的栗子</strong>中，新类型<code>CC</code>既需要满足<code>A</code>类型的约束 (因此<code>CC</code>必须有<code>A</code>的所有属性)，又必须满足类型 B 的约束 (因此必须含有类型 B 的所有属性)，即<code>CC</code>具有<code>A</code>和<code>B</code>的所有属性。</p><p>而在<strong>简单联合类型</strong>的栗子中，新类型<code>C</code>既要满足 A 的类型约束 (要么<code>C</code>是<code>number</code>, 要么是<code>string</code>)，又要满足类型<code>B</code>的约束 (要么<code>C</code>是字符串数组<code>string[]</code>，要么是<code>number</code>)，因此最终得到的<code>C</code>是<code>number</code>。</p><h2 id="四、泛型对象"><a href="#四、泛型对象" class="headerlink" title="四、泛型对象"></a>四、<mark>泛型对象</mark></h2><p><strong>泛型</strong>：使用尖括号<code>&lt;&gt;</code>来声明类型参数 (可以有多个)来表示暂时未知的类型，在实际声明变量时传入相应的类型 (或者由<code>TS</code>自动推论) 来替换相应出现该类型参数的地方，从而将抽象的、未知的类型替换为具体的、已知的类型。一个类型参数指代一种类型，例如<code>&lt;T,K,U,...&gt;</code>分别指代一种暂时未知的类型。将泛型用于定义对象类型，便得到了<strong>泛型对象</strong>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型T代表一种暂时未知的类型</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">PersonInfo</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">info</span>: T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 传入类型变量string，这时候string就会在相应的地方替换原来的T</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">p1</span>: <span class="title class_">PersonInfo</span>&lt;<span class="built_in">string</span>&gt; = &#123;</span><br><span class="line">  <span class="attr">info</span>: <span class="string">&quot;cc&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">p2</span>: <span class="title class_">PersonInfo</span>&lt;<span class="built_in">number</span>&gt; = &#123;</span><br><span class="line">  <span class="attr">info</span>: <span class="number">18</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">p3</span>: <span class="title class_">PersonInfo</span>&lt;<span class="string">&quot;男&quot;</span> | <span class="string">&quot;女&quot;</span>&gt; = &#123;</span><br><span class="line">  <span class="attr">info</span>: <span class="string">&quot;男&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>泛型对象常用于泛型函数，可参考<a href="https://juejin.cn/post/7070172611849748517">TS 中的函数签名，函数重载，泛型函数，你都了解多少？Typescript 系列：(二)函数篇</a>。</p><p><strong>泛型同样可在类型别名中使用</strong>。而类型别名除了定义对象类型之外，还能用泛型来定义各种其它类型。因此，我们可以<strong>使用泛型嵌套来定义更为复杂的类型结构</strong> (孩子已经哭了，难怪都说，玩会了泛型，<code>TS</code>就学完了一半)。本文主要介绍对象类型，关于泛型，以后再专门介绍。如下是官网的一个栗子。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">OrNull</span>&lt;<span class="title class_">Type</span>&gt; = <span class="title class_">Type</span> | <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">OneOrMany</span>&lt;<span class="title class_">Type</span>&gt; = <span class="title class_">Type</span> | <span class="title class_">Type</span>[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">OneOrManyOrNull</span>&lt;<span class="title class_">Type</span>&gt; = <span class="title class_">OrNull</span>&lt;<span class="title class_">OneOrMany</span>&lt;<span class="title class_">Type</span>&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">OneOrManyOrNullStrings</span> = <span class="title class_">OneOrManyOrNull</span>&lt;<span class="built_in">string</span>&gt;;</span><br></pre></td></tr></table></figure><h2 id="五、数组类型"><a href="#五、数组类型" class="headerlink" title="五、数组类型"></a>五、数组类型</h2><p>我们知道，数组是一种特殊的对象类型。上面简单了解了下泛型，那么我们现在就能知道，原来所谓数值数组、字符串数组等 (<code>number[]</code>，<code>string[]</code> )是泛型数组<code>Array&lt;number&gt;</code>，<code>Array&lt;string&gt;</code>的简写。现代<code>JS</code>也提供了其它新类型的泛型结构，如<code>Map&lt;T, K&gt;</code>，<code>Set&lt;T&gt;</code>，<code>Promise&lt;T&gt;</code>等，类型参数的数量都取决于各类型的自身行为表现。</p><h3 id="1-ReadonlyArray-只读数组"><a href="#1-ReadonlyArray-只读数组" class="headerlink" title="1. ReadonlyArray 只读数组"></a>1. <code>ReadonlyArray</code> 只读数组</h3><p>只读数组是<code>TS</code>提供的一种特殊的数组，它的任何成员都不能被修改。</p><ul><li>无法进行新增、删除、替换等操作，<code>push</code>、<code>pop</code>等修改自身的方法都无法使用。</li><li>可以使用不修改自身的数组方法。例如使用<code>slice</code>方法，返回一个普通的数组</li><li>代表一种类型，无法当作构造函数使用，不能使用<code>new</code>操作符。</li><li>在声明一个只读数组类型的变量时需指定类型参数，只读数组里只能存放该类型的值。</li><li>只读数组类型的变量本身可以接收普通数组的赋值。</li><li>普通数组不能接收只读数组的赋值</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定类型参数number，即该只读数组里只</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="title class_">ReadonlyArray</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">123</span>];</span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line">a.<span class="title function_">pop</span>();</span><br><span class="line"><span class="comment">// 可以使用slice方法</span></span><br><span class="line"><span class="keyword">let</span> cc = a.<span class="title function_">slice</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该变量可以用普通重新赋值</span></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">let</span> val = <span class="keyword">new</span> <span class="title class_">ReadonlyArray</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">aa</span>: <span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">456</span>];</span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line">aa = a;</span><br></pre></td></tr></table></figure><h3 id="2-Tuple-Types-元组"><a href="#2-Tuple-Types-元组" class="headerlink" title="2. Tuple Types 元组"></a>2. <code>Tuple Types</code> 元组</h3><p><mark><strong>元组</strong></mark>类型是另一种特殊的数组类型，<strong>一般来说</strong>它可以存储不同类型的成员，<strong>限定了数组的长度及每个成员的类型</strong>。(<strong>普通数组也可以通过指定联合类型的类型参数，从而存放不同类型的成员)</strong>。元组的成员是可以被修改，可以调用一系列的数组方法。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">UserInfo</span> = [<span class="built_in">string</span>, <span class="built_in">number</span>, <span class="number">1</span> | <span class="number">2</span>];</span><br></pre></td></tr></table></figure><p>这里得<code>UserInfo</code>便是一个元组类型，规定了元组里<strong>有且仅有</strong>三个成员，索引为<code>0</code>的成员是<code>string</code>类型，索引为<code>1</code>的成员是<code>number</code>类型，索引为<code>2</code>的成员 是字面量联合类型 <code>1 | 2</code> 。</p><ul><li>元组类型可以被解构。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">introduceUser</span>(<span class="params">info: UserInfo</span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [name, age, gender] = info;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`我是<span class="subst">$&#123;name&#125;</span>，今年<span class="subst">$&#123;age&#125;</span>岁啦`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>元组也可以指定可选成员</strong>：</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第三个成员可选</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UserInfo</span> = [<span class="built_in">string</span>, <span class="built_in">number</span>, (<span class="number">1</span> | <span class="number">2</span>)?];</span><br></pre></td></tr></table></figure><ul><li>元组中可使用剩余参数，来<strong>指定某个或某些索引位置的成员的类型和其它成员的类型</strong>。此时，元组没有长度限制。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">FamilyMember</span> = <span class="built_in">string</span>[];</span><br><span class="line"><span class="comment">// 指定索引0处的类型为string，索引1处的类型为number，剩余类型为FamilyMember</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UserInfo1</span> = [<span class="built_in">string</span>, <span class="built_in">number</span>, ...<span class="title class_">FamilyMember</span>[]];</span><br><span class="line"><span class="comment">// 同理</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UserInfo2</span> = [<span class="built_in">string</span>, <span class="built_in">number</span>, ...<span class="title class_">FamilyMember</span>[], <span class="built_in">boolean</span>];</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UserInfo3</span> = [...<span class="title class_">FamilyMember</span>[], <span class="built_in">string</span>, <span class="built_in">number</span>];</span><br></pre></td></tr></table></figure><ul><li><p><strong><code>readonly</code></strong> 只读元组类型</p><p>我们可以用类似 数组类型的简写方式 来声明一个只读元组：<strong><code>readonly [string, number]</code></strong>，使元组的成员变为只读成员，不可修改。<strong><code>readonly</code>关键字只能用于字面量数组或字面量元组类型之前，不可用于类型别名之前</strong>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ok</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">cc</span>: <span class="keyword">readonly</span> [<span class="built_in">string</span>, <span class="built_in">number</span>] = [<span class="string">&quot;cc&quot;</span>, <span class="number">18</span>];</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">yy</span>: <span class="keyword">readonly</span> <span class="title class_">UserInfo3</span> = [[<span class="string">&quot;dd&quot;</span>], <span class="string">&quot;1&quot;</span>, <span class="number">1</span>];</span><br><span class="line"><span class="comment">// 用于字面量元组之前，ok</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">yy</span>: <span class="keyword">readonly</span> [...<span class="title class_">FamilyMember</span>[], <span class="built_in">string</span>, <span class="built_in">number</span>] = [[<span class="string">&quot;dd&quot;</span>], <span class="string">&quot;1&quot;</span>, <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错，只读属性不可修改</span></span><br><span class="line">cc[<span class="number">0</span>] = <span class="string">&quot;yy&quot;</span>;</span><br></pre></td></tr></table></figure><p>此外，如果我们对数组使用<mark><strong>常量断言</strong></mark>：<strong><code>as const</code></strong>，该数组的类型也会变为只读元组。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> yy = [<span class="string">&quot;yy&quot;</span>, <span class="number">18</span>] <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错，只读属性不可修改</span></span><br><span class="line">yy[<span class="number">0</span>] = <span class="string">&quot;cc&quot;</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>ReadonlyArray</code>、<code>tuple</code>、<code>readonly tuple</code> 的主要区别。</p><ul><li><code>ReadonlyArray</code> 只读数组：不可修改数组成员，不可增删改，不会为每个数组成员单独指定类型，可以被重新赋值；</li><li><code>tuple</code> 元组：一般指定了长度和各个成员的类型，使用剩余参数法来声明元组类型时则没有限制长度；元组可以修改成员的值；可以被重新赋值；</li><li><code>readonly tuple</code>：一般指定了长度和各个成员的类型，使用剩余参数法来声明元组类型时则没有限制长度，不可修改成员的值，不可被重新赋值；</li></ul></li></ul><p>关于对象类型就先分享到这里啦。如果觉得我的文章有不妥之处，欢迎在评论区留言指正。下一期聊聊<strong>泛型</strong>，不见不散。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前 端 </tag>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typescript 系列基础篇(二) TS 中的函数</title>
      <link href="/articals/2d2f991a/"/>
      <url>/articals/2d2f991a/</url>
      
        <content type="html"><![CDATA[<h1 id="Typescript-系列基础篇-二-TS-中的函数"><a href="#Typescript-系列基础篇-二-TS-中的函数" class="headerlink" title="Typescript 系列基础篇(二) TS 中的函数"></a>Typescript 系列基础篇(二) TS 中的函数</h1><p>函数在我们日常代码中占有绝对重要的地位，深入了解 TS 中函数的使用对我们的学习十分有利。如果你还不了解<strong>泛型函数</strong>、<strong>函数签名</strong>、<strong>函数重载</strong>，那么阅读本文将让你对 TS 中的函数有一个更加细致的理解，必能有所收获。</p><h2 id="一、返回值"><a href="#一、返回值" class="headerlink" title="一、返回值"></a>一、返回值</h2><p>我们在声明一个函数 / 方法时，可以在括号后加上类型注释，以约束其返回值的类型，如果没有明确约束返回值的类型，则将其推论为 any 类型。<strong>除了<code>void</code>和<code>any</code>之外，其它所有的类型都应该有相应类型的返回值。</strong></p><ul><li>返回值如果不是约束的类型，或者约束了类型却没有<code>return</code>相应的类型，则会报错：</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明变量时由初始值&#x27;cc&#x27;进行类型推论，得出_name为string类型</span></span><br><span class="line"><span class="keyword">let</span> _name = <span class="string">&quot;cc&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会报错，约束了返回值的类型，却没有return相应的类型,</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getName1</span>(<span class="params"></span>): <span class="built_in">string</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 约束了返回值类型只能时string</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getName1</span>(<span class="params"></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> _name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个number类型的变量_name2</span></span><br><span class="line"><span class="keyword">let</span> _name2 = <span class="number">18</span>;</span><br><span class="line"><span class="comment">// 约束函数返回值类型为string</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getName2</span>(<span class="params"></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="comment">// 会报错，返回值应该是string类型，而_name2是number类型</span></span><br><span class="line">  <span class="keyword">return</span> _name2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当我们<strong>实际的返回值有可能不是约束的类型时</strong>，也是不正确的：</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">_name3</span>: <span class="built_in">string</span> | <span class="built_in">number</span> = <span class="string">&quot;cc&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getName3</span>(<span class="params"></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="comment">// 不合法的返回值，因为_name3有可能是number类型，而返回值只能是string类型</span></span><br><span class="line">  <span class="keyword">return</span> _name3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这种情况<strong>尤其容易发生在字面量类型上</strong>：</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// _name4经类型推论判定为string类型</span></span><br><span class="line"><span class="keyword">let</span> _name4 = <span class="string">&quot;cc&quot;</span>;</span><br><span class="line"><span class="comment">// 约束返回值只能为 &#x27;cc&#x27; | &#x27;yy&#x27; 类型</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getName4</span>(<span class="params"></span>): <span class="string">&quot;cc&quot;</span> | <span class="string">&quot;yy&quot;</span> &#123;</span><br><span class="line">  <span class="comment">// 会报错，虽然_name4的值为&#x27;cc&#x27;，但它是string类型，不符合要求</span></span><br><span class="line">  <span class="comment">// return _name4</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 可以用类型断言来解决，后面我们将介绍类型缩减来解决</span></span><br><span class="line">  <span class="keyword">return</span> _name4 <span class="keyword">as</span> <span class="string">&quot;cc&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数的返回值为空时，使用<code>void</code>类型，此时可以<code>return undefined</code>，<code>return null</code>，也可以不写<code>return</code>，会默认返回<code>undefined</code>：</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> _name = <span class="string">&quot;cc&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回空值undefined</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setName</span>(<span class="params">name</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  _name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="title function_">setName</span>(<span class="string">&quot;yy&quot;</span>); <span class="comment">// a为undefined</span></span><br></pre></td></tr></table></figure><h2 id="二、参数"><a href="#二、参数" class="headerlink" title="二、参数"></a>二、参数</h2><p>在<code>TS</code>中我们往往需要对函数的参数添加类型注释，如果不添加类型注释，则该参数将被类型推论为<code>any</code>。<code>TS</code>不仅约束了传参时实参的类型，也约束了在函数内部形参的类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> _name = <span class="string">&quot;cc&quot;</span>;</span><br><span class="line"><span class="comment">// 定义一个接收string类型，无返回值的函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setName2</span>(<span class="params">name: <span class="built_in">string</span></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  _name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时候，我们的参数比较复杂，例如多种类型的组合：<code>string | number</code>，这时候我们需要进行<strong>类型缩减</strong>，以防在<code>return</code>或参数调用方法等情况下出现问题。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> _name = <span class="string">&quot;cc&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setName3</span>(<span class="params">name: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="comment">// 参数name有可能是number，因此不能直接赋值</span></span><br><span class="line">  _name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setName3</span>(<span class="params">name: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="comment">// name是string类型</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> name === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">    _name = name;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// name是number类型，可强制转化</span></span><br><span class="line">    _name = <span class="title class_">String</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时候，某个参数不是必须传的，就可以在形参后加上英文问号”<code>?</code>“来表示<strong>可选参数</strong>，如果调用函数时不传该参数，则该参数为<code>undefined</code>。因此，在函数体内部，该参数有可能是<code>undefined</code>，也需要进行类型缩减。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">userInfo</span>: &#123; <span class="attr">name</span>: <span class="built_in">string</span>; <span class="attr">age</span>: <span class="built_in">number</span>; <span class="attr">gender</span>: <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setUserInfo</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span>, gender?: <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (gender === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    userInfo.<span class="property">gender</span> = <span class="number">3</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    userInfo.<span class="property">gender</span> = gender;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、函数类型表达式"><a href="#三、函数类型表达式" class="headerlink" title="三、函数类型表达式"></a>三、函数类型表达式</h2><p>TS 中可以使用箭头函数的形式来定义一个函数类型：<strong><code>(a: Type1, b: Type2, ...) =&gt; TypeN</code></strong>表示<strong>接收的参数名称为<code>a</code>, <code>b</code> , …，类型分别为<code>Type1</code>, <code>Type2</code>,…，返回值类型为<code>TypeN</code>的函数。</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义了类型Fn1是一个函数，接收一个string类型的name和number类型的age为参数，</span></span><br><span class="line"><span class="comment">// 返回一个sttring类型的值</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Fn1</span> = <span class="function">(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给fn1添加Fn1类型，则参数和返回值都需要满足Fn1的约束</span></span><br><span class="line"><span class="comment">// 已经由Fn1约束了类型，因此无需再对参数和返回值进行类型注释</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">fn1</span>: <span class="title class_">Fn1</span> = <span class="keyword">function</span> (<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;I am&quot;</span> + name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以使用箭头函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">fn11</span>: <span class="title class_">Fn1</span> = <span class="function">(<span class="params">name, age</span>) =&gt;</span> <span class="string">&quot;I am&quot;</span> + name;</span><br></pre></td></tr></table></figure><p>在声明对象的方法时，可以很方便地使用函数类型表达式：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个User接口，其中包含interest方法，需要传入一个string类型的参数，</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">interest</span>: <span class="function">(<span class="params">something: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">user</span>: <span class="title class_">User</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;cc&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="title function_">interest</span>(<span class="params">something</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="四、类型缩减"><a href="#四、类型缩减" class="headerlink" title="四、类型缩减"></a>四、类型缩减</h2><p>在函数中，我们会经常遇到形参是组合类型或可选参数的情况，这时候我们就需要进行类型缩减，对该参数的类型抽丝剥茧，从而在每个具体的子类型时做相应的操作，防止类型出错。在该过程中，越往后该参数可能的类型范围就越小。</p><p>主要有 <strong>控制流分析</strong>：<code>if-else</code> 或 <code>switch-case</code> 。</p><h3 id="一-控制流分析"><a href="#一-控制流分析" class="headerlink" title="(一) 控制流分析"></a>(一) 控制流分析</h3><p>通过 if，else 等控制流语句来逐步缩减参数的类型范围。</p><ul><li><strong><code>typeof</code></strong> 类型守卫</li></ul><p>在下面的例子中，我们使用了<strong><code>typeof</code></strong> 这个 <strong><code>type gurads</code></strong> 类型守卫，<code>typeof</code>会返回一些列固定的字符串，我们根据这些字符串来减少类型范围。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Fn</span> = <span class="function">(<span class="params">name?: <span class="built_in">string</span> | <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">fn</span>: <span class="title class_">Fn</span> = <span class="keyword">function</span> (<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="comment">// 类型缩减</span></span><br><span class="line">  <span class="keyword">if</span> (name === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;default name&quot;</span>;</span><br><span class="line">    <span class="comment">// 接下来只能是string或者number</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> name === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">    <span class="comment">// 接下来只能是number</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">String</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><code>typeof</code> 的返回值</strong>：</p><ol><li><p><strong>“<code>string</code>“</strong></p></li><li><p><strong>“<code>numbrt</code>“</strong></p></li><li><p><strong>“<code>bigint</code>“</strong></p></li><li><p><strong>“<code>boolean</code>“</strong></p></li><li><p><strong>“<code>symbol</code>“</strong></p></li><li><p><strong>“<code>undefined</code>“</strong></p></li><li><p><strong>“<code>object</code>“</strong></p></li><li><p><strong>“<code>function</code>“</strong></p></li></ol><p>可以看到，<strong><code>typeof</code>无法检测出<code>null</code></strong>这个空值，<code>typeof null</code>会返回”<code>object</code>“，因此，我们可以辅以“<code>truthiness</code>”检测进行真值校验。</p><ul><li><p><strong><code>Truthiness narrowing</code></strong> 真值校验</p><p>利用<code>true</code>和<code>false</code>来进行真值条件判断，从而达到类型缩减的目的。</p></li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Fn</span> = <span class="function">(<span class="params">name?: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">fn2</span>: <span class="title class_">Fn</span> = <span class="keyword">function</span> (<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="comment">// 真值校验</span></span><br><span class="line">  <span class="keyword">if</span> (name) &#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;default name&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>下面列举出使用 <code>if</code> 会得到 <code>false</code> 的值</strong>，根据官方文档的描述，除了以下列举的值之外，其它的值都会返回<code>true</code>。</p><ol><li><p><strong><code>0</code></strong></p></li><li><p><strong><code>NaN</code></strong></p></li><li><p><strong>“”</strong> 空字符串</p></li><li><p><strong><code>0n</code></strong> 数字<code>0</code> + 字母<code>n</code>，是<code>bigint</code>类型的 <code>0</code></p></li><li><p><strong><code>null</code></strong></p></li><li><p><strong><code>undefined</code></strong></p></li></ol><p>如果我们想把任何值转化为相应的<code>boolean</code>类型，可以利用布尔否定符”<code>!</code>“，任何值经过双重否定之后都会转化为相应的布尔值。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">!!<span class="number">0</span>; <span class="comment">// false</span></span><br><span class="line">!!<span class="title class_">NaN</span>; <span class="comment">// false</span></span><br><span class="line">!!<span class="string">&quot;&quot;</span>; <span class="comment">// false</span></span><br><span class="line">!!<span class="string">&quot;name&quot;</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li><p><strong><code>Equality narrowing</code></strong> 等值校验</p><p>利用已知条件进行等值校验，从而 TS 可以推断出相应的参数类型，达到类型缩减的目的。</p></li><li><p><strong><code>in</code> 操作符</strong></p><p>使用表达式 <strong><code>&quot;value&quot; in x</code></strong>，来判断对象里是否存在某个属性，来进行类型缩减。</p></li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Fish</span> = &#123;</span><br><span class="line">  <span class="attr">swim</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Dog</span> = &#123;</span><br><span class="line">  <span class="attr">bark</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params">obj: Fish | Dog</span>) &#123;</span><br><span class="line">  <span class="comment">// 有bark方法的则是Dog</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&quot;bark&quot;</span> <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;汪汪汪&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 否则是Fish</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;I am Fish&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>使用 <strong><code>instanceof</code></strong></p><p>用于<code>Array</code>，<code>Date</code>等引用类型。</p></li></ul><h3 id="二-类型预言"><a href="#二-类型预言" class="headerlink" title="(二) 类型预言"></a>(二) 类型预言</h3><p>想要定义一个自定义的类型守卫，我们通常可以使用一个返回值是类型预言的函数。</p><p>类型预言格式：<strong><code>param is Type</code></strong>，随后我们可以用该函数来进行类型缩减。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Fish</span> = &#123;</span><br><span class="line">  <span class="attr">swim</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Dog</span> = &#123;</span><br><span class="line">  <span class="attr">bark</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我可能不是人，才是真的狗</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isDog</span>(<span class="params">obj: Fish | Dog</span>): obj is <span class="title class_">Dog</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;bark&quot;</span> <span class="keyword">in</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">animal</span>: <span class="title class_">Fish</span> | <span class="title class_">Dog</span> = &#123;</span><br><span class="line">  <span class="attr">swim</span>: <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;I am Fish&quot;</span>),</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 进行类型缩减</span></span><br><span class="line"><span class="keyword">if</span> (<span class="title function_">isDog</span>(animal)) &#123;</span><br><span class="line">  animal.<span class="title function_">bark</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  animal.<span class="title function_">swim</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意如果<code>animal</code>的的方法不是<code>swim</code>而是<code>bark</code>，则<code>TS</code>将会进行类型推论，得到这个<code>animal</code>是<code>Dog</code>，便已经排除了<code>Fish</code>类型。此时，在我们的 if 分支里包含了<code>animal</code>是<code>Dog</code>的情况，而在<code>else</code>分支里 <code>animal</code> 就是<code>never</code>类型了。</p><h3 id="三-解析联合类型"><a href="#三-解析联合类型" class="headerlink" title="(三) 解析联合类型"></a>(三) 解析联合类型</h3><p>在上面的例子中，我们分析了一些较为简单的类型。但是实际上，稍微复杂些的类型也是非常常见的。在官方文档中，给了一个例子：我们定义一个用于表示形状的接口<code>Shape</code>，用 <code>kind</code> 属性来表示是圆形<code>circle</code>还是正方形<code>square</code>（字面量联合类型，防止单词拼写错误），圆形仅需要一个半径<code>radius</code>属性，正方形仅需要边长属性 <code>side_length</code>。因此我们使用可选属性，如果是<code>circle</code>，则有<code>radius</code>属性而没有<code>side_length</code>属性，反之同理。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">  <span class="attr">kind</span>: <span class="string">&quot;circle&quot;</span> | <span class="string">&quot;square&quot;</span>;</span><br><span class="line">  radius?: <span class="built_in">number</span>;</span><br><span class="line">  side?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们需要一个求面积的函数，参数为<code>Shape</code>类型。由于参数<code>radius</code>和<code>side</code>都是可选的，因此都可能为空值。按照常理，我们会根据 <code>kind</code> 属性的值来判断是圆形还是方形，从而使用不同的面积公式：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getArea</span>(<span class="params">obj: Shape</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj.<span class="property">kind</span> === <span class="string">&quot;circle&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 圆形面积，会报错，obj.radius可能是空的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">PI</span> * obj.<span class="property">radius</span> ** <span class="number">2</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 方形面积，会报错，obj.side可能是空的</span></span><br><span class="line">    <span class="keyword">return</span> obj.<span class="property">side</span> ** <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是此时你会发现，在严格空值检查下，这段代码会报错。因为<code>radius</code>和<code>side</code>都是可选属性，因此它们都可能为空值。当然，这里我们可以使用<strong>非空断言</strong>，但是也许我们可以用更合理的方式：给<code>circle</code>和<code>square</code>定义不同的接口，毕竟它们是两个完全不同的东西。此时我们的<code>getArea</code>函数就不会再出现上述的问题。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">  <span class="attr">kind</span>: <span class="string">&quot;circle&quot;</span>;</span><br><span class="line">  <span class="attr">radius</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Square</span> &#123;</span><br><span class="line">  <span class="attr">kind</span>: <span class="string">&quot;square&quot;</span>;</span><br><span class="line">  <span class="attr">side</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Shape</span> = <span class="title class_">Circle</span> | <span class="title class_">Square</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getArea</span>(<span class="params">obj: Shape</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj.<span class="property">kind</span> === <span class="string">&quot;circle&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 是Circle，必然有radius属性</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">PI</span> * obj.<span class="property">radius</span> ** <span class="number">2</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 是Square，必然有side属性</span></span><br><span class="line">    <span class="keyword">return</span> obj.<span class="property">side</span> ** <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过合理设计接口，能使问题得到更加优雅的解决方案。</p><h3 id="四-never-类型"><a href="#四-never-类型" class="headerlink" title="(四) never 类型"></a>(四) <code>never</code> 类型</h3><p>当我们进行类型缩减时，一旦所有可能的类型都被缩减完了，如果继续缩减，例如再加一个<code>else</code>分支，我们就会得到一个<strong><code>never</code></strong>类型。<code>TS</code>使用<code>never</code>类型来告诉我们，当前的情况是<code>tan ( Math.PI / 2 )</code>。<strong><code>never</code>类型可以被赋值给任意类型，但是任意其它类型都不能被赋值给<code>never</code>类型(除了<code>never</code>本身之外)</strong>。这个特性常用于穷举校验。</p><h3 id="五-穷举校验"><a href="#五-穷举校验" class="headerlink" title="(五) 穷举校验"></a>(五) 穷举校验</h3><p>我们在进行类型缩减时，有时候无法考虑到所有的情况。因此，可以使用穷举校验，为了避免有类型被遗漏。穷举校验利用了上述<code>never</code>类型的特性，在控制流的最后一个分支里，(如<code>switch</code>语句的<code>default</code>分支，<code>if</code> 语句末尾的<code>else</code>分支)，尝试把 进行类型缩减的参数 赋值给一个 <code>never</code> 类型的变量。由于只有<code>never</code>类型可以被赋值给<code>never</code>类型，一旦有我们考虑不周全，参数有类型遗漏了，那么在最后的分支里，该参数的类型就不会是<code>never</code>，无法被赋值给<code>never</code>类型的变量，<code>TS</code>便会报错来提示我们。而如果我们考虑完了所有的类型情况，则该参数在最后一个分支里便是<code>never</code>类型，可以被赋值给<code>never</code>类型的变量，<code>TS</code>就不会报错。因此，通过穷举检查的方式，我们只需要关注最后一个分支里是否有相应的报错，就能知晓我们是否考虑到了所有的类型情况。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">  <span class="attr">kind</span>: <span class="string">&quot;circle&quot;</span>;</span><br><span class="line">  <span class="attr">radius</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Square</span> &#123;</span><br><span class="line">  <span class="attr">kind</span>: <span class="string">&quot;square&quot;</span>;</span><br><span class="line">  <span class="attr">side</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Triangle</span> &#123;</span><br><span class="line">  <span class="attr">kind</span>: <span class="string">&quot;triangle&quot;</span>;</span><br><span class="line">  <span class="attr">side</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Shape</span> = <span class="title class_">Circle</span> | <span class="title class_">Square</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getArea</span>(<span class="params">obj: Shape</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj.<span class="property">kind</span> === <span class="string">&quot;circle&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 是Circle，必然有radius属性</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">PI</span> * obj.<span class="property">radius</span> ** <span class="number">2</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj.<span class="property">kind</span> === <span class="string">&quot;square&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 是Square，必然有side属性</span></span><br><span class="line">    <span class="keyword">return</span> obj.<span class="property">side</span> ** <span class="number">2</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 在最后一个分支进行穷举校验</span></span><br><span class="line">    <span class="keyword">const</span> <span class="attr">_isExhaustive</span>: <span class="built_in">never</span> = obj;</span><br><span class="line">    <span class="keyword">return</span> _isExhaustive;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、函数进阶"><a href="#五、函数进阶" class="headerlink" title="五、函数进阶"></a>五、函数进阶</h2><p>前面已经介绍了函数类型表达式，下面我们来了解下更多关于函数的知识。</p><h3 id="一-函数签名"><a href="#一-函数签名" class="headerlink" title="(一) 函数签名"></a>(一) 函数签名</h3><ol><li><mark><strong>调用签名</strong></mark></li></ol><p>函数也是一种对象，可以有自己的属性。但是使用函数类型表达式的时候无法同时声明函数的属性。<strong>调用签名描述了一种函数类型，包含了函数的属性、调用函数时应传递的参数以及返回值</strong>。使用调用签名可以很方便地解决函数类型表达式的不足。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明调用签名，调用签名是一种类型，其名字可以任意取</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">CallSignatureFn</span> = &#123;</span><br><span class="line">  <span class="comment">// 函数的属性</span></span><br><span class="line">  <span class="attr">grade</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="comment">// 函数的形参和返回值</span></span><br><span class="line">  (<span class="attr">arg1</span>: <span class="built_in">number</span>, <span class="attr">arg2</span>: <span class="built_in">string</span>): <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">logInfo</span>(<span class="params">fn: CallSignatureFn</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(fn.<span class="property">grade</span> + <span class="string">&quot; returned &quot;</span> + <span class="title function_">fn</span>(<span class="number">6</span>, <span class="string">&quot;A&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>调用签名 vs 函数类型表达式：</strong></p><ul><li>函数类型表达式十分简洁</li><li>调用签名可以声明函数的属性</li><li>调用前面在 参数列表 和 返回值 之间使用冒号 “<code>:</code>“ ，而函数类型表达式使用箭头 “<code>=&gt;</code>“</li></ul><ol><li><mark><strong>构造签名</strong></mark></li></ol><p>函数除了可以被直接调用之外，还可以使用 <strong><code>new</code></strong> 操作符来调用。构造签名描述了函数在使用 <code>new</code> 操作符调用时的传参和返回值。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ConstructSignatureFn</span> = &#123;</span><br><span class="line">  <span class="keyword">new</span> (<span class="attr">_type</span>: <span class="built_in">string</span>, <span class="attr">_num</span>: <span class="built_in">number</span>): <span class="built_in">string</span>[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">ctor: ConstructSignatureFn</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">ctor</span>(<span class="string">&quot;hello&quot;</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><mark><strong>混合签名</strong></mark></li></ol><p>对于有些比较特殊的函数比如<code>Date</code>，直接调用和使用<code>new</code>操作符调用得到的结果是一样的，这种函数类型可以使用混合签名，将调用签名和构造签名写在一个类型对象里。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">CallOrConstruct</span> &#123;</span><br><span class="line">  <span class="keyword">new</span> (<span class="attr">s</span>: <span class="built_in">string</span>): <span class="title class_">Date</span>;</span><br><span class="line">  (n?: <span class="built_in">number</span>): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><mark><strong>重载签名</strong></mark> 和 <mark><strong>实现签名</strong></mark></li></ol><p>将在<strong>函数重载</strong>章节介绍。</p><h3 id="二-泛型函数"><a href="#二-泛型函数" class="headerlink" title="(二) 泛型函数"></a>(二) 泛型函数</h3><ol><li><strong>基础</strong></li></ol><p>此前，我们在声明函数时，会直接给 <strong>形参</strong> 和 <strong>返回值</strong> 添加类型注释，在调用时传入相应类型的值。以这样的形式声明的函数，其传参和返回值的类型都是固定的。那有没有什么方式，能让我们调用函数时传参的类型能灵活多样呢？<strong>泛型函数</strong>正是我们想要的。</p><p><mark><strong>泛型函数</strong></mark>：高度抽象化的类型。在声明函数时将类型抽象化( 可以是多个类型 )：在函数名后面加上尖括号，里面为抽象化的类型名 (例如：<strong><code>&lt;T, K, U, ... &gt;</code>，其中 <code>T, K, U</code>是<mark>类型参数</mark>，各代表一种类型，至于具体是什么类型，在调用函数时由传入的类型决定。</strong>)，在调用函数时再具体化，传入实际的类型，一旦传入类型，所有出现该泛型的地方，都会替换为这个传入的类型。如果没有传入明确的类型，则<code>TS</code>会进行类型推论，自动判断<code>Type</code>的类型。(<code>T，K，U</code>等可以用任何你喜欢的词来替代，不过用这些字母会显得比较简洁。)</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;Type&gt;为泛型，Tpye任意代表一种类型，</span></span><br><span class="line"><span class="comment">// 在调用函数时，需要传入实际的类型，一旦传入类型，所有出现Type的地方都会替换</span></span><br><span class="line"><span class="keyword">function</span> firstElement&lt;<span class="title class_">Type</span>&gt;(<span class="attr">arr</span>: <span class="title class_">Type</span>[]): <span class="title class_">Type</span> | <span class="literal">undefined</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用函数时可以传入任意实际类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型推论判断Type为string</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="title function_">firstElement</span>([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]);</span><br><span class="line"><span class="comment">// 类型推论判断Type为number</span></span><br><span class="line"><span class="keyword">const</span> n = <span class="title function_">firstElement</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="comment">// 类型推论判断Type为undefined类型</span></span><br><span class="line"><span class="keyword">const</span> u = <span class="title function_">firstElement</span>([]);</span><br></pre></td></tr></table></figure><p>泛型的概念将类型进行了抽象化，使得函数可以在调用时传入需要的类型，从而增加了函数的通用性。泛型的名字 Type 可以随意取，注意相同的泛型代表着同一种类型。</p><ol><li><strong>泛型约束</strong></li></ol><p>我们知道，泛型可以定义多个，例如<code>&lt;Type1, Type2, ...&gt;</code>，每个泛型都代表着一种类型，它们可以相同，也可以不同，具体分别是什么类型，都由该函数调用时传入的类型来决定。然而，到目前为止，我们定义的泛型都是和其它类型无关的。很多时候，我们会希望给泛型做一定的约束，让它只能是某些类型之中的一种。这时候，可以使用<strong><code>extends</code></strong>关键字，来实现泛型约束。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 泛型T继承了Person类型，因此T必须有name和age属性</span></span><br><span class="line"><span class="keyword">function</span> getInfo&lt;T <span class="keyword">extends</span> <span class="title class_">Person</span>&gt;(<span class="attr">user</span>: T): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> user.<span class="property">name</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user1 = &#123; <span class="attr">age</span>: <span class="number">16</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> user2 = &#123; <span class="attr">name</span>: <span class="string">&quot;cc&quot;</span>, <span class="attr">age</span>: <span class="number">18</span>, <span class="attr">gender</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="comment">// 报错，user1中没有name属性，不符合类型要求</span></span><br><span class="line"><span class="title function_">getInfo</span>(user1);</span><br><span class="line"><span class="comment">// ok</span></span><br><span class="line"><span class="title function_">getInfo</span>(user2);</span><br></pre></td></tr></table></figure><ol><li><strong>指定类型参数</strong></li></ol><p>在前面的例子中，我们都没有手动传入类型，来指定泛型的实际类型，而是由<code>TS</code>自动进行类型推论得出的。有一说一，<code>TS</code>确实够机智。不过有些时候，由于泛型太抽象，仅仅靠<code>TS</code>的类型推论，可能无法得出正确的结果。这时候，我们可以在调用函数时手动传入类型，来指定类型参数。毕竟<strong>我们永远比<code>TS</code>知道的更多</strong>。下面来看一个官方的示例：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> combine&lt;<span class="title class_">Type</span>&gt;(<span class="attr">arr1</span>: <span class="title class_">Type</span>[], <span class="attr">arr2</span>: <span class="title class_">Type</span>[]): <span class="title class_">Type</span>[] &#123;</span><br><span class="line">  <span class="keyword">return</span> arr1.<span class="title function_">concat</span>(arr2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会报错，TS根据第一个参数数组[1,2,3]，将Type推论为number，</span></span><br><span class="line"><span class="comment">// 于是第二个字符串数组就无法通过类型校验, 因为Type[]此时应为number[]</span></span><br><span class="line"><span class="title function_">combine</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]);</span><br></pre></td></tr></table></figure><p>这种情况下，便需要指定参数类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = combine&lt;<span class="built_in">string</span> | <span class="built_in">number</span>&gt;([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="string">&quot;hello&quot;</span>]);</span><br></pre></td></tr></table></figure><ol><li><strong>三个小细节写好泛型函数</strong></li></ol><ul><li>尽可能少地使用泛型约束，让 TS 进行类型推论</li><li>尽可能少地使用类型参数</li><li>不要将没有重复使用的类型作为类型参数</li></ul><h3 id="三-函数重载"><a href="#三-函数重载" class="headerlink" title="(三) 函数重载"></a>(三) 函数重载</h3><ol><li><strong>函数的可选参数</strong></li></ol><p>在前面的类型缩减章节中，我们知道，函数可以有可选参数，调用函数时，如果没有给可选参数传值，那么该参数的值便是<code>undefined</code>, 这容易引发意想不到的错误。在函数中，我们可以通过<strong>真值校验</strong>来解决，也可以<strong>给参数一个默认值</strong>来解决 (同<code>JS</code>)。但是，如果一个函数的参数中有回调函数，且该<strong>回调函数也有可选参数，则尤其容易引发错误</strong>。偷个懒，继续搬运官方的栗子：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myForEach</span>(<span class="params">arr: <span class="built_in">any</span>[], callback: (arg: <span class="built_in">any</span>, index?: <span class="built_in">number</span>) =&gt; <span class="built_in">void</span></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 如果调用callback时没有传入index参数，则index为undefined</span></span><br><span class="line">    <span class="title function_">callback</span>(arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">myForEach</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function">(<span class="params">a, i</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 即此处的i为undefined，undefined上没有toFixed方法，便会报错</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i.<span class="title function_">toFixed</span>());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可见，使用可选参数不仅处理起来会有些麻烦，而且容易引发错误。因此，函数当有有限个不定数量或不同类型的参数时，更好的方案是<strong>函数重载</strong>。</p><ol><li><mark><strong>函数重载</strong></mark></li></ol><p>规定函数的形参与返回值的是<mark><strong>重载签名</strong></mark>，可以有多个重载签名；</p><p>兼容多个重载签名并进行逻辑处理的是<mark><strong>实现签名</strong></mark>，由于要兼容多套重载签名，因此会出现可选参数；</p><p>我们可以通过编写多套<strong>重载签名</strong>，来规定函数的不同调用方式 (传入不同数量或不同类型的参数以及不同类型的返回值)。然后通过<strong>实现签名</strong>来进行兼容的逻辑处理。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义两套重载签名</span></span><br><span class="line"><span class="comment">// 允许调用函数时只传入name参数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setUserInfo</span>(<span class="params">name: <span class="built_in">string</span></span>): <span class="built_in">boolean</span>;</span><br><span class="line"><span class="comment">// 允许调用函数时传入name, age, gender三个参数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setUserInfo</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span>, gender: <span class="number">1</span> | <span class="number">2</span></span>): <span class="built_in">string</span>;</span><br><span class="line"><span class="comment">// 实现签名，统一处理逻辑</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setUserInfo</span>(<span class="params">name: <span class="built_in">string</span>, age?: <span class="built_in">number</span>, gender?: <span class="number">1</span> | <span class="number">2</span></span>) &#123;</span><br><span class="line">  <span class="comment">// 真值校验，由于两套重载签名规定，调用函数时要么传入三个参数</span></span><br><span class="line">  <span class="comment">// 因此，传入了age，则必定也传入了gender</span></span><br><span class="line">  <span class="keyword">if</span> (age) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`我叫 <span class="subst">$&#123;name&#125;</span>, 今年 <span class="subst">$&#123;age&#125;</span> 岁啦！`</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入一个参数，正确</span></span><br><span class="line"><span class="title function_">setUserInfo</span>(<span class="string">&quot;cc&quot;</span>);</span><br><span class="line"><span class="comment">// 传入三个参数，正确</span></span><br><span class="line"><span class="title function_">setUserInfo</span>(<span class="string">&quot;cc&quot;</span>, <span class="number">18</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 传入两个参数，报错，因为没有定义两个参数的重载签名</span></span><br><span class="line"><span class="title function_">setUserInfo</span>(<span class="string">&quot;cc&quot;</span>, <span class="number">18</span>);</span><br></pre></td></tr></table></figure><p>可以看到，实现签名 和 我们之前普通地使用可选参数的处理很相似，区别也很明显：尽管<code>age</code>和<code>gender</code>都是可选参数，但是通过重载签名，规定了<code>age</code>和<code>gender</code>必须同时传入或同时都不传，即规定了该函数的调用只能传入一个或三个参数。如果不进行函数重载，那么将多出一种只传入<code>name</code>和<code>age</code>这两个参数的情况要进行处理。可见，通过函数重载来规定函数不同的调用方式，可以使逻辑与结构更加清晰优雅。当我们进行函数重载时，一定要<strong>注意让实现签名兼容所有的重载签名(参数和返回值都要兼容处理)</strong>。</p><h3 id="四-在函数中声明-this"><a href="#四-在函数中声明-this" class="headerlink" title="(四) 在函数中声明 this"></a>(四) 在函数中声明 this</h3><p>一般而言，<code>TS</code>会如同<code>JS</code>一样，自动推断 this 的指向。<code>JS</code>中不允许<code>this</code>作为参数，不过<code>TS</code>允许我们在函数中声明<code>this</code>的类型，这种情况尤其在函数的回调参数<code>callback</code>中较为常见。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filterUser个方法，其后是其调用签名</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">  <span class="title function_">filterUsers</span>(<span class="attr">filter</span>: <span class="function">(<span class="params"><span class="variable language_">this</span>: User</span>) =&gt;</span> <span class="built_in">boolean</span>): <span class="title class_">User</span>[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>起初这个官方的示例我看了好几分钟没看懂，后来发现它的<code>filterUsers</code>就是一个函数的调用签名，੯ੁૂ‧̀͡u\。这里声明了<code>this</code>是<code>User</code>类型，如果在该方法执行时，<code>callback</code>中的<code>this</code>不是<code>User</code>类型，<code>TS</code>就会提示我们代码写的有误。在函数中声明<code>this</code>时，需要注意一点是，虽然在构造签名中，<code>callback</code>使用箭头形式，但是<strong>在我们实际调用该方法时，<code>callback</code>不能使用箭头函数，只能用<code>function</code>关键字</strong>。毕竟众所周知，箭头函数没有自己作用域的<code>this</code>，它使用的的<code>this</code>同定义箭头函数时的上下文的 this。</p><h3 id="五-其它的类型"><a href="#五-其它的类型" class="headerlink" title="(五) 其它的类型"></a>(五) 其它的类型</h3><ul><li><p><strong><code>void</code></strong></p><p>函数的返回值设置为<code>void</code>，则返回空值。<strong><code>void</code>不等同于<code>undefined</code></strong>。</p><p>返回值为<code>void</code>类型的函数，并不一定不能写<code>return</code> 语句。<strong>如果是通过函数表达式、函数签名等定义的函数类型，该类型的实例函数体中可以有<code>return</code>语句，并且后面可以接任意类型的值，只不过它的返回值会被忽略</strong>。如果我们把这样的函数调用结果赋值给某个变量，则该变量的类型依然是<code>void</code>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> voidFunc = <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">f1</span>: voidFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 可以return任意类型的值，但是会被忽略</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// v1 的类型依然是void</span></span><br><span class="line"><span class="keyword">const</span> v1 = <span class="title function_">f1</span>();</span><br></pre></td></tr></table></figure><p>但是，<strong>如果是通过字面量声明函数的返回值为<code>void</code>，则函数体内不能有<code>return</code>语句</strong>。虽然官方文档里这么说，下面的栗子也摘自官方文档，但是我的<code>vs code</code>编辑器里这样写并没有报错 ？。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f2</span>(<span class="params"></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="comment">// @ts-expect-error</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> f3 = <span class="keyword">function</span> (<span class="params"></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="comment">// @ts-expect-error</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>object</code></strong></p><p>是小写的<code>object</code>，而不是大写的<code>Object</code>。这两者意义不同。</p></li><li><p><strong><code>unknown</code></strong></p></li><li><p><strong><code>never</code></strong></p><p>有的函数永远没有返回值，例如在函数体内 <code>return</code> 之前抛出错误。<code>never</code>类型也常用来做穷举校验。</p></li><li><p><strong><code>Funtion</code></strong></p><p>这些类型基本都在[# <code>Typescript</code>系列：基础篇(一)]<a href="https://juejin.cn/post/7069940384515751973">2022年了，了解一下 typescript系列：基础篇(一)？ - 掘金</a>介绍过了，此处不再赘述。</p></li></ul><h3 id="六-剩余参数"><a href="#六-剩余参数" class="headerlink" title="(六) 剩余参数"></a>(六) 剩余参数</h3><ul><li>我才发现，原来<strong><code>parameters</code>表示形参</strong>，<strong><code>arguments</code>表示实参</strong>。</li><li><strong>剩余形参</strong></li></ul><p>剩余形参的使用基本同<code>JS</code>一致，偷个懒直接拿官方栗子：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 倍乘函数，第一个参数为倍数，会返回后续所有参数各自乘以倍数而形成的数组</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">multiply</span>(<span class="params">n: <span class="built_in">number</span>, ...m: <span class="built_in">number</span>[]</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> m.<span class="title function_">map</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> n * x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a 的值</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="title function_">multiply</span>(<span class="number">10</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>剩余实参</strong></li></ul><p>剩余实参常用于函数调用时对传递的参数 (数组、对象等) 进行展开，然而这里容易踩坑。以数组为例：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">arr1.<span class="title function_">push</span>(...arr2);</span><br></pre></td></tr></table></figure><p>数组的<code>push</code>可以接收无限制个参数，因此可以直接展开参数<code>arr2</code>。但是有的方法只能接收指定数量的参数，而在一般情况下，<code>TS</code>认为数组的是可变的。如果直接对这类方法的进行数组参数的展开，会引起报错，因为<code>TS</code>会认为数组里的成员数量可能是<code>0</code>个或者多个，不符合该方法只接受指定数量的参数的要求。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 虽然数组现在只有两个成员，但是它的类型被推断为 number[]，</span></span><br><span class="line"><span class="comment">// 即args数组可能会发生变化，可能有0个或多个参数</span></span><br><span class="line"><span class="comment">// 而Math.atan2方法只接收两个参数，因此会报错</span></span><br><span class="line"><span class="keyword">const</span> args = [<span class="number">8</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> angle = <span class="title class_">Math</span>.<span class="title function_">atan2</span>(...args);s);</span><br></pre></td></tr></table></figure><p>解决的办法也很简单，使用 <strong><code>as const</code></strong>将数组的类型断言为不可变类型。此时的数组便被推论为元组类型。有关元组类型的内容，会在下一篇 <strong>对象类型篇</strong>中介绍。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此时args长度不可变，被推论为元组类型</span></span><br><span class="line"><span class="keyword">const</span> args = [<span class="number">8</span>, <span class="number">5</span>] <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line"><span class="comment">// ok</span></span><br><span class="line"><span class="keyword">const</span> angle = <span class="title class_">Math</span>.<span class="title function_">atan2</span>(...args);</span><br></pre></td></tr></table></figure><ul><li><strong>形参结构</strong></li></ul><p>没啥好说的，直接上官方示例。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">NumberABC</span> = &#123; <span class="attr">a</span>: <span class="built_in">number</span>; <span class="attr">b</span>: <span class="built_in">number</span>; <span class="attr">c</span>: <span class="built_in">number</span> &#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">&#123; a, b, c &#125;: NumberABC</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a + b + c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TS系列基础篇(一) TS类型指南</title>
      <link href="/articals/70f81d2c/"/>
      <url>/articals/70f81d2c/</url>
      
        <content type="html"><![CDATA[<h1 id="TS-系列基础篇-一-TS-类型指南"><a href="#TS-系列基础篇-一-TS-类型指南" class="headerlink" title="TS 系列基础篇(一) TS 类型指南"></a>TS 系列基础篇(一) TS 类型指南</h1><p>这段时间以来，TS 的发展可谓是如日中天，本想偷个懒去看看别人写的分享贴来学习，找了近十篇之后，发现要么是比较浅显，要么有些偏差，没有找到很满意的。于是决定去看<a href="https://www.typescriptlang.org/docs/handbook/declaration-files/consumption.html#consuming">官方文档</a>。学习了一段时间后，准备写一个系列，从基础类型，对象，函数，模块等 TS 知识，到在<code>vue</code>、<code>react</code>中的应用，供有需要的同学们参考。其中，我套用了不少官方文档的示例，觉得我的学习经验不好或不正确的朋友，欢迎批评指正。</p><p><code>TS</code>是<code>JS</code>的超集。在学 TS 之前，最好有一定的<code>JS</code>基础。本篇只介绍<code>typescript</code>的安装和各种基础类型。需要了解其它内容的同学可以看其它篇章或查阅官方文档。</p><p>[toc]</p><h2 id="一-、安装与编译"><a href="#一-、安装与编译" class="headerlink" title="(一)、安装与编译"></a>(一)、安装与编译</h2><p>想要使用<code>TS</code>，得先会安装。Typescript 需要<code>node</code>环境，确保你已经安装了<code>node</code>。如果还没有安装<code>node</code>，可以去<a href="[`Node.js`](https://nodejs.org/zh-cn/"><code>Node.js</code>官网</a>下载，傻瓜式安装。</p><p>打开项目目录进行初始化：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init <span class="literal">-y</span></span><br></pre></td></tr></table></figure><p>官方推荐了<code>npm</code>，<code>yarn</code>，<code>pnpm</code>三种工具，任选其一即可（<code>npm</code>工具为<code>node</code>自带的包管理工具，可自由使用；<code>yarn</code>或<code>pnpm</code>工具需要提前安装）。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># with npm</span></span><br><span class="line">npm install typescript <span class="literal">--save-dev</span></span><br><span class="line"><span class="comment"># with yarn</span></span><br><span class="line">yarn add typescript <span class="literal">--dev</span></span><br><span class="line"><span class="comment"># with pnpm</span></span><br><span class="line">pnpm add typescript <span class="literal">-D</span></span><br></pre></td></tr></table></figure><p>在安装 ts 时，编译工具<code>tsc</code>也会被自动安装。待安装完成，在项目根目录下新建一个<code>app.ts</code>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.ts</span></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;app&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">charAt</span>(<span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>即可通过以下任一方式运行<code>tsc</code>，编译成功后会在和<code>app.ts</code>同级目录下多出一个<code>app.js</code>文件。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前目录下的app.ts文件编译为app.js</span></span><br><span class="line"><span class="comment"># npm</span></span><br><span class="line">npx tsc app.ts</span><br><span class="line"><span class="comment"># yarn</span></span><br><span class="line">yarn tsc app.ts</span><br><span class="line"><span class="comment"># pnpm</span></span><br><span class="line">pnpm tsc app.ts</span><br></pre></td></tr></table></figure><p><code>app.js</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;app&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">charAt</span>(<span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>这个<code>js</code>文件和<code>app.ts</code>看起来没有差别，这是因为我们没有在<code>app.ts</code>里没有进行类型约束。与类型的相关内容会在后面谈到。现在我们来让<code>app.ts</code>出一点“错误”，将<code>str</code>换成数组，编辑器会把错误代码用红色波浪线标出，如果此时在命令行运行<code>yarn tsc app.ts</code>，控制台便会报错。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.ts</span></span><br><span class="line"><span class="keyword">const</span> str = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;p&quot;</span>, <span class="string">&quot;p&quot;</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">charAt</span>(<span class="number">0</span>)); <span class="comment">// charAt会被</span></span><br></pre></td></tr></table></figure><p>尽管如此，报错了的代码依旧会被编译成<code>js</code>文件。我们可以在<code>tsc</code>命令后加上编译的相关配置指令来进行控制。比如，加上<strong><code>--noEmitOnError</code></strong>之后，一旦报错便不会生成<code>js</code>文件。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc <span class="literal">--noEmitOnError</span> hello.ts</span><br></pre></td></tr></table></figure><p>但是 ts 的编译配置项非常多，如果每次都通过在命令行加入指令来进行相关控制，无疑非常繁琐。因此我们可以在<strong><code>tsconfig.json</code></strong>里编写相关配置，这样我们执行<code>tsc</code>命令时，编译器会默认从当前目录逐步向上层目录查找并读取<code>tsconfig.json</code>里的配置项。</p><h2 id="二-、配置文件：tsconfig-json"><a href="#二-、配置文件：tsconfig-json" class="headerlink" title="(二)、配置文件：tsconfig.json"></a>(二)、配置文件：<code>tsconfig.json</code></h2><p>在运行<code>tsc</code>命令时，我们可以在后面添加指令来指定相关配置。但是我们会更倾向于在<code>tsconfig.json</code>里对相关指令进行配置，以减少重复、繁琐的操作。在<code>Vue</code>、<code>React</code>等框架搭建的项目里，一般都已生成初步配置好了的<code>tsconfig.json</code>文件。本篇只进行解基础内容的分享，有关配置的章节将在后续推出。</p><h2 id="三-、类型基础"><a href="#三-、类型基础" class="headerlink" title="(三)、类型基础"></a>(三)、类型基础</h2><p>这里介绍部分 TS 基础类型，关于类型的进阶将在后续篇章中单独介绍。注意不要将基础类型和 js 基本数据类型混为一谈。基础类型可以理解为 ts 内置的各种类型，而非我们人为定义出的类型。TS 有多种基础类型，这些类型可以用来进行组合，从而得到我们需要的人为定义的类型。TS 在声明变量时，在变量名后加上冒号<mark>: </mark>和类型名来进行变量的类型注释。如果不添加类型注释，则 TS 会根据变量的初始值进行<mark><strong>类型推论</strong></mark>，自动推断出该变量属于什么类型。如果也没有初始值，则会被推断为<strong>any</strong>类型。</p><h3 id="1-原有的基本数据类型"><a href="#1-原有的基本数据类型" class="headerlink" title="1. 原有的基本数据类型"></a>1. 原有的基本数据类型</h3><ul><li><strong><code>string</code></strong>：字符串类型，注意<code>String</code>在<code>js</code>里已经有特殊意义了，而小写的<code>string</code>才是<code>Typescript</code>用来表示字符串的类型名称，即在注释变量类型为字符串时，使用小写的<code>string</code>，而不是大写的<code>String</code>，注意不要混淆了两者；<code>number</code>和<code>boolean</code>同理。</li><li><strong><code>number</code></strong>：数字类型；</li><li><p><strong><code>boolean</code></strong>：布尔类型；</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明变量类型，可以不赋初值，后续给num赋的值必须是number类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">num</span>: <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">str</span>: <span class="built_in">string</span> = <span class="string">&quot;typescript&quot;</span>;</span><br><span class="line"><span class="comment">// 类型推断：TS会自动推断出bool的类型为boolean</span></span><br><span class="line"><span class="keyword">let</span> bool = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-Array"><a href="#2-Array" class="headerlink" title="2. Array"></a>2. <code>Array</code></h3><p><code>Array</code>是数组类型，属于对象类型的一种。由于数组内会有数组成员，因此，在声明数组变量的时候，还要给数组成员添加类型注释，一般有两种常见方式：<strong><code>Type[]</code></strong>、<strong><code>Array&lt;Type&gt;</code></strong>。后者涉及<strong>泛型</strong>概念，将在后续介绍。其中，<code>Type</code>指代数组成员的类型，可以是基础类型，也可以是人为定义的类型 (关于数组的变形，元组类型，将在对象类型的章节介绍)。例如，要声明一个存放字符串的数组变量：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">arr1</span>: <span class="built_in">string</span>[];</span><br><span class="line"><span class="comment">// 也可以像下面</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr2</span>: <span class="title class_">Array</span>&lt;<span class="built_in">string</span>&gt;;</span><br></pre></td></tr></table></figure><h3 id="3-object"><a href="#3-object" class="headerlink" title="3. object"></a>3. <code>object</code></h3><p>对象类型是我们平时更为常见的类型。在本篇只给出一些简单定义，后续篇章中会进行单独介绍。一个对象类型的变量可以通过键值对来存储多个数据。定义一个对象类型，可以简单地列出它的各个属性及属性的类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个包含name, age, gender属性的变量obj</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>: &#123; <span class="attr">name</span>: <span class="built_in">string</span>; <span class="attr">age</span>: <span class="built_in">number</span>; <span class="attr">gender</span>: <span class="string">&quot;gg&quot;</span> | <span class="string">&quot;mm&quot;</span> &#125;;</span><br></pre></td></tr></table></figure><p>之后给 obj 赋值时<strong>必须有且只能有</strong><code>name</code>，<code>age</code>，<code>gender</code>三个属性，且属性值应为相应的类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 会报错,多了一个beauty属性,因此类型不合</span></span><br><span class="line">obj = &#123; <span class="attr">name</span>: <span class="string">&quot;yy&quot;</span>, <span class="attr">age</span>: <span class="number">22</span>, <span class="attr">gender</span>: <span class="string">&quot;mm&quot;</span>, <span class="attr">beauty</span>: <span class="number">100</span> &#125;;</span><br><span class="line"><span class="comment">// 报错，缺少了gender属性</span></span><br><span class="line">obj = &#123; <span class="attr">name</span>: <span class="string">&quot;yy&quot;</span>, <span class="attr">age</span>: <span class="number">22</span> &#125;;</span><br><span class="line"><span class="comment">// 正确赋值</span></span><br><span class="line">obj = &#123; <span class="attr">name</span>: <span class="string">&quot;yy&quot;</span>, <span class="attr">age</span>: <span class="number">22</span>, <span class="attr">gender</span>: <span class="string">&quot;mm&quot;</span> &#125;;</span><br></pre></td></tr></table></figure><p>如果想要让某个属性变为可选项，则可以在定义对象类型时在属性名后使用问号”?”：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将gender定义为可选项</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>: &#123; <span class="attr">name</span>: <span class="built_in">string</span>; <span class="attr">age</span>: <span class="built_in">number</span>; gender?: <span class="string">&quot;gg&quot;</span> | <span class="string">&quot;mm&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line">obj = &#123; <span class="attr">name</span>: <span class="string">&quot;yy&quot;</span>, <span class="attr">age</span>: <span class="number">22</span>, <span class="attr">gender</span>: <span class="string">&quot;mm&quot;</span> &#125;;</span><br><span class="line"><span class="comment">// 也正确，因为gender是可选的</span></span><br><span class="line">obj = &#123; <span class="attr">name</span>: <span class="string">&quot;yy&quot;</span>, <span class="attr">age</span>: <span class="number">22</span> &#125;;</span><br></pre></td></tr></table></figure><p>在某个属性被定义为可选项之后，一旦给该对象赋值时，没有传入该属性，它的取值便会成为<code>undefined</code> (注意<strong>这与一开始边定义<code>gender: &#39;gg&#39; | &#39;mm&#39; | undefined</code>不同</strong>。)</p><p>使用可选项有些地方需要注意，如<strong>在函数的形参中</strong>存在可选项，此时由于<code>gender</code>属性可能为<code>undefined</code>，我们在使用时需要在该属性后面加上英文感叹号”<code>!</code>“进行<strong>非空断言</strong>，明确它不是<code>undefined</code>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">obj: &#123; name: <span class="built_in">string</span>; age: <span class="built_in">number</span>; gender?: <span class="string">&quot;gg&quot;</span> | <span class="string">&quot;mm&quot;</span> &#125;</span>) &#123;</span><br><span class="line">  <span class="comment">// 使用!进行非空断言</span></span><br><span class="line">  obj.<span class="property">gender</span>!.<span class="title function_">replace</span>(<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-Union-Types-联合类型"><a href="#4-Union-Types-联合类型" class="headerlink" title="4. Union Types 联合类型"></a>4. <code>Union Types</code> 联合类型</h3><p><code>Union Types</code>是指使用 “<code>|</code>“符号来把多个类型联合成一个类型，一个联合类型的变量，其值可以是联合类型的任何一个子类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义a为联合类型，则a可以是string类型也可以是number类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"><span class="comment">// a可以是string</span></span><br><span class="line">a = <span class="string">&quot;union types&quot;</span>;</span><br><span class="line"><span class="comment">// a也可以是number</span></span><br><span class="line">a = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>在<strong>函数的形参中</strong>使用联合类型时有一些注意事项，如在上面的例子中，<code>a</code> 的类型是<code>string | number</code>，此时<code>a</code>无法调用字符串方法，因为<code>a</code>有可能是一个<code>number</code>；同理，也不能直接调用数字类型的方法。当然，也不能直接赋值给<code>string</code>类型的变量或者<code>number</code>类型的变量。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"><span class="comment">// a可以是string</span></span><br><span class="line">a = <span class="string">&quot;union types&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">b</span>: <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>: <span class="built_in">number</span>;</span><br><span class="line"><span class="comment">// 当开启了严格空值检查时，以下两次赋值都不合法</span></span><br><span class="line">b = a;</span><br><span class="line">c = a;</span><br></pre></td></tr></table></figure><p>当然，如果每个子类型都具有共同的方法，则可以调用该共同的方法。例如：数组和字符串都具有<code>slice</code>方法，则联合类型<code>string | number[]</code> 的变量可以调用<code>slice</code>方法。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params">obj: <span class="built_in">string</span> | <span class="built_in">number</span>[]</span>) &#123;</span><br><span class="line">  <span class="comment">// 可以直接调用slice方法</span></span><br><span class="line">  <span class="keyword">const</span> a = obj.<span class="title function_">slice</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-Type-Alias-类型别名"><a href="#5-Type-Alias-类型别名" class="headerlink" title="5. Type Alias 类型别名"></a>5. <code>Type Alias</code> 类型别名</h3><p>使用<strong><code>type</code></strong>关键字给你的类型起一个别名，以后就可以使用别名来指代这个类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Point</span> = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">ID</span> = <span class="built_in">number</span> | <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类型别名Point</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">p</span>: <span class="title class_">Point</span> = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">123</span>,</span><br><span class="line">  <span class="attr">y</span>: <span class="number">222</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="6-Interfaces"><a href="#6-Interfaces" class="headerlink" title="6. Interfaces"></a>6. Interfaces</h3><p>通过关键字<strong><code>interface</code></strong>，来定义一个接口，实际是一个对象类型，用于规定一个对象的形状。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printCoord</span>(<span class="params">pt: Point</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;The coordinate&#x27;s x value is &quot;</span> + pt.<span class="property">x</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;The coordinate&#x27;s y value is &quot;</span> + pt.<span class="property">y</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">printCoord</span>(&#123; <span class="attr">x</span>: <span class="number">100</span>, <span class="attr">y</span>: <span class="number">100</span> &#125;);</span><br></pre></td></tr></table></figure><p>简单说说<strong><code>interface</code>与类型别名的区别</strong>：</p><ul><li><code>interface</code> 可以通过 <strong><code>extends</code></strong>关键字来<strong>继承</strong>另一个<code>interface</code>，而<code>type</code>通过 <code>&amp;</code>符号来连接不同的对象属性；</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承Animal接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">skull</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承了Animal接口的属性name</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">dog</span>: <span class="title class_">Dog</span> = &#123;</span><br><span class="line">  <span class="attr">skull</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;wangcai&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型别名通过&amp;符号来拓展属性</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Dog2</span> = <span class="title class_">Animal</span> &amp; &#123;</span><br><span class="line">  <span class="attr">skull</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>interface</code>可以进行拓展，<code>Type</code>不可以</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">skull</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拓展interface的内容</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时Dog类型包含name,skull,age三个</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">dog</span>: <span class="title class_">Dog</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;wangcai&quot;</span>,</span><br><span class="line">  <span class="attr">skull</span>: <span class="number">12</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个Dog2类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Dog2</span> = &#123;</span><br><span class="line">  <span class="attr">skull</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会报错，Dog2重复了</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Dog2</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>interface</code>定义对象的形状，<code>type</code>不仅可以用于对象，也可以用于其它类型</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">TypeA</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TypeB</span> = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TypeC</span> = <span class="title class_">TypeA</span> | <span class="title class_">TypeB</span>;</span><br></pre></td></tr></table></figure><h3 id="7-Intersection-Types-交叉类型"><a href="#7-Intersection-Types-交叉类型" class="headerlink" title="7. Intersection Types 交叉类型"></a>7. <code>Intersection Types</code> 交叉类型</h3><p>用 <code>&amp;</code> 符号来连接多个类型，属于交叉类型 <code>A &amp; B</code> 的变量，既满足<code>A</code>的约束，又满足<code>B</code>的约束。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">TypeA</span> = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TypeB</span> = <span class="title class_">Array</span>&lt;<span class="built_in">boolean</span>&gt; | <span class="built_in">number</span>;</span><br><span class="line"><span class="comment">// TypeC既满足TypeA又满足TypeB，因此TypeC是number</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TypeC</span> = <span class="title class_">TypeA</span> &amp; <span class="title class_">TypeB</span>;</span><br><span class="line"><span class="comment">// a是number类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="title class_">TypeC</span> = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// b是TypeA类型，它的值是个string，因此不能赋值给a</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">b</span>: <span class="title class_">TypeA</span> = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">a = b; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>也可以用来拓展对象类型的属性：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> B = &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">gender</span>: <span class="string">&quot;男&quot;</span> | <span class="string">&quot;女&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 类型C是既满足A又满足B，即C既包含A的所有属性，又包含B的所有属性，</span></span><br><span class="line"><span class="comment">// 从而实现属性拓展</span></span><br><span class="line"><span class="keyword">type</span> C = A &amp; B;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>: C = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;cc&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">gender</span>: <span class="string">&quot;男&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意 <strong><code>&amp;</code> 和 | 的区别</strong>：”<code>&amp;</code>“可以合并多个对象类型的属性，使得到的新的对象类型包含其它所有类型的全部属性；”<code>&amp;</code>“可以获得多个类型之间的公共子类型；”<code>|</code>“可以联合多个类型，得到的新类型的值，只需满足其中一种子类型即可。</p><h3 id="8-Literal-Types-字面量类型"><a href="#8-Literal-Types-字面量类型" class="headerlink" title="8. Literal Types 字面量类型"></a>8. <code>Literal Types</code> 字面量类型</h3><p>通过字面量来定义类型，字面量的值可以是任意一个类型的值，可以将多个不同类型的字面量进行组合，此时得到的变量上的方法无法进行合法调用，因为变量可能为其它不含该方法的类型（与联合类型同理）。因此需要进行类型精简或类型断言。注意在变量声明时进行类型注释了的才能被字面量类型约束，如果没有类型注释，则会按照类型推论的结果来判定类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义gender只能取值为 &#x27;男&#x27; 或 &#x27;女&#x27; 中的一种</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">gender</span>: <span class="string">&quot;男&quot;</span> | <span class="string">&quot;女&quot;</span> = <span class="string">&quot;男&quot;</span>;</span><br><span class="line"><span class="comment">// gender2经类型推论string类型</span></span><br><span class="line"><span class="keyword">let</span> gender2 = <span class="string">&quot;男&quot;</span>;</span><br><span class="line"><span class="comment">// 多种类型字面量的组合</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="string">&quot;未知数&quot;</span> | <span class="number">1</span> | &#123; <span class="attr">y</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="comment">// 严格类型检查时不能合法调用</span></span><br><span class="line">x.<span class="title function_">split</span>(<span class="string">&quot;知&quot;</span>) &lt;</span><br><span class="line">  <span class="comment">// 进行类型断言后可合法</span></span><br><span class="line">  <span class="built_in">string</span> &gt;</span><br><span class="line">  x.<span class="title function_">split</span>(<span class="string">&quot;知&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="9-null-和-undefined-与-非空断言"><a href="#9-null-和-undefined-与-非空断言" class="headerlink" title="9. null 和 undefined 与 非空断言"></a>9. <code>null</code> 和 <code>undefined</code> 与 非空断言</h3><p>两个空值类型，和在<code>js</code>里的区别一致。开启/关闭严格空值检查会影响到空值类型的行为。当我们知道一个变量不会为空时，可以在该变量后使用英文感叹号 “<code>!</code>“ ，进行临时<strong>非空断言 （<code>Non-null Assertion</code>）</strong>。这点在函数中尤为重要。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyType</span> = <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">value</span>: <span class="title class_">MyType</span> = <span class="string">&quot;I love China&quot;</span>;</span><br><span class="line"><span class="comment">// 对value进行非空断言</span></span><br><span class="line">value!.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="10-Enums-枚举类型"><a href="#10-Enums-枚举类型" class="headerlink" title="10. Enums 枚举类型"></a>10. <code>Enums</code> 枚举类型</h3><p>枚举类型是一组被有意义地命名了的常量的集合。与其它类型本质上不同的是，其它的类型都只是类型，而枚举类型却是可以使用的值。<strong>通过<code>enum</code>关键字声明某个变量为枚举类型的值</strong>，使用枚举类型，可以让我们不去关注变量实际的值，而使用更有意义的名字来代表实际的值。例如，在表示性别时，我们可以简单地用数字 1 和 2 来表示 男 和 女。那么在实际使用中，我们需要知道到底是 1 代表男还是 1 代表女。当数据从前端传到后端，后端的小伙伴又需要去了解哪个数字代表哪个性别。这对我们来说就不太友好。所以，我们可以使用枚举类型来定义一组表示性别的常量，之后使用时，只需取常量的名字即可。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Gender</span> &#123;</span><br><span class="line">  <span class="attr">male</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">female</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">secret</span>: <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举类型包括数字型枚举、字符串型枚举、异构枚举等等。此处只简要了解一下枚举类型的的存在，后续会写一篇枚举类型的深入。</p><h3 id="11-any"><a href="#11-any" class="headerlink" title="11. any"></a>11. <code>any</code></h3><p><code>any</code>可以指代任何类型，可以被赋值给任意类型的变量。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给变量anyscript一个any类型，其值为数字123</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">anyscript</span>: <span class="built_in">any</span> = <span class="number">123</span>;</span><br><span class="line"><span class="comment">// 给变量typescript一个string类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">typescript</span>: <span class="built_in">string</span> = <span class="string">&quot;typescript&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值操作后，typescript变成了123，其类型发生了改变</span></span><br><span class="line">typescript = anyscript;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 而编译器会认为typescript变量为string类型，且允许我们调用string类型的方法</span></span><br><span class="line">typescript.<span class="title function_">split</span>(<span class="string">&quot;c&quot;</span>);</span><br><span class="line"><span class="comment">// 而事实上此时变量typescript的值已经变为了数字123，调用string的方法就会</span></span><br></pre></td></tr></table></figure><p>这个看起来很便捷的<code>any</code>类型，在这种时候就会引发问题，造成类型污染。因此，我们应该避免使用<code>any</code>，以免走进<code>Anyscript</code>的误区。</p><h3 id="12-unknown与类型断言"><a href="#12-unknown与类型断言" class="headerlink" title="12. unknown与类型断言"></a>12. <code>unknown</code>与类型断言</h3><p><code>unknown</code>用来表示未知类型，和<code>any</code>相似，它的值可以是任何类型。不同的是，如果一个变量是<code>unknown</code>类型，那么它在被明确为某个确切的类型之前，不能调用任何方法，也不能被赋值给其它变量。你可以使用<mark><strong>类型断言</strong></mark>来<strong>临时</strong>人为明确一个 unknown 变量的确切类型。毕竟<strong>你永远比<code>Typescript</code>知道的多</strong>！类型断言一般有两种方式：使用 <code>a as Type</code> 或者 在需要进行类型断言的变量前使用尖括号：<code>&lt;Type&gt;a</code>，来明确变量<code>a</code>为<code>Type</code>类型。注意类型断言是临时的，因此它不会改变原来<code>unknown</code>变量的类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个unknown变量a，一个字符串变量b</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="built_in">unknown</span> = <span class="string">&quot;I am unknown type&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">b</span>: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里会报错，因为a为unknown类型，而且并没有明确它的具体类型，</span></span><br><span class="line"><span class="comment">// 不能被赋值给字符串变量b，哪怕a本身实际的值为字符串</span></span><br><span class="line">b = a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类型断言来明确a的具体类型为字符串string，</span></span><br><span class="line"><span class="comment">// 之后便可以赋值给字符串b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用as进行类型断言，可以用括号将其整体包裹起来，以进行对断言之后的变量a的操作</span></span><br><span class="line">b = a <span class="keyword">as</span> <span class="built_in">string</span>;</span><br><span class="line">b = (a <span class="keyword">as</span> <span class="built_in">string</span>) + <span class="string">&quot;!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以使用&lt;Type&gt;a的形式进行类型断言</span></span><br><span class="line">b = &lt;<span class="built_in">string</span>&gt;a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 之后 a 的类型依然是unknown</span></span><br></pre></td></tr></table></figure><p>也许你会觉得使用<code>unknown</code>类型有些繁琐。但相比起<code>any</code>类型容易引发的错误，<code>unknown</code>类型的使用足够安全。因此，如果有需要使用不明确的类型时，应该首选<code>unknown</code>而不是<code>any</code>。毕竟谁也不愿意，一杯茶，一个圈，一个<code>BUG</code>改一天(甚至还在排查错误原因)。</p><h3 id="13-never-和-void"><a href="#13-never-和-void" class="headerlink" title="13. never 和 void"></a>13. <code>never</code> 和 <code>void</code></h3><p><code>void</code>用于表示函数返回空值；<code>never</code>用于表示不该使用的值或者函数不应该有返回值，在我们平常的工作中<code>never</code>的应用场景较少。</p><h3 id="14-不常用的类型"><a href="#14-不常用的类型" class="headerlink" title="14.不常用的类型"></a>14.不常用的类型</h3><p><strong><code>Bigint</code>和<code>Symbol</code></strong>是<code>ES6</code>之后加入的基本数据类型，目前在日常工作中的使用并不多见。<code>TS</code>中的这两种类型和<code>JS</code>中一致。</p><ul><li><p><strong><code>bigint</code></strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用BigInt函数来创建一个bigint类型的变量</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">oneHundred</span>: <span class="built_in">bigint</span> = <span class="title class_">BigInt</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用字面量语法 数字 + n 来创建bigint类型的变量</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">anotherHundred</span>: <span class="built_in">bigint</span> = <span class="number">100n</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>Symbol</code></strong></p><p><code>Symbol</code>是<code>ES6</code>之后新增的一种基本数据类型，每个<code>Symbol</code>类型的变量，其值都是唯一的，即使传入相同的参数，返回的结果也永远不会相等。一般使用<code>Symbol</code>函数来创建。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Symbol函数创建Symbol类型的变量/常量</span></span><br><span class="line"><span class="keyword">const</span> first1 = <span class="title class_">Symbol</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> first2 = <span class="title class_">Symbol</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"></span><br><span class="line">first1 === first2; <span class="comment">// 永远是false</span></span><br></pre></td></tr></table></figure></li></ul><p>类型基础的内容就介绍到这里啦，下一篇将着重介绍在函数中使用各种类型时需要注意的问题，例如如何进行类型精确。如果文章描述有不妥之处，恳请不吝指出，我们下一篇再见！</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前 端 </tag>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS笔记之Promise进阶：从A+规范到手动实现</title>
      <link href="/articals/20cb1782/"/>
      <url>/articals/20cb1782/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Promise-A-规范"><a href="#一、Promise-A-规范" class="headerlink" title="一、Promise A+ 规范"></a>一、Promise A+ 规范</h2><h3 id="（一）相关概念"><a href="#（一）相关概念" class="headerlink" title="（一）相关概念"></a>（一）相关概念</h3><ol><li><p><strong>promise</strong>：一个具有<strong>then 方法</strong>的对象/函数，其行为遵循 Promise A+ 规范；</p></li><li><p><strong>thenable</strong>：具有<strong>then 方法</strong>的对象/函数;</p></li><li><p><strong>value</strong>：promise 实例的状态为兑现/成功时的值，即<mark> <strong>resolve</strong> </mark> 的参数，可为任意类型；</p></li><li><p><strong>reason</strong>：promise 实例的状态为拒绝/失败时的值，即<mark> <strong>reject</strong> </mark>的值，表示拒绝/失败的原因；</p></li><li><p><strong>exception</strong>：异常值</p></li></ol><h3 id="（二）A-规范"><a href="#（二）A-规范" class="headerlink" title="（二）A+ 规范"></a>（二）A+ 规范</h3><ol><li><strong>states</strong></li></ol><p>Promise 实例的状态，共有三种: pending，fulfilled，rejected。</p><p>(1) <strong>pending</strong>：</p><ul><li>初始状态，可以改变，在 resolve / reject 执行之前都是这个状态。</li><li>在 resolve 执行后从 pending 状态改变为 fufilled；</li><li>在 reject 执行后从 pending 状态改变为 rejected；</li></ul><p>(2) <strong>fulfilled</strong>：</p><ul><li>是一种最终状态，不可再发生改变；</li><li>当处于 pending 状态的 promise 在经过<mark>resolve</mark>之后，其状态会变为 fulfilled；</li><li>必须有一个 value 值，一般为 resolve 传入的参数，若 resolve 没有传参，则 value 值为 undefined；</li></ul><p>(3)<strong>rejected</strong>：</p><ul><li>也是一种最终状态，不可再发生改变；</li><li>当处于 pending 状态的 promis 经过<mark>reject</mark>后，其状态会变为 rejected；</li><li>必须有一个 reason 值，一般为 reject 传入的参数，若未传参数，则 reason 值为 undefined；</li></ul><p>需要注意的是，<strong>promise 的状态只能从 pending 状态转变为 fulfilled 或者 rejected</strong>，不可逆转，也不会在 fulfilled 和 rejected 之间转变。因此，一旦 promise 的状态已经是 fulfilled 或者 rejected，即使之后又经过了 resolve 或 reject，promise 的状态也不会再发生变化。</p><ol><li><strong>then</strong>方法</li></ol><p>根据 A+ 规范，promise 应该提供一个 then 方法，接收两个参数，用于访问最终状态的结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line">promise.<span class="title function_">then</span>(onFulfilled, onRejected);</span><br></pre></td></tr></table></figure><ul><li><strong>then 方法的参数</strong>：<mark><strong>onFulfilled</strong></mark>应该是一个<strong>function</strong>，如果不是，则 onFulfilled 应该<strong>被忽略</strong>，而使用内部默认的 function 来替代它。<mark><strong>onRejected</strong></mark>同理。</li><li><strong>onFulfilled</strong>：<strong>在 promise 的状态变为 fulfilled 后</strong>，应该调用 onFulfilled，此时，onFulfilled 的参数是 value；而在 promise 状态变为 fulfilled 之前，则不应该调用此函数。此外，promise 的状态只会发生一次变化，相对应的，<strong>一个 onFulfilled 也只能调用一次</strong>。</li><li><strong>onRejected</strong>：<strong>在 promise 的状态变为 rejected 后</strong>，应该调用 onRejected，此时，onRejected 的参数是 reason；而在 promise 状态变为 rejected 之前，则不应该调用此函数。此外，promise 的状态只会发生一次变化，相对应的，<strong>一个 onRejected 也只能调用一次</strong>。</li><li>onFulfilled 和 onRejected 的执行环境是在<mark><strong>微任务</strong></mark>里。可使用<mark><strong>queueMicrotask( )</strong></mark>来将其加入微任务队列，不使用 setTimeout 的原因是：setTimeout 为宏任务，不符合 A+ 规范。</li><li><p><strong>then 方法可以多次调用</strong>。在 promise 的状态变为 fulfilled 后，其所有的 onFulfilled 回调按照 then 的顺序执行；在 promise 的状态变为 rejected 后，其所有的 onRejected 回调按照 then 的顺序执行；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 可多次调用then方法，其中回调函数按照then的顺序</span></span><br><span class="line">promise.<span class="title function_">then</span>(onFulfilled, onRejected);</span><br><span class="line">promise.<span class="title function_">then</span>(onFulfilled, onRejected);</span><br><span class="line">promise.<span class="title function_">then</span>(onFulfilled, onRejected);</span><br><span class="line">promise.<span class="title function_">then</span>(onFulfilled, onRejected);</span><br></pre></td></tr></table></figure></li><li><p>then 方法的返回值</p><p><strong>then 方法的返回值应该是一个船新的 promise</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// then方法返回一个新的promise，与</span></span><br><span class="line"><span class="keyword">const</span> promise2 = promise.<span class="title function_">then</span>(onFulfilled, onRejected);</span><br><span class="line"><span class="comment">// promise2 同样可以调用then方法</span></span><br><span class="line">promise2.<span class="title function_">then</span>(callback1, callback2);</span><br></pre></td></tr></table></figure><ul><li>根据 onFilfilled 或者 onRejected 执行的结果，假设为 a，调用<mark><strong>resolvePromise( )</strong></mark>来解析 promise；</li><li>当 onFulfilled 或 onRejected 执行时报错了，则 promise2 就需要被 reject ；</li><li>若 promise1 的 then 方法中，onFulfilled 不是一个 function，则会调用内部的默认函数，使 promise2 以 promise1 的 value 来触发 fulfilled 。</li><li>若 promise1 的 then 方法中，onRejected 不是一个 function，则会调用内部的默认函数，使 promise2 以 promise1 的 reason 来触发 rejected。</li></ul></li><li><p><strong>resolvePromise( )</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">resolvePromise</span>(promise2, a, resolve, reject);</span><br></pre></td></tr></table></figure><p>接下来进行条件判断：</p><ul><li><strong>promise2 === a</strong>，reject Type error；</li><li><p><strong>如果 a 是一个 promise</strong>：</p><ul><li>a 的状态是 pending，则 promise2 也会处于 pending 状态直至 a 的状态改变；</li><li>a 的状态是 fulfilled，则 promise2 也以相同的 value 触发 fulfilled；</li><li>a 的状态是 rejected，则 promise2 以相同的 reason 触发 rejected；</li></ul></li><li><p><strong>如果 a 是一个 object 或 function</strong>：</p><p>尝试取 a 的 then 方法看是否出错：let then = a.then，若出错则把错误 reject 出去。取到 then 之后，判断 then 的类型，如果 then 是一个函数则通过 call 调用 then：then.call(a)，否则 resolve(a)；</p></li><li><p><strong>如果 a 是其他类型</strong>，则 resolve (a)；</p></li></ul></li></ul><h2 id="二、如何实现一个-Promise"><a href="#二、如何实现一个-Promise" class="headerlink" title="二、如何实现一个 Promise"></a>二、如何实现一个 Promise</h2><h3 id="1-定义状态类型"><a href="#1-定义状态类型" class="headerlink" title="1.定义状态类型"></a>1.定义状态类型</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PENDING</span> = <span class="string">&quot;pending&quot;</span>,</span><br><span class="line">  <span class="variable constant_">FULFILLED</span> = <span class="string">&quot;fulfilled&quot;</span>,</span><br><span class="line">  <span class="variable constant_">REJECTED</span> = <span class="string">&quot;rejected&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="2-初始化-class"><a href="#2-初始化-class" class="headerlink" title="2.初始化 class"></a>2.初始化 class</h3><p>定义<strong>初始状态</strong>，<strong>value</strong>以及<strong>reason</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyPromise</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">PENDING</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reason</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-resolve-和-reject"><a href="#3-resolve-和-reject" class="headerlink" title="3.resolve 和 reject"></a>3.resolve 和 reject</h3><ul><li>更改 status，从 pending 变为 fulfilled 或 rejected；</li><li><p>更新 value 或 reason 值；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyPromise</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ... 初始化</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">FULFILLED</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">reject</span>(<span class="params">reason</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">reason</span> = reason;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">REJECTED</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-构造函数入参"><a href="#4-构造函数入参" class="headerlink" title="4.构造函数入参"></a>4.构造函数入参</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure><ul><li>入参为一个函数 <mark><strong>resolver</strong></mark>，resolver 接收两个参数：resolve 和 reject；</li><li><strong>执行 new Promise 时，就会同步执行这个函数，发生任何的错误就会被 reject 出去。</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyPromise</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">resolver</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">PENDING</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reason</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> resolver === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">// resolver是函数则执行resolver</span></span><br><span class="line">      <span class="comment">// 错误捕获</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="title function_">resolver</span>(<span class="variable language_">this</span>.<span class="property">resolve</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>), <span class="variable language_">this</span>.<span class="property">reject</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>));</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">reject</span>(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// resolver不是函数则抛出错误</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`Promise resolver <span class="subst">$&#123;resolver&#125;</span> is not a function`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">reject</span>(<span class="params">reason</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-then-方法"><a href="#5-then-方法" class="headerlink" title="5.then 方法"></a>5.then 方法</h3><ul><li>入参：<strong>onFulfilled</strong>，<strong>onRejected</strong></li><li>返回值：新的 promise</li><li>需要配判断入参是否为函数，如果不是则调用默认函数传递 value 和 reason</li></ul><p>先来看看下面这个写法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyPromise</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">resolver</span>) &#123;</span><br><span class="line">    <span class="comment">// ... 初始化、执行resolver</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">reject</span>(<span class="params">reason</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">then</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> realOnFulfilled = <span class="title function_">isFunction</span>(onFulfilled)</span><br><span class="line">      ? onFulfilled</span><br><span class="line">      : <span class="function">(<span class="params">vaule</span>) =&gt;</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> realOnRejected = <span class="title function_">isFunction</span>(onRejected)</span><br><span class="line">      ? onRejected</span><br><span class="line">      : <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> reason;</span><br><span class="line">        &#125;;</span><br><span class="line">    <span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">switch</span> (<span class="variable language_">this</span>.<span class="property">status</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="attr">FULFILLED</span>:</span><br><span class="line">          <span class="title function_">realOnFulfilled</span>();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="attr">REJECTED</span>:</span><br><span class="line">          <span class="title function_">realOnRejected</span>();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> promise2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">isFunction</span>(<span class="params">func</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> func === <span class="string">&quot;function&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个写法存在问题，只能处理同步操作，一旦有异步执行 resolve 或 reject，则调用 then 方法时，status 仍为 pending。另外，then 方法可以执行多次，因此，需要两个队列来存储<strong>realOnFulfilled</strong> 和 <strong>realOnrejected</strong>，一旦 status 状态为 pending，则将 realOnFulfilled 和 realOnRejected 添加进队列里，以便后续 status 值发生变化时依次调用。因此做如下改进：</p><ul><li>增加两个队列<mark><strong>FULFILLED_CALLBACK_LIST</strong></mark>和<mark><strong>REJECTED_CALLBACK_LIST</strong></mark>分别在 pending 状态时存放 realOnFulfilled 和 realOnRejected；</li><li><p>在合适的时机调用队列里的回调函数，有两种方案：</p><ul><li>在 resolve 和 reject 里，当 status 变为 fulfilled 或 rejected 时调用相应队列里的函数；</li><li><strong>通过存取器 setter 来监听 status</strong>，一旦 status 发生变化，则一次调用相应队列里的处理程序。</li></ul><p>这里我选择了后者，能让代码结构更清晰。如果在 resolve 和 reject 里调用，会增加代码的复杂性和混乱程度。</p></li><li><p>此外，根据 A+ 规范，当 realOnFulfilled 或 realOnRejected 为微任务环境，执行出错时，需要将错误 reject 出去，触发 promise2 的 rejected。且根据其执行得到的结果 a 的不同，会在<mark><strong>resolvePromise</strong></mark>中有不同的操作。因此使用<mark><strong>queueMicrotask( )</strong></mark>将其放入微任务队列，并封装到<mark><strong>fulfilledMicroTask</strong></mark>和<mark><strong>rejectedMicroTask</strong></mark>中进行错误捕获。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyPromise</span> &#123;</span><br><span class="line">  <span class="comment">// 添加队列</span></span><br><span class="line">  <span class="variable constant_">FULFILLED_CALLBACK_LIST</span> = [];</span><br><span class="line">  <span class="variable constant_">REJECTED_CALLBACK_LIST</span> = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 因为使用了存取器，增加一个私有变量_status来储存真正的status的值</span></span><br><span class="line">  _status = <span class="variable constant_">PENDING</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">resolver</span>) &#123;</span><br><span class="line">    <span class="comment">// ... 初始化、执行resolver</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过存取器setter来监听status</span></span><br><span class="line">  <span class="comment">// 需要一个私有变量_status来储存真正的status的值，否则在getter中会死循环</span></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">status</span>(<span class="params">newStatus</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_status</span> = newStatus;</span><br><span class="line">    <span class="keyword">switch</span> (newStatus) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="attr">FULFILLED</span>:</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">FULFILLED_CALLBACK_LIST</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">callback</span>) =&gt;</span></span><br><span class="line">          <span class="title function_">callback</span>(<span class="variable language_">this</span>.<span class="property">value</span>)</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="attr">REJECTED</span>:</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">REJECTED_CALLBACK_LIST</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">callback</span>) =&gt;</span></span><br><span class="line">          <span class="title function_">callback</span>(<span class="variable language_">this</span>.<span class="property">reason</span>)</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">status</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_status</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">resolve</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">reject</span>(<span class="params">reason</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">then</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> realOnFulfilled = <span class="variable language_">this</span>.<span class="title function_">isFunction</span>(onFulfilled)</span><br><span class="line">      ? onFulfilled</span><br><span class="line">      : <span class="function">(<span class="params">vaule</span>) =&gt;</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> realOnRejected = <span class="variable language_">this</span>.<span class="title function_">isFunction</span>(onRejected)</span><br><span class="line">      ? onRejected</span><br><span class="line">      : <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> reason;</span><br><span class="line">        &#125;;</span><br><span class="line">    <span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 捕获realOnFulfilled执行过程中的错误并reject出去</span></span><br><span class="line">      <span class="keyword">const</span> <span class="title function_">fulfilledMicroTask</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="title function_">queueMicrotask</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> a = <span class="title function_">realOnFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">resolvePromise</span>(promise2, a, resolve, reject);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="comment">// 捕获realOnRejected执行过程中的错误并reject出去</span></span><br><span class="line">      <span class="keyword">const</span> <span class="title function_">rejectedMicroTask</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="title function_">queueMicrotask</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> a = <span class="title function_">realOnRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>);</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">resolvePromise</span>(promise2, a, resolve, reject);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">switch</span> (<span class="variable language_">this</span>.<span class="property">status</span>) &#123;</span><br><span class="line">        <span class="comment">// 成功时调用realOnFulfilled</span></span><br><span class="line">        <span class="keyword">case</span> <span class="attr">FULFILLED</span>:</span><br><span class="line">          <span class="title function_">fulfilledMicroTask</span>();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 拒绝时调用realOnRejected</span></span><br><span class="line">        <span class="keyword">case</span> <span class="attr">REJECTED</span>:</span><br><span class="line">          <span class="title function_">rejectedMicroTask</span>();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 等待时将其放入队列</span></span><br><span class="line">        <span class="keyword">case</span> <span class="attr">PENDING</span>:</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">FULFILLED_CALLBACK_LIST</span>.<span class="title function_">push</span>(fulfilledMicroTask);</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">REJECTED_CALLBACK_LIST</span>.<span class="title function_">push</span>(rejectedMicroTask);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> promise2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">resolvePromise</span>(<span class="params">promise2, a, resolve, reject</span>) &#123;</span><br><span class="line">    <span class="comment">// 根据a的值进行不同的操作</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">isFunction</span>(<span class="params">func</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> func === <span class="string">&quot;function&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来实现<mark><strong>resolvePromise</strong></mark>来解析 a 的结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class MyPromise</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="title function_">resolvePromise</span>(<span class="params">promise2, a, resolve, reject</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(promise2 === a)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;The promise and the return value are the same&#x27;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(a <span class="keyword">instanceof</span> <span class="title class_">MyPromise</span>)&#123;</span><br><span class="line">    <span class="title function_">queueMicroTask</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      a.<span class="title function_">then</span>(</span><br><span class="line">        <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="title function_">resolvePromise</span>(promise2, res, resolve, reject);</span><br><span class="line">        &#125;,</span><br><span class="line">        reject</span><br><span class="line">      )</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> a === <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> a === <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(a === <span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">resolve</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> then = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      then = a.<span class="property">then</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">reject</span>(e)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">isFunction</span>(then))&#123;</span><br><span class="line">      <span class="comment">// 保证函数只能调用一次</span></span><br><span class="line">      <span class="keyword">let</span> hasCalled = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        then.<span class="title function_">call</span>(</span><br><span class="line">          x,</span><br><span class="line">          <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(hasCalled) <span class="keyword">return</span>;</span><br><span class="line">            hasCalled = <span class="literal">true</span>;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">resolvePromise</span>(promise2, res, resolve, reject)</span><br><span class="line">          &#125;, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(hasCalled) <span class="keyword">return</span>;</span><br><span class="line">            hasCalled = <span class="literal">true</span>;</span><br><span class="line">            <span class="title function_">reject</span>(e)</span><br><span class="line">          &#125;</span><br><span class="line">        )</span><br><span class="line">      &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        <span class="keyword">if</span>(hasCalled)&#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">reject</span>(e)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="title function_">resolve</span>(a)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="title function_">resolve</span>(a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h3 id="6-catch-方法"><a href="#6-catch-方法" class="headerlink" title="6. catch 方法"></a>6. catch 方法</h3><ul><li>catch 实质上就是调用了 then 方法，给第一个参数传入 null，返回一个新的 promise，即 promise2；</li><li>在 catch 方法未执行完之前，promise2 的 status 将一直是 pending；</li><li>catch 方法执行过程中如果报错，将触发 promise2 的 status 变为 rejected；</li><li>若 catch 方法执行完毕且没有报错，将触发 promise2 的 status 变为 fulfilled；</li><li>详见 resolvePromise 方法。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class MyPromise</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">catch</span>(onRejected)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(<span class="literal">null</span>, onRejected)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h3 id="7-Promise-resolve"><a href="#7-Promise-resolve" class="headerlink" title="7. Promise.resolve()"></a>7. Promise.resolve()</h3><p>静态方法，用提供的参数创建一个 rosolve 过的 promise。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyPromise</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">resolve</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="comment">// 只需要resolve，不需要reject</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(value);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-Promise-reject"><a href="#8-Promise-reject" class="headerlink" title="8. Promise.reject()"></a>8. Promise.reject()</h3><p>与 Promise.resolve 同理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyPromise</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">reject</span>(<span class="params">reason</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">reject</span>(reason);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，Promise 的核心功能都已基本实现。还剩下 Promise.all，Promise.race 等静态方法，有空再研究。以上代码整合如下，如有不足或错误之处，还望不吝指出，感激不尽！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义三种状态</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">PENDING</span> = <span class="string">&quot;pending&quot;</span>,</span><br><span class="line">  <span class="variable constant_">FULFILLED</span> = <span class="string">&quot;fulfilled&quot;</span>,</span><br><span class="line">  <span class="variable constant_">REJECTED</span> = <span class="string">&quot;rejected&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPromise</span> &#123;</span><br><span class="line">  <span class="comment">// 添加队列</span></span><br><span class="line">  <span class="variable constant_">FULFILLED_CALLBACK_LIST</span> = [];</span><br><span class="line">  <span class="variable constant_">REJECTED_CALLBACK_LIST</span> = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 因为使用了存取器，增加一个私有变量_status来储存真正的status的值</span></span><br><span class="line">  _status = <span class="variable constant_">PENDING</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">resolver</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">PENDING</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reason</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> resolver === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">// resolver是函数则执行resolver</span></span><br><span class="line">      <span class="comment">// 错误捕获</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="title function_">resolver</span>(<span class="variable language_">this</span>.<span class="property">resolve</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>), <span class="variable language_">this</span>.<span class="property">reject</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>));</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">reject</span>(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// resolver不是函数则抛出错误</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`Promise resolver <span class="subst">$&#123;resolver&#125;</span> is not a function`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过存取器setter来监听status</span></span><br><span class="line">  <span class="comment">// 需要一个私有变量_status来储存真正的status的值，否则在getter中会死循环</span></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">status</span>(<span class="params">newStatus</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_status</span> = newStatus;</span><br><span class="line">    <span class="keyword">switch</span> (newStatus) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="attr">FULFILLED</span>:</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">FULFILLED_CALLBACK_LIST</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">callback</span>) =&gt;</span></span><br><span class="line">          <span class="title function_">callback</span>(<span class="variable language_">this</span>.<span class="property">value</span>)</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="attr">REJECTED</span>:</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">REJECTED_CALLBACK_LIST</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">callback</span>) =&gt;</span></span><br><span class="line">          <span class="title function_">callback</span>(<span class="variable language_">this</span>.<span class="property">reason</span>)</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">status</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_status</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">resolve</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">FULFILLED</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">reject</span>(<span class="params">reason</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">reason</span> = reason;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">REJECTED</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">then</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> realOnFulfilled = <span class="variable language_">this</span>.<span class="title function_">isFunction</span>(onFulfilled)</span><br><span class="line">      ? onFulfilled</span><br><span class="line">      : <span class="function">(<span class="params">vaule</span>) =&gt;</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> realOnRejected = <span class="variable language_">this</span>.<span class="title function_">isFunction</span>(onRejected)</span><br><span class="line">      ? onRejected</span><br><span class="line">      : <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> reason;</span><br><span class="line">        &#125;;</span><br><span class="line">    <span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 捕获realOnFulfilled执行过程中的错误并reject出去</span></span><br><span class="line">      <span class="keyword">const</span> <span class="title function_">fulfilledMicroTask</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="title function_">queueMicrotask</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> a = <span class="title function_">realOnFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">resolvePromise</span>(promise2, a, resolve, reject);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="comment">// 捕获realOnRejected执行过程中的错误并reject出去</span></span><br><span class="line">      <span class="keyword">const</span> <span class="title function_">rejectedMicroTask</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="title function_">queueMicrotask</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> a = <span class="title function_">realOnRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>);</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">resolvePromise</span>(promise2, a, resolve, reject);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">switch</span> (<span class="variable language_">this</span>.<span class="property">status</span>) &#123;</span><br><span class="line">        <span class="comment">// 成功时调用realOnFulfilled</span></span><br><span class="line">        <span class="keyword">case</span> <span class="attr">FULFILLED</span>:</span><br><span class="line">          <span class="title function_">fulfilledMicroTask</span>();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 拒绝时调用realOnRejected</span></span><br><span class="line">        <span class="keyword">case</span> <span class="attr">REJECTED</span>:</span><br><span class="line">          <span class="title function_">rejectedMicroTask</span>();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 等待时将其放入队列</span></span><br><span class="line">        <span class="keyword">case</span> <span class="attr">PENDING</span>:</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">FULFILLED_CALLBACK_LIST</span>.<span class="title function_">unshift</span>(fulfilledMicroTask);</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">REJECTED_CALLBACK_LIST</span>.<span class="title function_">unshift</span>(rejectedMicroTask);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> promise2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">catch</span>(onRejected) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(<span class="literal">null</span>, onRejected);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">resolvePromise</span>(<span class="params">promise2, a, resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (promise2 === a) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">reject</span>(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;The promise and the return value are the same&quot;</span>)</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a <span class="keyword">instanceof</span> <span class="title class_">MyPromise</span>) &#123;</span><br><span class="line">      <span class="title function_">queueMicroTask</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        a.<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="title function_">resolvePromise</span>(promise2, res, resolve, reject);</span><br><span class="line">        &#125;, reject);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> a === <span class="string">&quot;object&quot;</span> || <span class="keyword">typeof</span> a === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">resolve</span>(a);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">let</span> then = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        then = a.<span class="property">then</span>;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">reject</span>(e);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">isFunction</span>(then)) &#123;</span><br><span class="line">        <span class="comment">// 保证函数只能调用一次</span></span><br><span class="line">        <span class="keyword">let</span> hasCalled = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          then.<span class="title function_">call</span>(</span><br><span class="line">            x,</span><br><span class="line">            <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (hasCalled) <span class="keyword">return</span>;</span><br><span class="line">              hasCalled = <span class="literal">true</span>;</span><br><span class="line">              <span class="variable language_">this</span>.<span class="title function_">resolvePromise</span>(promise2, res, resolve, reject);</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (hasCalled) <span class="keyword">return</span>;</span><br><span class="line">              hasCalled = <span class="literal">true</span>;</span><br><span class="line">              <span class="title function_">reject</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">          );</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          <span class="keyword">if</span> (hasCalled) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="title function_">reject</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(a);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">isFunction</span>(<span class="params">func</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> func === <span class="string">&quot;function&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 静态方法Promise.resolve()</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">resolve</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="comment">// 只需要resolve，不需要reject</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(value);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 静态方法Promise.reject()</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">reject</span>(<span class="params">reason</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">reject</span>(reason);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前 端 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
